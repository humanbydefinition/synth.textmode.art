/**
 * AUTO-GENERATED TYPE DEFINITIONS FOR MONACO INTELLISENSE
 * Generated: 2026-01-16T22:02:10.813Z
 * Config ID: textmode
 * 
 * This file contains:
 * - All .d.ts files from: textmode.js, textmode.synth.js
 * - Augmented methods INJECTED directly into original type definitions
 * - Minimal global declarations for the live coding environment
 */

export const typeDefinitions: Record<string, string> = {
  "file:///node_modules/textmode.js/dist/types/errors/Error.d.ts": "export declare class TextmodeError extends Error {\n    constructor(message: string, context?: any);\n    /**\n     * Create a formatted error message that includes context\n     */\n    static $createFormattedMessage(message: string, context?: any): string;\n    /**\n     * Format values for better display in error messages\n     */\n    private static _formatValue;\n}",
  "file:///node_modules/textmode.js/dist/types/errors/ErrorHandler.d.ts": "/**\n * Error handling levels to control how errors are reported and handled.\n *\n * Determines how validation failures and errors are processed throughout the library.\n * Each level provides different behavior for error reporting and execution flow control.\n *\n * @note\n * This feature is currently not fully implemented across all modules,\n * and most `textmode.js` functions will still throw errors if used incorrectly.\n *\n * \n */\nexport declare enum TextmodeErrorLevel {\n    /**\n     * Suppress all error output.\n     * Validation failures are handled silently without any console messages.\n     */\n    SILENT = 0,\n    /**\n     * Log validation failures as warnings.\n     */\n    WARNING = 1,\n    /**\n     * Log validation failures as errors.\n     */\n    ERROR = 2,\n    /**\n     * Throw exceptions on validation failures *(default behavior)*.\n     */\n    THROW = 3\n}\n/**\n * Options for configuring the error handler.\n * @ignore\n */\nexport interface ErrorHandlerOptions {\n    /** Global error level */\n    globalLevel: TextmodeErrorLevel;\n}\n/**\n * Singleton error handler for textmode.js\n * This class handles errors based on the configured error level.\n * It can log warnings, errors, or throw exceptions based on the global error level.\n * @ignore\n */\nexport declare class TextmodeErrorHandler {\n    private static _instance;\n    private _options;\n    private constructor();\n    static $getInstance(): TextmodeErrorHandler;\n    /**\n     * Handle an error based on the configured settings\n     * @returns true if execution should continue, false if error was handled\n     */\n    private _handle;\n    /**\n     * Validate a condition and handle errors if validation fails\n     * @param condition The condition to validate\n     * @param message Error message if validation fails\n     * @param context Additional context for debugging\n     * @returns true if validation passed, false if validation failed and was handled\n     */\n    $validate(condition: boolean, message: string, context?: any): boolean;\n    /**\n     * Set global error level\n     */\n    $setGlobalLevel(level: TextmodeErrorLevel): void;\n}\n/**\n * Singleton instance of the textmode.js error handler.\n * @ignore\n */\nexport declare const errorHandler: TextmodeErrorHandler;",
  "file:///node_modules/textmode.js/dist/types/errors/index.d.ts": "export { TextmodeError } from './Error';\nexport { TextmodeErrorHandler, errorHandler, TextmodeErrorLevel, type ErrorHandlerOptions } from './ErrorHandler';",
  "file:///node_modules/textmode.js/dist/types/exports/conversion.d.ts": "export * from '../textmode/conversion';",
  "file:///node_modules/textmode.js/dist/types/exports/filters.d.ts": "export * from '../textmode/filters';",
  "file:///node_modules/textmode.js/dist/types/exports/input.d.ts": "export * from '../textmode/managers';",
  "file:///node_modules/textmode.js/dist/types/exports/layering.d.ts": "export * from '../textmode/layers';",
  "file:///node_modules/textmode.js/dist/types/exports/loadables.d.ts": "export * from '../textmode/loadables';",
  "file:///node_modules/textmode.js/dist/types/exports/loading.d.ts": "export * from '../textmode/loading';",
  "file:///node_modules/textmode.js/dist/types/exports/plugins.d.ts": "export type { TextmodePlugin, TextmodePluginAPI, TextmodePluginHook, LayerLifecycleHook, LayerRenderHook, SetupLifecycleHook, } from '../textmode/managers/PluginManager';",
  "file:///node_modules/textmode.js/dist/types/index.d.ts": "import { Textmode } from './Textmode';\nexport { Textmodifier } from './textmode/Textmodifier';\nexport { GLFramebuffer as TextmodeFramebuffer } from './rendering';\nexport { TextmodeColor } from './textmode/TextmodeColor';\nexport { TextmodeCanvas } from './textmode/Canvas';\nexport { TextmodeGrid } from './textmode/Grid';\nexport type { TextmodeOptions } from './textmode/types';\nexport type { TextmodeFramebufferOptions } from './rendering/webgl';\n/**\n * All media conversion related modules and types.\n *\n * Responsible for converting images and videos into textmode-renderable formats\n * using various conversion strategies, like brightness- or edge-detection-based conversion.\n *\n * `textmode.js` only comes with a built-in `'brightness'`-based conversion strategy,\n * but custom strategies can be registered via {@link TextmodeConversionManager.register}.\n */\nexport * as conversion from './textmode/conversion';\n/**\n * Plugin system types for extending textmode.js functionality.\n *\n * Plugins can:\n * - Add methods to TextmodeLayer instances (e.g., `.synth()`)\n * - Hook into the render lifecycle (pre/post draw, per-layer rendering)\n * - React to layer creation and disposal events\n * - Access the WebGL renderer, framebuffers, and other internals\n *\n * \n */\nexport * as plugins from './textmode/managers/PluginManager';\n/**\n * All filter related modules and types.\n *\n * Provides various image processing filters that can be applied in sequence on a layer's textmode-converted output,\n * such as blur, sharpen, edge detection, and color adjustments. Filters can also be applied globally to all layers as post-processing effects.\n *\n * While `textmode.js` only offers a basic set of filters, additional filters can be implemented and registered via the {@link TextmodeFilterManager},\n * which is accessible through {@link Textmodifier.filters}.\n */\nexport * as filters from './textmode/filters';\nexport { TextmodeErrorLevel } from './errors/ErrorHandler';\nexport { GLShader as TextmodeShader } from './rendering/webgl/core/Shader';\nexport { Textmode as textmode } from './Textmode';\n/** All loading screen related modules and types. */\nexport * as loading from './textmode/loading';\n/** All loadable assets related to textmode rendering. */\nexport * as loadables from './textmode/loadables';\n/** All types and interfaces related to input event handling. */\nexport * as input from './textmode/managers';\n/** All modules and types related to multi-layered textmode rendering. */\nexport * as layering from './textmode/layers';\n/**\n * Exports the create, setErrorLevel, and version functions from the Textmode class for UMD compatibility,\n * so calls like `textmode.create()` can be used.\n */\n/** @ignore */\nexport declare const create: typeof Textmode.create;\n/** @ignore */\nexport declare const setErrorLevel: typeof Textmode.setErrorLevel;\n/** @ignore */\nexport declare const version: string;",
  "file:///node_modules/textmode.js/dist/types/rendering/index.d.ts": "export { GLShader } from './webgl/core/Shader';\nexport { GLRenderer } from './webgl/core/Renderer';\nexport { GLFramebuffer } from './webgl/core/Framebuffer';",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/batching/DrawQueue.d.ts": "import { RenderState } from '../state/RenderState';\nimport type { DrawCommand } from '../types/DrawCommand';\nimport type { Material } from '../materials/Material';\nimport type { RectangleParams, LineParams, EllipseParams, ArcParams, TriangleParams, BezierCurveParams } from '../types/GeometryTypes';\n/**\n * Global draw queue preserving user-issued draw order across geometry types.\n *\n * Performance optimizations:\n * - Object pooling: Command slots are reused across frames to eliminate allocations\n * - Direct property assignment: Maintains V8 hidden classes for optimal JIT performance\n * - Type-specific enqueue methods: Eliminates conditional branching\n */\nexport declare class DrawQueue implements Iterable<DrawCommand> {\n    private _commands;\n    private _nextId;\n    private _size;\n    /** Reserve or reuse a pooled slot */\n    private _acquireSlot;\n    /**\n     * Enqueue a rectangle draw command.\n     * Zero-allocation in steady state (reuses pooled slots).\n     * Direct property assignment preserves V8 hidden classes for optimal performance.\n     *\n     * @param params Rectangle parameters\n     * @param renderState Current render state\n     * @param material Material to use for rendering\n     * @returns Command ID\n     */\n    $enqueueRectangle(params: RectangleParams, renderState: RenderState, material: Material): number;\n    /**\n     * Enqueue a line draw command.\n     * Zero-allocation in steady state (reuses pooled slots).\n     * Direct property assignment preserves V8 hidden classes for optimal performance.\n     *\n     * @param params Line parameters\n     * @param renderState Current render state\n     * @param material Material to use for rendering\n     * @returns Command ID\n     */\n    $enqueueLine(params: LineParams, renderState: RenderState, material: Material): number;\n    /**\n     * Enqueue an ellipse draw command.\n     * Zero-allocation in steady state (reuses pooled slots).\n     * Direct property assignment preserves V8 hidden classes for optimal performance.\n     *\n     * @param params Ellipse parameters\n     * @param renderState Current render state\n     * @param material Material to use for rendering\n     * @returns Command ID\n     */\n    $enqueueEllipse(params: EllipseParams, renderState: RenderState, material: Material): number;\n    /**\n     * Enqueue an arc draw command.\n     * Zero-allocation in steady state (reuses pooled slots).\n     * Direct property assignment preserves V8 hidden classes for optimal performance.\n     *\n     * @param params Arc parameters\n     * @param renderState Current render state\n     * @param material Material to use for rendering\n     * @returns Command ID\n     */\n    $enqueueArc(params: ArcParams, renderState: RenderState, material: Material): number;\n    /**\n     * Enqueue a triangle draw command.\n     * Zero-allocation in steady state (reuses pooled slots).\n     * Direct property assignment preserves V8 hidden classes for optimal performance.\n     *\n     * @param params Triangle parameters\n     * @param renderState Current render state\n     * @param material Material to use for rendering\n     * @returns Command ID\n     */\n    $enqueueTriangle(params: TriangleParams, renderState: RenderState, material: Material): number;\n    /**\n     * Enqueue a bezier curve draw command.\n     * Zero-allocation in steady state (reuses pooled slots).\n     * Direct property assignment preserves V8 hidden classes for optimal performance.\n     *\n     * @param params Bezier curve parameters\n     * @param renderState Current render state\n     * @param material Material to use for rendering\n     * @returns Command ID\n     */\n    $enqueueBezierCurve(params: BezierCurveParams, renderState: RenderState, material: Material): number;\n    /** Clear all queued commands */\n    $clear(): void;\n    /** Iterate in the exact order of insertion */\n    [Symbol.iterator](): Iterator<DrawCommand>;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/batching/GeometryAttributeCache.d.ts": "/**\n * Minimal VAO manager that caches unit-geometry attribute setup per (program, geometry type).\n * It binds only non-instanced attributes (a_position, a_texCoord). Instanced attributes are\n * still configured by InstanceBatch per draw to keep buffers flexible.\n */\nimport type { UnitGeometryData } from '../types/GeometryTypes';\nexport declare class GeometryAttributeCache {\n    private _gl;\n    private _cache;\n    constructor(gl: WebGL2RenderingContext);\n    /** Bind or create a VAO for the given program and geometry key. */\n    $bind(program: WebGLProgram, geometryKey: string, unit: UnitGeometryData, geometryBuffer: WebGLBuffer): void;\n    $unbind(): void;\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/batching/InstanceAttributeBinder.d.ts": "import { GLShader } from '../core/Shader';\n/**\n * Manages WebGL attribute binding and GPU buffer synchronization.\n *\n * Responsibilities:\n * - WebGL buffer creation and management\n * - GPU data upload (full buffer or sub-buffer updates)\n * - Attribute location caching per shader program\n * - Vertex attribute binding/unbinding\n *\n * This class is the ONLY one that knows about WebGL state.\n * It has NO knowledge of instance data layout details (delegates to InstanceAttributeLayout).\n */\nexport declare class InstanceAttributeBinder {\n    private _gl;\n    private _glBuffer;\n    private _bufferCapacity;\n    private _attributeLocationCache;\n    /**\n     * Create a new attribute binder.\n     * @param gl WebGL2 rendering context\n     * @param initialCapacity Initial GPU buffer capacity in instances\n     */\n    constructor(gl: WebGL2RenderingContext, initialCapacity?: number);\n    /**\n     * Create or recreate the WebGL buffer with specified capacity.\n     * @param capacity Buffer capacity in number of instances\n     */\n    private _createBuffer;\n    /**\n     * Recreate GPU buffer with new capacity.\n     * Called when CPU buffer grows beyond current GPU buffer capacity.\n     *\n     * @param newCapacity New capacity in number of instances\n     */\n    $recreateBuffer(newCapacity: number): void;\n    /**\n     * Get the current GPU buffer capacity in instances.\n     */\n    get $capacity(): number;\n    /**\n     * Upload instance data to GPU buffer.\n     *\n     * Performance-critical: This uploads data to the GPU every frame.\n     * Optimizations applied:\n     * - Only uploads used portion of buffer (not full capacity)\n     * - Uses bufferSubData for partial updates (faster than bufferData)\n     * - Binds buffer once and keeps it bound for attribute setup\n     *\n     * Pattern follows modern graphics engines (three.js, babylon.js):\n     * - Minimize data transfer size\n     * - Avoid redundant buffer bindings\n     * - Use streaming pattern for per-frame data\n     *\n     * @param data Float32Array containing instance data to upload\n     * @param instanceCount Number of instances in the data\n     */\n    $upload(data: Float32Array, instanceCount: number): void;\n    /**\n     * Get cached attribute locations for a shader program.\n     * Queries locations once per program and caches them for performance.\n     *\n     * @param program WebGL shader program\n     * @returns Map of attribute name to location\n     */\n    private _getAttributeLocations;\n    /**\n     * Bind instance buffer and configure vertex attributes for instanced rendering.\n     *\n     * IMPORTANT: Assumes instance buffer is already bound to gl.ARRAY_BUFFER from upload().\n     * If upload() was not called immediately before this, the buffer will not be bound correctly.\n     * The buffer remains bound after this call for use by the draw command.\n     *\n     * @param shader The shader program to bind attributes for\n     */\n    $bindAttributes(shader: GLShader): void;\n    /**\n     * Unbind instance attributes to clean up WebGL state.\n     *\n     * @param shader The shader program to unbind attributes for\n     */\n    $unbindAttributes(shader: GLShader): void;\n    /**\n     * Dispose of WebGL resources.\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/batching/InstanceBatch.d.ts": "import type { InstanceData } from './InstanceData';\nimport { GLShader } from '../core/Shader';\nimport { type InstanceWriteData } from './InstanceWriter';\nexport type { InstanceWriteData };\n/**\n * High-performance instance batch manager for WebGL instanced rendering.\n *\n * This is a facade that orchestrates three specialized components:\n * - InstanceBuffer: CPU-side memory management\n * - InstanceWriter: Zero-allocation instance data writing\n * - InstanceAttributeBinder: WebGL state and attribute binding\n *\n * Features:\n * - Direct Float32Array writing (zero allocations per instance)\n * - Automatic buffer growth with configurable growth factor\n * - Efficient sub-buffer updates for animated content\n * - Optimized WebGL attribute binding\n * - Struct-of-arrays layout for maximum GPU efficiency\n *\n * Architecture:\n * This class maintains the same public API as before but delegates work\n * to specialized components. This improves maintainability and testability\n * while preserving performance.\n */\nexport declare class InstanceBatch {\n    private _gl;\n    private readonly _buffer;\n    private readonly _writer;\n    private readonly _binder;\n    /**\n     * Creates a new instance batch.\n     * @param gl WebGL2 rendering context\n     * @param initialCapacity Initial buffer capacity (number of instances)\n     * @param growthFactor Buffer growth factor when capacity is exceeded\n     */\n    constructor(gl: WebGL2RenderingContext, initialCapacity?: number, growthFactor?: number);\n    /**\n     * Add a new instance to the batch (legacy object-based path).\n     * @param instance Instance data to add\n     * @returns Index of the added instance\n     */\n    $addInstance(instance: InstanceData): number;\n    /**\n     * Write instance data directly to the buffer (zero-allocation fast path).\n     * @param data Instance write data\n     * @returns Index of the written instance\n     */\n    $writeInstance(data: InstanceWriteData): number;\n    /**\n     * Get the current number of instances in the batch.\n     */\n    get $count(): number;\n    /**\n     * Check if the batch is empty.\n     */\n    get $isEmpty(): boolean;\n    /**\n     * Clear all instances from the batch.\n     */\n    $clear(): void;\n    /**\n     * Bind instance buffer and configure vertex attributes for instanced rendering.\n     * @param shader The shader program to bind attributes for\n     */\n    $bindAttributes(shader: GLShader): void;\n    /**\n     * Unbind instance attributes to clean up WebGL state.\n     * @param shader The shader program to unbind attributes for\n     */\n    $unbindAttributes(shader: GLShader): void;\n    /**\n     * Execute instanced draw call for all instances in the batch.\n     * @param primitiveType WebGL primitive type (e.g., gl.TRIANGLES)\n     * @param vertexCount Number of vertices in the base geometry\n     */\n    $draw(primitiveType: number, vertexCount: number): void;\n    /**\n     * Dispose of WebGL resources.\n     * Call this when the batch is no longer needed.\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/batching/InstanceBuffer.d.ts": "/**\n * Manages raw Float32Array buffer with automatic capacity growth.\n *\n * Responsibilities:\n * - Memory allocation and reallocation\n * - Capacity management with configurable growth factor\n * - Write pointer tracking\n * - Buffer access for GPU upload\n *\n * This class has NO knowledge of WebGL or GPU state.\n * It's purely a CPU-side memory manager.\n */\nexport declare class InstanceBuffer {\n    private _buffer;\n    private _capacity;\n    private _growthFactor;\n    private _writeIndex;\n    private _instanceCount;\n    /**\n     * Create a new instance buffer.\n     * @param initialCapacity Initial capacity in number of instances\n     * @param growthFactor Multiplier for capacity growth (default: 1.5)\n     */\n    constructor(initialCapacity?: number, growthFactor?: number);\n    /**\n     * Ensure buffer has capacity for the specified number of instances.\n     * Automatically grows buffer if needed, preserving existing data.\n     *\n     * @param requiredInstances Number of instances that need to fit\n     */\n    $ensureCapacity(requiredInstances: number): void;\n    /**\n     * Get write pointer for direct buffer writing.\n     * Returns the current buffer and offset for zero-allocation writes.\n     *\n     * @returns Object containing buffer reference and current write offset\n     */\n    $getWritePointer(): {\n        buffer: Float32Array;\n        offset: number;\n    };\n    /**\n     * Commit a write operation, advancing the write pointer.\n     * Call this after writing floats to the buffer obtained from getWritePointer().\n     *\n     * @param floatsWritten Number of floats written (should be FLOATS_PER_INSTANCE)\n     */\n    $commitWrite(floatsWritten: number): void;\n    /**\n     * Reset buffer to empty state.\n     * Does not deallocate memory, just resets write pointer.\n     */\n    $reset(): void;\n    /**\n     * Get a subarray of the buffer containing used data.\n     *\n     * @param start Starting float index (default: 0)\n     * @param end Ending float index (default: current write position)\n     * @returns Float32Array view of the specified range\n     */\n    $subarray(start?: number, end?: number): Float32Array;\n    /**\n     * Get the number of instances currently in the buffer.\n     */\n    get $instanceCount(): number;\n    /**\n     * Get the current buffer capacity in instances.\n     */\n    get $capacity(): number;\n    /**\n     * Get the current write index in floats.\n     */\n    get $writeIndex(): number;\n    /**\n     * Check if buffer is empty.\n     */\n    get $isEmpty(): boolean;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/batching/InstanceData.d.ts": "/**\n * Core data structure representing a single instance in batched rendering.\n * Contains all necessary data for ASCII character rendering via MRT.\n */\nexport interface InstanceData {\n    _position: [number, number];\n    _size: [number, number];\n    _character: [number, number, number];\n    _charColor: [number, number, number, number];\n    _cellColor: [number, number, number, number];\n    _charRotation: number;\n    _charTransform: [number, number, number];\n    _translation: [number, number, number];\n    _rotation: [number, number, number];\n    _depth?: number;\n    _baseZ?: number;\n    _geometryType?: number;\n    _arcAngles?: [number, number];\n    _bezierControlPoint1?: [number, number];\n    _bezierControlPoint2?: [number, number];\n    _bezierStartPoint?: [number, number];\n    _bezierEndPoint?: [number, number];\n}\n/**\n * Optimized packed instance data layout for GPU upload.\n * Designed for efficient WebGL attribute binding and minimal memory usage.\n *\n * Total size: 144 bytes per instance (with Arc + Bezier + Translation + 3D support + Geometry Type)\n */\nexport declare class PackedInstanceData {\n    static readonly BYTES_PER_INSTANCE = 144;\n    static readonly FLOATS_PER_INSTANCE = 36;\n    /**\n     * Pack instance data into a Float32Array for efficient GPU upload.\n     */\n    static $pack(instance: InstanceData, target?: Float32Array, offset?: number): Float32Array;\n    /**\n     * Pack multiple instances into a single Float32Array for batch upload.\n     */\n    static $packBatch(instances: InstanceData[], targetBuffer?: Float32Array): Float32Array;\n}\n/**\n * WebGL attribute configuration for instance data.\n */\nexport interface InstanceAttributeConfig {\n    location: number;\n    size: number;\n    type: number;\n    normalized: boolean;\n    stride: number;\n    offset: number;\n    divisor: number;\n}\n/**\n * Pre-configured attribute layouts for efficient WebGL setup.\n */\nexport declare class InstanceAttributeLayout {\n    static readonly STRIDE = 144;\n    static readonly ATTRIBUTES: Record<string, InstanceAttributeConfig>;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/batching/InstanceWriter.d.ts": "import type { InstanceBuffer } from './InstanceBuffer';\n/**\n * Data structure for direct instance writing (zero-allocation hot path).\n * All fields are primitives to avoid object creation during rendering.\n */\nexport interface InstanceWriteData {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    char0: number;\n    char1: number;\n    char2: number;\n    r1: number;\n    g1: number;\n    b1: number;\n    a1: number;\n    r2: number;\n    g2: number;\n    b2: number;\n    a2: number;\n    invert: number;\n    flipX: number;\n    flipY: number;\n    charRot: number;\n    translationX: number;\n    translationY: number;\n    translationZ: number;\n    rotationX: number;\n    rotationY: number;\n    rotationZ: number;\n    curveParams0: [number, number, number, number];\n    curveParams1: [number, number, number, number];\n    depth: number;\n    baseZ: number;\n    geometryType: number;\n}\n/**\n * High-performance instance writer for zero-allocation rendering.\n *\n * Responsibilities:\n * - Direct Float32Array writing without intermediate allocations\n * - Instance data packing according to GPU layout\n * - Write coordination with InstanceBuffer\n *\n * This class knows about the instance data layout but has NO knowledge\n * of WebGL, GPU buffers, or attribute binding.\n */\nexport declare class InstanceWriter {\n    private _buffer;\n    /**\n     * Create a new instance writer.\n     * @param buffer The buffer to write instances into\n     */\n    constructor(buffer: InstanceBuffer);\n    /**\n     * Write instance data directly to the buffer (zero-allocation fast path).\n     *\n     * This is the hot path for rendering - optimized for minimal overhead.\n     * Writes directly to Float32Array without any intermediate allocations.\n     *\n     * @param data Instance write data\n     * @returns Index of the written instance\n     */\n    $writeInstance(data: InstanceWriteData): number;\n    /**\n     * Get the current number of instances written.\n     */\n    get $instanceCount(): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/core/Framebuffer.d.ts": "import type { GLRenderer } from './Renderer';\nimport type { Material } from '../materials/Material';\nimport type { IFramebuffer } from './interfaces/IFramebuffer';\nexport type FramebufferOptions = {\n    /** Texture filtering mode */\n    filter?: 'nearest' | 'linear';\n    /** Texture wrapping mode */\n    wrap?: 'clamp' | 'repeat';\n    /** Texture format */\n    format?: 'rgba' | 'rgb';\n    /** Data type for texture data */\n    type?: 'unsigned_byte' | 'float';\n    /** Enable depth buffer (defaults to true for 3D support) */\n    depth?: boolean;\n};\n/**\n * Options for creating a framebuffer. If not specified, width and height default to the current textmode grid size.\n */\nexport type TextmodeFramebufferOptions = {\n    /** Width of the framebuffer in grid cells */\n    width?: number;\n    /** Height of the framebuffer in grid cells */\n    height?: number;\n    /**\n     * Number of color attachments *(1-8)*\n     *\n     * Defaults to 3 for textmode framebuffers *(character/transform data, primary color, secondary color)*.\n     * You probably do not want to go below 3 for textmode rendering, otherwise rendering will not function correctly.\n     *\n     * Going above 3 is only recommended for advanced use cases involving custom shaders that utilize additional attachments.\n     */\n    attachments?: number;\n};\n/**\n * Framebuffer class for managing offscreen rendering targets initialized via {@link Textmodifier.createFramebuffer}.\n *\n * `TextmodeFramebuffer` instances contain 3 attachments to support the rendering pipeline:\n * - Attachment 0: Character and transform data *(RGBA)*\n * - Attachment 1: Primary color data *(RGBA)*\n * - Attachment 2: Secondary color data *(RGBA)*\n */\nexport declare class GLFramebuffer implements IFramebuffer {\n    protected _width: number;\n    protected _height: number;\n    protected _options: FramebufferOptions;\n    private _gl;\n    private _framebuffer;\n    private _textures;\n    private _depthRenderbuffer;\n    private _attachmentCount;\n    private _renderer;\n    private _material;\n    private _pixelCache;\n    private static _copyShader;\n    /**\n     * Create a new GLFramebuffer instance.\n     * @param gl WebGL2 rendering context\n     * @param width Framebuffer width\n     * @param height Framebuffer height\n     * @param attachmentCount Number of color attachments\n     * @param options Framebuffer options\n     * @param renderer Optional GLRenderer instance for state management\n     * @ignore\n     */\n    constructor(gl: WebGL2RenderingContext, width: number, height: number | undefined, attachmentCount: number | undefined, options: FramebufferOptions | undefined, renderer: GLRenderer);\n    private _createTextures;\n    private _attachTextures;\n    private _createDepthRenderbuffer;\n    $update(source: HTMLCanvasElement | HTMLVideoElement): void;\n    resize(width: number, height: number): void;\n    readPixels(attachmentIndex: number): Uint8Array;\n    begin(): void;\n    end(): void;\n    /**\n     * Get or create the material for rendering this framebuffer.\n     * @ignore\n     */\n    $getMaterial(): Material;\n    /**\n     * Update the material with current framebuffer textures.\n     * @ignore\n     */\n    private _updateMaterial;\n    dispose(): void;\n    /** Get the width of the framebuffer */\n    get width(): number;\n    /** Get the height of the framebuffer */\n    get height(): number;\n    /** Get the WebGL textures associated with this framebuffer */\n    get textures(): WebGLTexture[];\n    /** Get the number of color attachments in this framebuffer */\n    get attachmentCount(): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/core/interfaces/IFramebuffer.d.ts": "/**\n * Interface for managing offscreen rendering targets (framebuffers).\n *\n * Framebuffers are used to render content offscreen, enabling effects like:\n * - Post-processing filters\n * - Multi-pass rendering\n * - Render-to-texture operations\n * - Double buffering\n *\n * Framebuffers in this system support Multiple Render Targets (MRT), allowing\n * multiple textures to be written simultaneously in a single render pass.\n */\nexport interface IFramebuffer {\n    /**\n     * Get the current framebuffer width in pixels/cells.\n     */\n    readonly width: number;\n    /**\n     * Get the current framebuffer height in pixels/cells.\n     */\n    readonly height: number;\n    /**\n     * Get all textures associated with this framebuffer.\n     *\n     * Useful for binding textures for reading in shaders.\n     *\n     * Textmode framebuffers allocate 4 attachments by default:\n     * - 0: Character data encoded in red and green channels\n     * - 1: Character colors\n     * - 2: Cell background colors\n     * - 3: Inversion, horizontal/flip flags, and rotation encoded in red, green, blue, alpha channels\n     */\n    readonly textures: WebGLTexture[];\n    /**\n     * Update the framebuffer texture with canvas or video content.\n     * Note: Only updates the first attachment in multi-attachment mode.\n     *\n     * @param source - The HTML canvas or video element to copy from\n     * @ignore\n     */\n    $update(source: HTMLCanvasElement | HTMLVideoElement): void;\n    /**\n     * Resize the framebuffer to new dimensions.\n     * This recreates the internal textures with the new size and invalidates any cached pixel data.\n     *\n     * @param width - New width in pixels/cells\n     * @param height - New height in pixels/cells\n     */\n    resize(width: number, height: number): void;\n    /**\n     * Read pixels from a specific color attachment into an RGBA Uint8Array.\n     *\n     * The returned pixel data:\n     * - Is in RGBA format (4 bytes per pixel)\n     * - Has top-left origin (first pixel is top-left corner)\n     * - Is cached until the next render pass to this framebuffer\n     *\n     * @param attachmentIndex - The index of the color attachment to read (0-based)<br/>\n     *                          0. Character data and transform info<br/>\n     *                          1. Character colors<br/>\n     *                          2. Cell background colors<br/>\n     * @returns A Uint8Array containing the pixel data in RGBA format\n     */\n    readPixels(attachmentIndex: number): Uint8Array;\n    /**\n     * Begin drawing to this framebuffer.\n     *\n     * This method:\n     * - Flushes any pending draw calls to maintain proper render order\n     * - Saves the current framebuffer and viewport state\n     * - Binds this framebuffer as the render target\n     * - Clears all color attachments to transparent black\n     * - Sets the viewport to match the framebuffer dimensions\n     *\n     * All subsequent drawing operations will target this framebuffer until {@link end} is called.\n     */\n    begin(): void;\n    /**\n     * End rendering to this framebuffer and restore previous state.\n     *\n     * This method:\n     * - Flushes any pending draw calls into this framebuffer\n     * - Restores the previously bound framebuffer\n     * - Restores the previous viewport settings\n     *\n     * After calling this method, rendering operations will target the previously active framebuffer.\n     */\n    end(): void;\n    /**\n     * Dispose of WebGL resources used by this framebuffer.\n     *\n     * This method is idempotent and safe to call multiple times.\n     * After disposal, the framebuffer should not be used for rendering.\n     */\n    dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/core/interfaces/IRenderer.d.ts": "import type { GLFramebuffer, FramebufferOptions } from '../Framebuffer';\nimport type { GLShader } from '../Shader';\nimport type { RenderState } from '../../state/RenderState';\n/**\n * Interface for the core WebGL renderer that manages the WebGL context and provides high-level rendering operations.\n *\n * This interface defines the contract for all rendering operations including:\n * - Shader management and creation\n * - Framebuffer operations\n * - Primitive rendering (rectangles, lines, ellipses, triangles, arcs, bezier curves)\n * - Image and texture rendering\n * - State management\n * - Viewport and clearing operations\n */\nexport interface IRenderer {\n    /**\n     * Get the WebGL rendering context.\n     * Provides direct access to the underlying WebGL2 context for advanced operations.\n     */\n    readonly context: WebGLRenderingContext;\n    /**\n     * Get the current render state.\n     * The render state tracks the current rendering configuration including blend modes,\n     * colors, and other state that affects how primitives are drawn.\n     */\n    readonly state: RenderState;\n    /**\n     * Set the current shader for subsequent rendering operations.\n     * This binds the shader program and makes it active for all following draw calls\n     * until a different shader is set.\n     *\n     * @param shader - The shader to activate\n     */\n    $shader(shader: GLShader): void;\n    /**\n     * Create a new shader from vertex and fragment source code.\n     * The shader is compiled, linked, and cached by the shader manager.\n     *\n     * @param vertexSource - GLSL source code for the vertex shader\n     * @param fragmentSource - GLSL source code for the fragment shader\n     * @returns A compiled and linked shader program\n     */\n    $createShader(vertexSource: string, fragmentSource: string): GLShader;\n    /**\n     * Set a custom user shader for subsequent rendering operations.\n     * This shader will be used for primitive rendering instead of the default shader.\n     * Pass null to reset to the default shader.\n     *\n     * @param shader - The custom shader to use, or null to reset to default\n     */\n    $setUserShader(shader: GLShader | null): void;\n    /**\n     * Set a uniform value for the current user shader.\n     * The uniform must exist in the shader for this to have any effect.\n     *\n     * @param name - The name of the uniform variable in the shader\n     * @param value - The value to set (type must match the uniform type in the shader)\n     */\n    $setUniform(name: string, value: any): void;\n    /**\n     * Set multiple uniform values for the current user shader.\n     * This is a convenience method for setting multiple uniforms at once.\n     *\n     * @param uniforms - A record mapping uniform names to their values\n     */\n    $setUserUniforms(uniforms: Record<string, any>): void;\n    /**\n     * Create a filter shader using the standard instanced vertex shader.\n     * Filter shaders are commonly used for post-processing effects and only require\n     * a custom fragment shader since they use a standard quad-rendering vertex shader.\n     *\n     * @param fragmentSource - GLSL source code for the fragment shader\n     * @returns A shader configured for filter operations\n     */\n    $createFilterShader(fragmentSource: string): GLShader;\n    /**\n     * Draw a quad covering the pixel rectangle (x, y, width, height) on the canvas.\n     * The quad is converted to NDC (Normalized Device Coordinates) and rendered with the\n     * current shader using only the a_position attribute.\n     * Origin: top-left (canvas space).\n     *\n     * @param x - X coordinate of the top-left corner in pixels\n     * @param y - Y coordinate of the top-left corner in pixels\n     * @param width - Width of the quad in pixels\n     * @param height - Height of the quad in pixels\n     */\n    $quad(x: number, y: number, width: number, height: number): void;\n    /**\n     * Draw a rectangle.\n     * The rectangle is rendered using the current shader and render state.\n     *\n     * @param x - X coordinate of the top-left corner\n     * @param y - Y coordinate of the top-left corner\n     * @param width - Width of the rectangle\n     * @param height - Height of the rectangle\n     */\n    $rect(x: number, y: number, width: number, height: number): void;\n    /**\n     * Draw a line from one point to another.\n     * The line is rendered with the current stroke settings from the render state.\n     *\n     * @param x1 - X coordinate of the line start point\n     * @param y1 - Y coordinate of the line start point\n     * @param x2 - X coordinate of the line end point\n     * @param y2 - Y coordinate of the line end point\n     */\n    $line(x1: number, y1: number, x2: number, y2: number): void;\n    /**\n     * Draw an ellipse.\n     * The ellipse is centered at (x, y) with the specified width and height.\n     *\n     * @param x - X coordinate of the center\n     * @param y - Y coordinate of the center\n     * @param width - Width of the ellipse\n     * @param height - Height of the ellipse\n     */\n    $ellipse(x: number, y: number, width: number, height: number): void;\n    /**\n     * Draw a triangle.\n     * The triangle is defined by three vertices and rendered with the current render state.\n     *\n     * @param x1 - First vertex X coordinate\n     * @param y1 - First vertex Y coordinate\n     * @param x2 - Second vertex X coordinate\n     * @param y2 - Second vertex Y coordinate\n     * @param x3 - Third vertex X coordinate\n     * @param y3 - Third vertex Y coordinate\n     */\n    $triangle(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;\n    /**\n     * Draw a cubic Bezier curve.\n     * The curve is defined by a start point, two control points, and an end point.\n     *\n     * @param x1 - Start point X coordinate\n     * @param y1 - Start point Y coordinate\n     * @param cp1x - First control point X coordinate\n     * @param cp1y - First control point Y coordinate\n     * @param cp2x - Second control point X coordinate\n     * @param cp2y - Second control point Y coordinate\n     * @param x2 - End point X coordinate\n     * @param y2 - End point Y coordinate\n     */\n    $bezierCurve(x1: number, y1: number, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x2: number, y2: number): void;\n    /**\n     * Draw an arc (a portion of an ellipse).\n     * The arc is part of an ellipse centered at (x, y) with the specified dimensions,\n     * drawn from the start angle to the stop angle.\n     *\n     * @param x - X coordinate of the center\n     * @param y - Y coordinate of the center\n     * @param width - Width of the ellipse\n     * @param height - Height of the ellipse\n     * @param start - Start angle in radians\n     * @param stop - Stop angle in radians\n     */\n    $arc(x: number, y: number, width: number, height: number, start: number, stop: number): void;\n    /**\n     * Create a new framebuffer for off-screen rendering.\n     * Framebuffers can be used for render-to-texture operations, post-processing,\n     * and other advanced rendering techniques.\n     *\n     * @param width - Width of the framebuffer in pixels\n     * @param height - Height of the framebuffer in pixels\n     * @param attachmentCount - Number of color attachments (default: 1, supports MRT)\n     * @param options - Additional framebuffer configuration options\n     * @returns A new framebuffer instance\n     */\n    $createFramebuffer(width: number, height: number, attachmentCount?: number, options?: FramebufferOptions): GLFramebuffer;\n    /**\n     * Fill the current framebuffer with a solid color.\n     * This sets the canvas background color in the render state and clears the framebuffer.\n     * If only one value is provided, it's used for all RGB components.\n     *\n     * @param r - Red component (0-255)\n     * @param g - Green component (0-255), defaults to r if not provided\n     * @param b - Blue component (0-255), defaults to r if not provided\n     * @param a - Alpha component (0-255), defaults to 255 if not provided\n     */\n    $background(r: number, g?: number, b?: number, a?: number): void;\n    /**\n     * Clear the current framebuffer to a specified color.\n     * Color components should be in the range [0, 1].\n     *\n     * @param r - Red component (0-1), defaults to 0\n     * @param g - Green component (0-1), defaults to 0\n     * @param b - Blue component (0-1), defaults to 0\n     * @param a - Alpha component (0-1), defaults to 0\n     */\n    $clear(r?: number, g?: number, b?: number, a?: number): void;\n    /**\n     * Reset the viewport to match the canvas dimensions.\n     * This ensures the viewport is synchronized with the canvas size, which is\n     * important after canvas resize operations.\n     */\n    $resetViewport(): void;\n    /**\n     * Flush all batched instances for instanced rendering.\n     * This must be called at the end of each frame to actually render all batched geometry.\n     * The method processes the entire draw queue and renders all primitives that were\n     * queued during the frame.\n     */\n    $flushInstances(): void;\n    /**\n     * Dispose of all WebGL resources managed by this renderer.\n     * This releases buffers, shaders, geometries, and other GPU resources.\n     * This method is idempotent and safe to call multiple times.\n     * After disposal, the renderer should not be used.\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/core/Renderer.d.ts": "import { GLFramebuffer } from './Framebuffer';\nimport type { FramebufferOptions } from './Framebuffer';\nimport { GLShader } from './Shader';\nimport { RenderState } from '../state/RenderState';\nimport type { TextmodeSource } from '../../../textmode/loadables/TextmodeSource';\nimport type { TextmodeFont } from '../../../textmode/loadables/font/TextmodeFont';\nimport type { IRenderer } from './interfaces/IRenderer';\nimport { MaterialManager } from '../materials/MaterialManager';\nexport declare class GLRenderer implements IRenderer {\n    private _gl;\n    private _currentShader;\n    private readonly _renderPipeline;\n    private readonly _materialManager;\n    private _renderState;\n    private _drawQueue;\n    private readonly _immediateQuad;\n    private _userShader;\n    private _userUniforms;\n    private _framebufferBindingStack;\n    private _viewportStack;\n    private _attachmentCountStack;\n    private _currentFramebuffer;\n    private _currentViewport;\n    private _currentAttachmentCount;\n    constructor(gl: WebGL2RenderingContext);\n    /**\n     * Push current framebuffer and viewport state onto the stack.\n     * Used by framebuffer begin() to save state before binding.\n     * @internal\n     */\n    $pushFramebufferState(): void;\n    /**\n     * Pop framebuffer and viewport state from the stack.\n     * Used by framebuffer end() to restore previous state.\n     * @internal\n     */\n    $popFramebufferState(): void;\n    /**\n     * Bind a framebuffer and update CPU-side tracking.\n     * @internal\n     */\n    $bindFramebuffer(framebuffer: WebGLFramebuffer | null, width: number, height: number, attachmentCount?: number): void;\n    $shader(shader: GLShader): void;\n    $createShader(vertexSource: string, fragmentSource: string): GLShader;\n    $setUserShader(shader: GLShader | null): void;\n    $setUniform(name: string, value: any): void;\n    $setUserUniforms(uniforms: Record<string, any>): void;\n    $createFilterShader(fragmentSource: string): GLShader;\n    $image(source: GLFramebuffer | TextmodeSource, width?: number, height?: number, activeFont?: TextmodeFont): void;\n    $quad(x: number, y: number, width: number, height: number): void;\n    $rect(width: number, height: number): void;\n    $line(x1: number, y1: number, x2: number, y2: number): void;\n    $ellipse(width: number, height: number): void;\n    $triangle(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;\n    $bezierCurve(x1: number, y1: number, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x2: number, y2: number): void;\n    $arc(width: number, height: number, start: number, stop: number): void;\n    $createFramebuffer(width: number, height: number, attachmentCount?: number, options?: FramebufferOptions): GLFramebuffer;\n    $background(r: number, g?: number, b?: number, a?: number): void;\n    $clear(r?: number, g?: number, b?: number, a?: number): void;\n    /**\n     * Internal MRT-aware clear implementation.\n     * @param r Red component (0-1)\n     * @param g Green component (0-1)\n     * @param b Blue component (0-1)\n     * @param a Alpha component (0-1)\n     * @param preserveCharData If true, clears attachment 0 to (1, 1, 0, 0); if false, clears to (0, 0, 0, 0)\n     */\n    private _clearMRT;\n    $resetViewport(): void;\n    $flushInstances(): void;\n    $dispose(): void;\n    get context(): WebGL2RenderingContext;\n    get state(): RenderState;\n    get materialManager(): MaterialManager;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/core/Shader.d.ts": "import { GLFramebuffer } from './Framebuffer';\n/**\n * Supported uniform value types\n */\nexport type UniformValue = number | boolean | number[] | number[][] | Float32Array | Int32Array | GLFramebuffer | WebGLTexture;\n/**\n *\n * Shader class for managing WebGL shader programs initialized via {@link Textmodifier.createFilterShader} or {@link Textmodifier.createShader}.\n *\n * Use shaders and set uniforms via {@link Textmodifier.shader}, {@link Textmodifier.setUniform}, and {@link Textmodifier.setUniforms}.\n *\n * With a shader active, the next {@link Textmodifier.rect} call will use the shader for rendering,\n * and automatically unuse it afterwards.\n */\nexport declare class GLShader {\n    private _gl;\n    private _program;\n    private _uniformLocations;\n    private _uniformTypes;\n    private _textureUnitCounter;\n    private _textureUnitAssignments;\n    private _maxTextureUnits;\n    /**\n     * Creates a new GLShader instance.\n     * @param gl The WebGL rendering context.\n     * @param vertexSource The source code for the vertex shader.\n     * @param fragmentSource The source code for the fragment shader.\n     * @ignore\n     */\n    constructor(gl: WebGLRenderingContext, vertexSource: string, fragmentSource: string);\n    private _cacheLocations;\n    private _createProgram;\n    private _createShader;\n    /**\n     * Use this shader program\n     * @ignore\n     */\n    $use(): void;\n    /**\n     * Reset texture unit counter and other state\n     */\n    private _resetState;\n    /**\n     * Set multiple uniform values at once.\n     * @param uniforms An object mapping uniform names to their values.\n     * @ignore\n     */\n    $setUniforms(uniforms: Record<string, any>): void;\n    /**\n     * Set a single uniform value with automatic texture unit management and proper type detection\n     * @param name The name of the uniform variable in the shader\n     * @param value The value to set for the uniform\n     * @ignore\n     */\n    $setUniform(name: string, value: UniformValue): void;\n    private _acquireTextureUnit;\n    /**\n     * Get the WebGL program\n     */\n    get program(): WebGLProgram;\n    /**\n     * Dispose of WebGL resources used by this shader.\n     */\n    dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/2d/Arc.d.ts": "/**\n * Instanced arc (pie segment) geometry implementation\n */\nimport type { InstanceBatch } from '../../batching/InstanceBatch';\nimport { type ArcParams } from '../../types/GeometryTypes';\nimport { BaseGeometry } from '../BaseGeometry';\nimport type { IRenderState } from '../../state/RenderState';\n/**\n * Instanced arc geometry renderer.\n * Batches arc draw calls using a unit triangle fan scaled to width/height.\n * Angles are specified in DEGREES by the API, converted to radians here.\n */\nexport declare class Arc extends BaseGeometry {\n    constructor(gl: WebGL2RenderingContext, batch: InstanceBatch);\n    /** Add an arc instance (filled pie segment) */\n    $addInstance(params: ArcParams, renderState: IRenderState): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/2d/BezierCurve.d.ts": "/**\n * Instanced bezier curve geometry implementation\n */\nimport type { InstanceBatch } from '../../batching/InstanceBatch';\nimport { type BezierCurveParams } from '../../types/GeometryTypes';\nimport { BaseGeometry } from '../BaseGeometry';\nimport type { IRenderState } from '../../state/RenderState';\n/**\n * TRUE INSTANCED bezier curve geometry renderer.\n *\n * APPROACH: Use a fixed multi-segment unit geometry shared by all curves.\n * Each instance provides Bezier control points via instance attributes, and the\n * vertex shader evaluates the curve mathematically to transform each segment.\n *\n * This maintains true instanced rendering: one draw call for all curves.\n */\nexport declare class BezierCurve extends BaseGeometry {\n    constructor(gl: WebGL2RenderingContext, batch: InstanceBatch);\n    /**\n     * Add a bezier curve instance to the batch - TRUE INSTANCED APPROACH\n     */\n    $addInstance(params: BezierCurveParams, renderState: IRenderState): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/2d/Ellipse.d.ts": "/**\n * Instanced ellipse geometry implementation\n */\nimport type { InstanceBatch } from '../../batching/InstanceBatch';\nimport { type EllipseParams } from '../../types/GeometryTypes';\nimport { BaseGeometry } from '../BaseGeometry';\nimport type { IRenderState } from '../../state/RenderState';\n/**\n * Instanced ellipse geometry renderer.\n * Batches all ellipse draw calls for efficient GPU rendering.\n */\nexport declare class Ellipse extends BaseGeometry {\n    constructor(gl: WebGL2RenderingContext, batch: InstanceBatch);\n    /**\n     * Add an ellipse instance to the batch\n     * @param params Ellipse parameters\n     * @param renderState Current render state\n     * @returns Index of the added instance\n     */\n    $addInstance(params: EllipseParams, renderState: IRenderState): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/2d/Line.d.ts": "/**\n * Instanced line geometry implementation\n */\nimport type { InstanceBatch } from '../../batching/InstanceBatch';\nimport { type LineParams } from '../../types/GeometryTypes';\nimport { BaseGeometry } from '../BaseGeometry';\nimport type { IRenderState } from '../../state/RenderState';\n/**\n * Instanced line geometry renderer.\n * Batches all line draw calls for efficient GPU rendering.\n */\nexport declare class Line extends BaseGeometry {\n    constructor(gl: WebGL2RenderingContext, batch: InstanceBatch);\n    /**\n     * Add a line instance to the batch\n     * @param params Line parameters\n     * @param renderState Current render state\n     * @returns Index of the added instance\n     */\n    $addInstance(params: LineParams, renderState: IRenderState): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/2d/Rectangle.d.ts": "/**\n * Instanced rectangle geometry implementation\n */\nimport type { InstanceBatch } from '../../batching/InstanceBatch';\nimport { type RectangleParams } from '../../types/GeometryTypes';\nimport { BaseGeometry } from '../BaseGeometry';\nimport type { IRenderState } from '../../state/RenderState';\n/**\n * Instanced rectangle geometry renderer.\n * Batches all rectangle draw calls for efficient GPU rendering.\n */\nexport declare class Rectangle extends BaseGeometry {\n    constructor(gl: WebGL2RenderingContext, batch: InstanceBatch);\n    /**\n     * Add a rectangle instance to the batch\n     * @param params Rectangle parameters\n     * @param renderState Current render state\n     * @returns Index of the added instance\n     */\n    $addInstance(params: RectangleParams, renderState: IRenderState): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/2d/Triangle.d.ts": "/**\n * Instanced triangle geometry implementation\n */\nimport type { InstanceBatch } from '../../batching/InstanceBatch';\nimport { type TriangleParams } from '../../types/GeometryTypes';\nimport { BaseGeometry } from '../BaseGeometry';\nimport type { IRenderState } from '../../state/RenderState';\n/**\n * Instanced triangle geometry renderer.\n * Batches all triangle draw calls for efficient GPU rendering.\n */\nexport declare class Triangle extends BaseGeometry {\n    constructor(gl: WebGL2RenderingContext, batch: InstanceBatch);\n    /**\n     * Add a triangle instance to the batch\n     * @param params Triangle parameters\n     * @param renderState Current render state\n     * @returns Index of the added instance\n     */\n    $addInstance(params: TriangleParams, renderState: IRenderState): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/BaseGeometry.d.ts": "import type { InstanceBatch } from '../batching/InstanceBatch';\nimport type { InstanceData } from '../batching/InstanceData';\nimport type { IGeometry, GeometryType, UnitGeometryData } from '../types/GeometryTypes';\nimport type { IRenderState } from '../state/RenderState';\n/**\n * Abstract base class for all instanced geometries.\n * Provides common functionality for instance data creation and batch management.\n */\nexport declare abstract class BaseGeometry implements IGeometry {\n    protected readonly _gl: WebGL2RenderingContext;\n    protected readonly _batch: InstanceBatch;\n    protected readonly _type: GeometryType;\n    protected readonly _unitGeometry: UnitGeometryData;\n    private _unitBuffer;\n    constructor(gl: WebGL2RenderingContext, batch: InstanceBatch, type: GeometryType, unitGeometry: UnitGeometryData);\n    get type(): GeometryType;\n    get unitGeometry(): UnitGeometryData;\n    get unitBuffer(): WebGLBuffer;\n    get batch(): InstanceBatch;\n    $clearInstances(): void;\n    $hasInstances(): boolean;\n    $dispose(): void;\n    abstract $addInstance(params: any, renderState: any): number;\n    protected _addInstance(instanceData: InstanceData, _rotationCenterX: number, _rotationCenterY: number): number;\n    /**\n     * Write instance data directly to batch buffer (zero-allocation helper).\n     * Handles all common instance data setup to eliminate code duplication.\n     *\n     * @param x - X position\n     * @param y - Y position\n     * @param width - Width\n     * @param height - Height\n     * @param centerX - Rotation center X (in pixels)\n     * @param centerY - Rotation center Y (in pixels)\n     * @param renderState - Current render state\n     * @param geometryData - Optional geometry-specific data (arc angles, bezier points, depth)\n     * @returns Index of the written instance\n     */\n    protected _writeInstance(x: number, y: number, width: number, height: number, renderState: IRenderState, geometryData?: {\n        arcStart?: number;\n        arcStop?: number;\n        cp1x?: number;\n        cp1y?: number;\n        cp2x?: number;\n        cp2y?: number;\n        bezStartX?: number;\n        bezStartY?: number;\n        bezEndX?: number;\n        bezEndY?: number;\n        depth?: number;\n        baseZ?: number;\n    }): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/immediate/ImmediateQuad.d.ts": "/**\n * Immediate-mode quad renderer for full-screen passes and framebuffer presentation.\n *\n * This is NOT an instanced geometry - it's a simple, stateless utility for drawing\n * a single textured quad immediately. Used primarily for presenting final framebuffer\n * results to the screen or for filter passes.\n */\n/**\n * Simple immediate-mode quad renderer.\n * No instancing, no batching, just a single quad drawn with vertex positions in NDC.\n */\nexport declare class ImmediateQuad {\n    private _gl;\n    private _vbo;\n    private _vertexData;\n    constructor(gl: WebGL2RenderingContext);\n    /**\n     * Draw a quad immediately with the given pixel coordinates.\n     * Converts pixel coordinates to NDC and renders a textured quad.\n     *\n     * The current shader must be bound before calling this method.\n     *\n     * @param x X position in pixels\n     * @param y Y position in pixels\n     * @param width Width in pixels\n     * @param height Height in pixels\n     */\n    $draw(x: number, y: number, width: number, height: number): void;\n    /**\n     * Dispose of WebGL resources.\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/index.d.ts": "export { Rectangle } from './2d/Rectangle';\nexport { Line } from './2d/Line';\nexport { Ellipse } from './2d/Ellipse';\nexport { Arc } from './2d/Arc';\nexport { Triangle } from './2d/Triangle';\nexport { BezierCurve } from './2d/BezierCurve';",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/utils/GeometryDescriptors.d.ts": "/**\n * Shared geometry attribute descriptors to eliminate redundant definitions.\n * All geometries of the same dimensionality (2D/3D) share identical stride and attribute layouts.\n */\n/**\n * Unit quad vertex data used by both instanced and immediate quad rendering.\n * Format: [x, y, u, v] for each vertex (position + texCoord interleaved)\n * Layout: Two triangles forming a unit square centered at origin from (-0.5,-0.5) to (0.5,0.5)\n */\nexport declare const UNIT_QUAD: Float32Array<ArrayBuffer>;\n/**\n * Standard 2D geometry attribute descriptor.\n * Used by: Rectangle, Line, Ellipse, Triangle, Arc, BezierCurve\n *\n * Layout: [position.xy, texCoord.uv]\n * Stride: 16 bytes (4 floats)\n */\nexport declare const GEOMETRY_2D_DESCRIPTOR: {\n    readonly _stride: 16;\n    readonly _primitiveType: 4;\n    readonly _attributes: {\n        readonly _position: {\n            readonly size: 2;\n            readonly offset: 0;\n        };\n        readonly _texCoord: {\n            readonly size: 2;\n            readonly offset: 8;\n        };\n    };\n};",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/geometries/utils/GeometryGenerator.d.ts": "/**\n * Geometry generation utilities for 2D shapes.\n * 2D geometries use 4 floats per vertex: position.xy + texCoord.uv\n */\n/**\n * Generate 2D circle/ellipse vertices.\n */\nexport declare function generateCircleVertices(segments?: number): Float32Array;\n/**\n * Generate unit arc vertices for 2D arc rendering.\n */\nexport declare function generateArcVertices(segments: number): Float32Array;\n/**\n * Generate bezier curve geometry (multi-segment for GPU evaluation).\n */\nexport declare function generateBezierVertices(segments?: number): Float32Array;",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/index.d.ts": "export * from './core/Framebuffer';\nexport * from './core/Renderer';\nexport * from './core/Shader';\nexport * from './utils/ViewportCache';\nexport * from './geometries/immediate/ImmediateQuad';\nexport * from './pipeline';\nexport { GeometryType } from './types/GeometryTypes';\nexport type { IGeometry as IInstancedGeometry, UnitGeometryData, RectangleParams, LineParams, EllipseParams, ArcParams, TriangleParams, BezierCurveParams, GeometryParams, } from './types/GeometryTypes';\nexport type { RenderContext } from './types/RenderTypes';\nexport type { InstanceData } from './batching/InstanceData';\nexport { PackedInstanceData, InstanceAttributeLayout } from './batching/InstanceData';\nexport { InstanceBatch } from './batching/InstanceBatch';\nexport { BaseGeometry } from './geometries/BaseGeometry';\nexport { Rectangle } from './geometries/2d/Rectangle';\nexport { Line } from './geometries/2d/Line';\nexport { Ellipse } from './geometries/2d/Ellipse';\nexport { Arc } from './geometries/2d/Arc';\nexport { Triangle } from './geometries/2d/Triangle';\nexport { BezierCurve } from './geometries/2d/BezierCurve';",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/materials/index.d.ts": "export type { Material, UniformValue } from './Material';\nexport { MaterialManager } from './MaterialManager';",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/materials/Material.d.ts": "import type { GLShader } from '../core/Shader';\n/**\n * Uniform value types supported by materials\n */\nexport type UniformValue = number | boolean | number[] | number[][] | Float32Array | Int32Array | WebGLTexture;\n/**\n * Material defines how geometry should be rendered.\n * Combines a shader program with uniform parameters.\n *\n * Materials are immutable once created to enable safe deduplication and caching.\n */\nexport interface Material {\n    /** Unique material identifier for fast comparison */\n    readonly id: number;\n    /** The shader program to use for rendering */\n    readonly shader: GLShader;\n    /** Uniform values to set when using this material (immutable) */\n    readonly uniforms: Readonly<Record<string, UniformValue>>;\n    /** Hash for fast material comparison and deduplication */\n    readonly hash: number;\n    /**\n     * Whether this is a built-in system material (solid color, copy, etc.)\n     * Built-in materials are never disposed when cleaning up user materials.\n     */\n    readonly isBuiltIn: boolean;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/materials/MaterialManager.d.ts": "import type { Material, UniformValue } from './Material';\nimport { GLShader } from '../core/Shader';\n/**\n * Manages material creation, deduplication, and lifecycle.\n *\n * Provides:\n * - Material creation with automatic deduplication\n * - Built-in materials (solid color, copy, image-to-MRT)\n * - Transient materials for dynamic uniforms\n * - Built-in shader management (2D/3D instanced shaders)\n *\n * Performance optimizations:\n * - Material interning: identical materials share the same instance\n * - Hash-based lookup for O(1) deduplication\n * - Separate tracking of user vs built-in materials\n */\nexport declare class MaterialManager {\n    private _nextMaterialId;\n    private readonly _shader;\n    private readonly _solidColorMaterial;\n    private _materialCache;\n    constructor(gl: WebGL2RenderingContext);\n    /**\n     * Get the default 2D solid-color material.\n     * This material uses the standard instanced MRT shader with per-instance colors.\n     */\n    get $solidColorMaterial(): Material;\n    /**\n     * Create a new material or return an existing one with identical properties.\n     *\n     * Materials are deduplicated based on shader and uniform values.\n     * If a material with the same shader and uniforms already exists, it will be reused.\n     *\n     * @param shader - The shader program to use\n     * @param uniforms - Uniform values to set (will be frozen for immutability)\n     * @param isBuiltIn - Whether this is a built-in system material\n     * @returns A material instance (new or deduplicated)\n     */\n    $createMaterial(shader: GLShader, uniforms?: Record<string, UniformValue>, isBuiltIn?: boolean): Material;\n    /**\n     * Create a transient material that won't be cached.\n     * Useful for one-off materials with dynamic uniforms that change every frame.\n     *\n     * @param shader - The shader program to use\n     * @param uniforms - Uniform values to set\n     * @returns A new material instance (not cached)\n     */\n    $createTransientMaterial(shader: GLShader, uniforms?: Record<string, UniformValue>): Material;\n    /**\n     * Compute a hash for a shader + uniforms combination.\n     * Used for material deduplication.\n     */\n    private _computeHash;\n    /**\n     * Hash a single uniform value based on its type.\n     */\n    private _hashUniformValue;\n    /**\n     * Dispose of all shaders and materials managed by this manager.\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/pipeline/index.d.ts": "/**\n * WebGL Rendering Pipeline\n *\n * This module contains the rendering pipeline architecture that orchestrates\n * the execution of draw commands through specialized renderers.\n */\nexport { MaterialBatchPipeline } from './MaterialBatchPipeline';",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/pipeline/MaterialBatchPipeline.d.ts": "import type { DrawCommand } from '../types/DrawCommand';\n/**\n * Material-based rendering pipeline with strict draw order preservation.\n *\n * Responsibilities:\n * - Manages all geometry instances (one per type)\n * - Batches consecutive commands with the same material + geometry type\n * - Executes instanced draw calls\n *\n * Key principles:\n * - Batches consecutive commands with the same material + geometry type\n * - NEVER reorders commands (preserves user draw order)\n * - Single rendering path for all geometry (no special-casing custom shaders)\n *\n * Architecture:\n * 1. Scan commands in insertion order\n * 2. Group consecutive runs of same material+type into batches\n * 3. Render each batch with a single instanced draw call\n *\n * Performance:\n * - Best case: All commands use same material  1 draw call\n * - Worst case: Alternating materials  same as unbatched\n * - Real-world: 50-70% reduction in draw calls\n */\nexport declare class MaterialBatchPipeline {\n    private _gl;\n    private _geometries;\n    private _geometryAttributeCache;\n    constructor(gl: WebGL2RenderingContext);\n    /**\n     * Execute all queued draw commands in strict order.\n     * Batches consecutive commands with same material+type for efficiency.\n     *\n     * @param commands - Draw commands in user-specified order\n     */\n    $execute(commands: Iterable<DrawCommand>): void;\n    /**\n     * Group consecutive commands with the same material + geometry type.\n     * Preserves draw order by never reordering commands.\n     *\n     * Algorithm:\n     * 1. Start with first command as current batch\n     * 2. For each subsequent command:\n     *    - If material OR type differs: flush current batch, start new one\n     *    - Otherwise: add to current batch\n     * 3. Flush final batch\n     *\n     * @param commands - Input draw commands in order\n     * @returns Array of batches to render sequentially\n     */\n    private _batchConsecutive;\n    /**\n     * Render a single batch of commands with the same material and geometry type.\n     * Uses instanced rendering for maximum efficiency.\n     *\n     * @param batch - Batch to render\n     */\n    private _renderBatch;\n    /**\n     * Dispose of pipeline resources (including all geometries).\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/state/RenderState.d.ts": "/**\n * Represents a snapshot of the current rendering state\n */\nexport interface IRenderState {\n    _lineWeight: number;\n    _translationX: number;\n    _translationY: number;\n    _translationZ: number;\n    _rotationX: number;\n    _rotationY: number;\n    _rotationZ: number;\n    _character: [number, number, number];\n    _charColor: [number, number, number, number];\n    _cellColor: [number, number, number, number];\n    _flipX: boolean;\n    _flipY: boolean;\n    _invert: boolean;\n    _charRotation: number;\n    _useOrtho: boolean;\n}\n/**\n * Manages rendering state and provides push/pop functionality for state management.\n *\n * Performance optimizations:\n * - Inlined array copies eliminate function call overhead\n * - Object pooling for push/pop operations reduces GC pressure\n * - Direct property assignment maintains V8 hidden classes\n */\nexport declare class RenderState {\n    private _currentLineWeight;\n    private _currentTranslationX;\n    private _currentTranslationY;\n    private _currentTranslationZ;\n    private _rotationX;\n    private _rotationY;\n    private _rotationZ;\n    private _currentCharacter;\n    private _currentCharColor;\n    private _currentCellColor;\n    private _flipHorizontally;\n    private _flipVertically;\n    private _invert;\n    private _charRotation;\n    private _canvasBackgroundColor;\n    private _useOrtho;\n    private _stateStack;\n    private _statePool;\n    /**\n     * Create a new state object with pre-allocated arrays.\n     * Used by the object pool to minimize garbage collection.\n     * @internal Shared with DrawQueue for command slot initialization\n     */\n    static $createStateObject(): IRenderState;\n    /**\n     * Copy current state to target object without allocations.\n     *\n     * Performance-critical path: This is called every push() operation.\n     * Optimizations:\n     * - Direct property assignment (no loops, no function calls)\n     * - Inlined array element copies (avoids copyArray() overhead)\n     * - Sequential memory access pattern for CPU cache efficiency\n     *\n     * @param target - Target state object to receive values\n     * @private\n     */\n    private _copyCurrentToState;\n    /**\n     * Copy state object to current state without allocations.\n     *\n     * Performance-critical path: This is called every pop() operation.\n     * Optimizations:\n     * - Direct property assignment (no loops, no function calls)\n     * - Inlined array element copies (avoids copyArray() overhead)\n     * - Sequential memory access pattern for CPU cache efficiency\n     *\n     * @param source - Source state object to copy from\n     * @private\n     */\n    private _copyStateToCurrents;\n    /**\n     * Save the current rendering state to the state stack.\n     * Uses object pooling to eliminate per-frame allocations and reduce GC pressure.\n     */\n    $push(): void;\n    /**\n     * Restore the most recently saved rendering state from the state stack.\n     * Returns the state object to the pool for reuse.\n     */\n    $pop(): void;\n    /**\n     * Copy current rendering state to a target object without allocations.\n     * Mutates the target's properties and arrays in-place for zero-allocation performance.\n     *\n     * @param target - Pre-allocated state object to copy values into\n     */\n    $copyTo(target: IRenderState): void;\n    $setLineWeight(weight: number): void;\n    /**\n     * Reset transformation matrix to identity and clear translation counters.\n     * Should be called at the start of each frame to prevent accumulation.\n     */\n    $resetTransform(): void;\n    /**\n     * Apply a rotation around the X-axis to the current transformation matrix.\n     * Follows p5.js convention where order matters.\n     * @param degrees Rotation angle in degrees\n     */\n    $setRotationX(degrees: number): void;\n    /**\n     * Apply a rotation around the Y-axis to the current transformation matrix.\n     * Follows p5.js convention where order matters.\n     * @param degrees Rotation angle in degrees\n     */\n    $setRotationY(degrees: number): void;\n    /**\n     * Apply a rotation around the Z-axis to the current transformation matrix.\n     * Follows p5.js convention where order matters.\n     * @param degrees Rotation angle in degrees\n     */\n    $setRotationZ(degrees: number): void;\n    $translate(x?: number, y?: number, z?: number): void;\n    $setTranslationX(pixels: number): void;\n    $setTranslationY(pixels: number): void;\n    $setTranslationZ(pixels: number): void;\n    $setCharacter(character: [number, number, number]): void;\n    $setCharColor(r: number, g?: number, b?: number, a?: number): void;\n    $setCellColor(r: number, g?: number, b?: number, a?: number): void;\n    $setFlipHorizontally(flip: boolean): void;\n    $setFlipVertically(flip: boolean): void;\n    $setInvert(invert: boolean): void;\n    $setCharRotation(rotation: number): void;\n    $setCanvasBackground(r: number, g: number, b: number, a: number): void;\n    $setUseOrtho(useOrtho: boolean): void;\n    get canvasBackgroundColor(): [number, number, number, number];\n    get useOrtho(): boolean;\n    /**\n     * Get the current transformation matrix.\n     * Returns the underlying Float32Array for efficient GPU upload.\n     */\n    get rotationX(): number;\n    get rotationY(): number;\n    get rotationZ(): number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/types/DrawCommand.d.ts": "import type { GeometryParams, GeometryType } from './GeometryTypes';\nimport type { IRenderState } from '../state/RenderState';\nimport type { GLShader } from '../core/Shader';\nimport type { Material } from '../materials/Material';\nexport type CustomRectParams = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    shader: GLShader;\n    uniforms: Record<string, any>;\n};\nexport type DrawParams = GeometryParams | CustomRectParams;\nexport interface DrawCommand {\n    id: number;\n    type: GeometryType;\n    params: DrawParams;\n    state: IRenderState;\n    material: Material;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/types/GeometryTypes.d.ts": "/**\n * Core interfaces and types for the instanced geometry system\n */\nimport type { InstanceBatch } from '../batching/InstanceBatch';\n/**\n * Geometry types supported by the instanced rendering system\n */\nexport declare enum GeometryType {\n    RECTANGLE = \"rectangle\",\n    LINE = \"line\",\n    ELLIPSE = \"ellipse\",\n    ARC = \"arc\",\n    TRIANGLE = \"triangle\",\n    BEZIER_CURVE = \"bezier_curve\"\n}\n/**\n * Mapping from GeometryType to numeric shader constant.\n * Must match the constants defined in instanced.vert:\n * - GEOMETRY_TYPE_FLAT = 2 (rectangle, line, ellipse, triangle)\n * - GEOMETRY_TYPE_ARC = 3\n * - GEOMETRY_TYPE_BEZIER = 4\n */\nexport declare const GEOMETRY_TYPE_ID: Record<GeometryType, number>;\n/**\n * Unit geometry vertex data for a specific geometry type\n */\nexport interface UnitGeometryData {\n    /** Vertex data as Float32Array (position + texCoord interleaved) */\n    _vertices: Float32Array;\n    /** Number of vertices in the geometry */\n    _vertexCount: number;\n    /** WebGL primitive type (gl.TRIANGLES, gl.LINES, etc.) */\n    _primitiveType: number;\n    /** Stride in bytes between vertices */\n    _stride: number;\n    /** Attribute configuration for position and texCoord */\n    _attributes: {\n        _position: {\n            size: number;\n            offset: number;\n        };\n        _texCoord: {\n            size: number;\n            offset: number;\n        };\n    };\n}\n/**\n * Interface for instanced geometry implementations\n */\nexport interface IGeometry {\n    /** The geometry type identifier */\n    readonly type: GeometryType;\n    /** The unit geometry data for this geometry type */\n    readonly unitGeometry: UnitGeometryData;\n    /** The instance batch for managing instances of this geometry */\n    readonly batch: InstanceBatch;\n    /**\n     * Add a new instance of this geometry to the batch\n     * @param params Geometry-specific parameters\n     * @param renderState Current render state\n     * @returns Index of the added instance\n     */\n    $addInstance(params: any, renderState: any): number;\n    /**\n     * Clear all instances from the batch\n     */\n    $clearInstances(): void;\n    /**\n     * Check if the geometry has any instances to render\n     */\n    $hasInstances(): boolean;\n    /**\n     * Dispose of geometry resources\n     */\n    $dispose(): void;\n}\n/**\n * Parameters for rectangle geometry\n */\nexport interface RectangleParams {\n    width: number;\n    height: number;\n}\n/**\n * Parameters for line geometry\n */\nexport interface LineParams {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    thickness?: number;\n}\n/**\n * Parameters for ellipse geometry\n */\nexport interface EllipseParams {\n    width: number;\n    height: number;\n    startAngle?: number;\n    endAngle?: number;\n    segments?: number;\n}\n/**\n * Parameters for arc geometry (filled pie segment)\n * Angles are specified in DEGREES and arcs are drawn clockwise from start to stop.\n */\nexport interface ArcParams {\n    width: number;\n    height: number;\n    start: number;\n    stop: number;\n}\n/**\n * Parameters for triangle geometry\n */\nexport interface TriangleParams {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n}\n/**\n * Parameters for bezier curve geometry\n */\nexport interface BezierCurveParams {\n    x1: number;\n    y1: number;\n    cp1x: number;\n    cp1y: number;\n    cp2x: number;\n    cp2y: number;\n    x2: number;\n    y2: number;\n    thickness?: number;\n    segments?: number;\n}\n/**\n * Union type for all geometry parameters\n */\nexport type GeometryParams = RectangleParams | LineParams | EllipseParams | ArcParams | TriangleParams | BezierCurveParams;",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/types/RenderTypes.d.ts": "/**\n * Rendering pipeline interfaces and types\n */\nimport type { GLShader } from '../core/Shader';\n/**\n * Render context containing shader and rendering configuration\n */\nexport interface RenderContext {\n    shader: GLShader;\n    gl: WebGL2RenderingContext;\n    viewport: [number, number, number, number];\n    cellWidth?: number;\n    cellHeight?: number;\n}",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/utils/GLUtils.d.ts": "/**\n * Update a WebGL texture from a canvas or video source.\n * Handles binding, pixel storage, upload, and unbinding.\n *\n * @param gl WebGL2 rendering context\n * @param texture Target texture to update\n * @param source Canvas or video element to upload\n */\nexport declare function updateTextureFromSource(gl: WebGL2RenderingContext, texture: WebGLTexture, source: HTMLCanvasElement | HTMLVideoElement): void;\n/**\n * Configure texture parameters for filtering and wrapping modes.\n * Must be called with texture already bound to gl.TEXTURE_2D.\n *\n * @param gl WebGL2 rendering context\n * @param minFilter Minification filter (gl.NEAREST or gl.LINEAR)\n * @param magFilter Magnification filter (gl.NEAREST or gl.LINEAR)\n * @param wrapS Horizontal wrapping mode (gl.CLAMP_TO_EDGE or gl.REPEAT)\n * @param wrapT Vertical wrapping mode (gl.CLAMP_TO_EDGE or gl.REPEAT)\n */\nexport declare function setTextureParameters(gl: WebGL2RenderingContext, minFilter: number, magFilter: number, wrapS: number, wrapT: number): void;\n/**\n * Configure a vertex attribute with pointer and divisor settings.\n * Handles enable, pointer setup, and divisor configuration in one call.\n *\n * @param gl WebGL2 rendering context\n * @param location Attribute location from shader\n * @param size Number of components per vertex attribute (1-4)\n * @param stride Byte offset between consecutive vertex attributes\n * @param offset Byte offset of the first component in the buffer\n * @param divisor Number of instances that will pass between updates (0 = per-vertex, 1 = per-instance)\n * @param type Data type (default: gl.FLOAT)\n * @param normalized Whether integer data should be normalized (default: false)\n */\nexport declare function setupVertexAttribute(gl: WebGL2RenderingContext, location: number, size: number, stride: number, offset: number, divisor?: number, type?: number, normalized?: boolean): void;\n/**\n * Allocate or upload data to a buffer (bind  bufferData  unbind pattern).\n * Ensures proper binding/unbinding sequence for safe buffer operations.\n *\n * @param gl WebGL2 rendering context\n * @param target Buffer binding point (gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER)\n * @param buffer Target buffer to bind\n * @param data Data to upload, or size in bytes for allocation\n * @param usage Usage hint (gl.STATIC_DRAW, gl.DYNAMIC_DRAW, etc.)\n */\nexport declare function uploadBufferData(gl: WebGL2RenderingContext, target: number, buffer: WebGLBuffer, data: AllowSharedBufferSource | number, usage: number): void;",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/utils/hash.d.ts": "/**\n * Generic hashing utilities for creating stable hash codes from various data types.\n *\n * These functions are useful for:\n * - Object deduplication (e.g., materials, shaders)\n * - Cache keys\n * - Fast equality comparisons\n *\n * Hash algorithm: Simple 32-bit integer hash with good distribution.\n * Not cryptographically secure, but fast and collision-resistant for typical use cases.\n */\n/**\n * Hash a string to a 32-bit integer.\n * Uses the djb2 algorithm variant.\n *\n * @param str - String to hash\n * @returns 32-bit integer hash\n *\n * \n */\nexport declare function hashString(str: string): number;\n/**\n * Hash a number or boolean to an integer.\n * Booleans are converted to 0/1.\n *\n * @param value - Number or boolean to hash\n * @returns Integer hash\n *\n * \n */\nexport declare function hashNumber(value: number | boolean): number;\n/**\n * Hash an array of numbers.\n * Supports nested arrays (will be flattened).\n *\n * @param arr - Array of numbers or nested arrays\n * @returns Combined hash of all elements\n *\n * \n */\nexport declare function hashArray(arr: number[] | number[][]): number;\n/**\n * Hash a typed array (Float32Array or Int32Array).\n * For performance, only hashes the first 16 elements for large arrays.\n *\n * @param arr - Typed array to hash\n * @returns Combined hash\n *\n * \n */\nexport declare function hashTypedArray(arr: Float32Array | Int32Array): number;\nexport declare function hashObject(obj: any): number;\n/**\n * Combine two hash values into a single hash.\n * Uses a simple but effective combination strategy.\n *\n * @param hash1 - First hash value\n * @param hash2 - Second hash value\n * @returns Combined hash\n *\n * \n */\nexport declare function combineHashes(hash1: number, hash2: number): number;\n/**\n * Hash a record/object by hashing its sorted keys and values.\n * Keys are sorted to ensure consistent hashing regardless of property order.\n *\n * @param record - Record to hash\n * @param valueHasher - Function to hash each value\n * @returns Combined hash of all key-value pairs\n *\n * \n */\nexport declare function hashRecord<T>(record: Record<string, T>, valueHasher: (value: T) => number): number;",
  "file:///node_modules/textmode.js/dist/types/rendering/webgl/utils/ViewportCache.d.ts": "type Viewport = [number, number, number, number];\nexport declare function setViewport(gl: WebGLRenderingContext, vp: Viewport): void;\nexport declare function getViewport(gl: WebGLRenderingContext): Viewport | undefined;\nexport {};",
  "file:///node_modules/textmode.js/dist/types/textmode/AnimationController.d.ts": "/**\n * Manages animation loop timing and frame rate control for textmode rendering.\n * Provides precise frame rate limiting and smooth animation timing.\n */\nexport declare class AnimationController {\n    private _frameInterval;\n    private _targetFrameRate;\n    private _animationFrameId;\n    private _lastFrameTime;\n    private _isLooping;\n    private _frameRate;\n    private _lastRenderTime;\n    private _frameTimeHistory;\n    private _frameTimeHistorySize;\n    private _deltaTime;\n    private _frameCount;\n    private _millisStart;\n    /**\n     * Creates an AnimationController instance.\n     * @param frameRateLimit Maximum frames per second. Defaults to 60.\n     */\n    constructor(frameRateLimit?: number);\n    /**\n     * Start the animation loop with the provided render callback.\n     * @param renderCallback Function to call for each frame render\n     */\n    $start(renderCallback: () => void): void;\n    /**\n     * Stop the animation loop.\n     */\n    $stop(): void;\n    /**\n     * Pause the animation loop without stopping it completely.\n     */\n    $pause(): void;\n    /**\n     * Resume the animation loop if it was paused.\n     * @param renderCallback Function to call for each frame render\n     */\n    $resume(renderCallback: () => void): void;\n    /**\n     * Set or get the frame rate limit.\n     * @param fps Optional new frame rate limit. If not provided, returns current measured frame rate.\n     * @param renderCallback Required when setting new frame rate and animation is running\n     * @returns Current measured frame rate when getting, void when setting\n     */\n    $frameRate(fps?: number, renderCallback?: () => void): number | void;\n    /**\n     * Update frame rate measurement. Should be called on each render.\n     * Uses a rolling average for smoother frame rate reporting.\n     */\n    $measureFrameRate(): void;\n    /**\n     * Check if the animation loop is currently active.\n     */\n    get $isLooping(): boolean;\n    /**\n     * Get the current measured frame rate.\n     */\n    get $currentFrameRate(): number;\n    /**\n     * Get the target frame rate limit.\n     */\n    get $targetFrameRate(): number;\n    /**\n     * Set the target frame rate limit.\n     * @param value The new target frame rate in frames per second\n     */\n    set $targetFrameRate(value: number);\n    /**\n     * Get the current frame count.\n     */\n    get $frameCount(): number;\n    /**\n     * Set the current frame count.\n     */\n    set $frameCount(value: number);\n    /**\n     * Increment the frame count by one.\n     * Should be called on each render to track total frames rendered.\n     */\n    $incrementFrame(): void;\n    /**\n     * Get the number of milliseconds since the animation started.\n     * Returns 0 if the animation has not started yet.\n     */\n    get $millis(): number;\n    /**\n     * Set the elapsed milliseconds by adjusting the start time.\n     * This allows seeking/scrubbing in animations.\n     * @param value The new elapsed time in milliseconds\n     */\n    set $millis(value: number);\n    /**\n     * Get the number of seconds since the animation started.\n     * Returns 0 if the animation has not started yet.\n     */\n    get $secs(): number;\n    /**\n     * Set the elapsed seconds by adjusting the start time.\n     * This allows seeking/scrubbing in animations.\n     * @param value The new elapsed time in seconds\n     */\n    set $secs(value: number);\n    /**\n     * Get the time in milliseconds between the current frame and the last frame.\n     * Useful for frame-rate-independent animations.\n     */\n    get $deltaTime(): number;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/Canvas.d.ts": "import type { TextmodeOptions } from './types';\nimport { type RGBA } from './utils/cssColor';\n/**\n * Manages a `HTMLCanvasElement` for textmode rendering.\n * @ignore\n */\nexport declare class TextmodeCanvas {\n    private _canvas;\n    private _targetCanvas;\n    private _isOverlay;\n    private _canvasCreatedByUs;\n    /**\n     * Creates a new TextmodeCanvas instance.\n     * @param opts Options for creating or using an existing canvas\n     * @ignore\n     */\n    constructor(opts?: TextmodeOptions);\n    private _createCanvas;\n    private _createOverlayCanvas;\n    private _setupOverlayPositioning;\n    private _collectBackgroundSources;\n    /**\n     * Attempts to detect the background color behind the textmode canvas.\n     * Used internally for theming transparent UI elements like the loading screen.\n     * @ignore\n     */\n    $sampleBackgroundColor(): RGBA | null;\n    private _positionOverlayCanvas;\n    /**\n     * Resize the canvas to the specified width and height.\n     * If width or height is not provided, it retains the current dimension.\n     * @param width The new width of the canvas in pixels.\n     * @param height The new height of the canvas in pixels.\n     * @ignore\n     */\n    $resize(width?: number, height?: number): void;\n    /**\n     * Get the WebGL context for the overlay canvas\n     * @ignore\n     */\n    $getWebGLContext(): WebGL2RenderingContext;\n    /**\n     * Dispose of this TextmodeCanvas and clean up all resources.\n     * This method is idempotent and safe to call multiple times.\n     * @ignore\n     */\n    $dispose(): void;\n    /** Getters */\n    get canvas(): HTMLCanvasElement;\n    get targetCanvas(): HTMLCanvasElement | HTMLVideoElement | null;\n    get width(): number;\n    get height(): number;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/conversion/ConversionManager.d.ts": "import type { TextmodeConversionMode, TextmodeConversionStrategy } from './ConversionRegistry';\n/**\n * Manages conversion strategy registration and retrieval.\n *\n * This class provides:\n * - A registry for custom and built-in conversion strategies\n * - Instance-scoped conversion strategies per Textmodifier\n *\n * Used for image-to-ASCII conversion modes.\n *\n * \n */\nexport declare class TextmodeConversionManager {\n    private readonly _conversionRegistry;\n    /**\n     * Create a new TextmodeConversionManager.\n     * @param renderer The WebGL renderer instance\n     * @ignore\n     */\n    constructor();\n    /**\n     * Register a custom conversion strategy.\n     *\n     * @param strategy The conversion strategy to register\n     *\n     * \n     */\n    register(strategy: TextmodeConversionStrategy): void;\n    /**\n     * Unregister a conversion strategy by its ID.\n     *\n     * @param id The conversion strategy ID to unregister\n     * @returns true if the strategy was unregistered, false if it wasn't found\n     */\n    unregister(id: TextmodeConversionMode): boolean;\n    /**\n     * Check if a conversion strategy with the given ID is registered.\n     *\n     * @param id The conversion strategy ID to check\n     * @returns true if the strategy exists\n     */\n    has(id: TextmodeConversionMode): boolean;\n    /**\n     * Get a registered conversion strategy by its ID.\n     * @param id The ID of the conversion strategy\n     * @returns The conversion strategy, or undefined if not found\n     * @ignore\n     */\n    $get(id: TextmodeConversionMode): TextmodeConversionStrategy | undefined;\n    /**\n     * Dispose of all resources.\n     * @ignore\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/conversion/ConversionRegistry.d.ts": "import type { GLShader } from '../../rendering';\nimport type { GLRenderer } from '../../rendering/webgl/core/Renderer';\nimport type { TextmodeFont } from '../loadables/font/TextmodeFont';\nimport type { TextmodeSource } from '../loadables/TextmodeSource';\n/**\n * Built-in conversion mode names provided by textmode.js\n */\nexport type BuiltInConversionMode = 'brightness';\n/**\n * Type representing the available textmode conversion modes\n */\nexport type TextmodeConversionMode = BuiltInConversionMode | string;\n/**\n * Interface for the context provided to conversion strategies\n * @ignore\n */\nexport interface TextmodeConversionContext {\n    renderer: GLRenderer;\n    gl: WebGL2RenderingContext;\n    font: TextmodeFont;\n    source: TextmodeSource;\n    gridWidth: number;\n    gridHeight: number;\n}\n/**\n * Interface for a textmode conversion strategy\n * @ignore\n */\nexport interface TextmodeConversionStrategy {\n    readonly id: TextmodeConversionMode;\n    createShader(context: TextmodeConversionContext): GLShader;\n    createUniforms(context: TextmodeConversionContext): Record<string, any>;\n}\n/**\n * Instance-based registry for conversion strategies.\n *\n * Each {@link ConversionManager} instance has its own ConversionRegistry, allowing\n * conversion strategies to be scoped to a specific Textmodifier instance rather than registered globally.\n *\n * \n * @ignore\n */\nexport declare class ConversionRegistry {\n    private readonly _strategies;\n    private readonly _shaderCache;\n    /**\n     * Create a new ConversionRegistry.\n     * @param renderer The WebGL renderer instance\n     */\n    constructor();\n    /**\n     * Register a conversion strategy.\n     * @param strategy The conversion strategy to register\n     */\n    $register(strategy: TextmodeConversionStrategy): void;\n    /**\n     * Unregister a conversion strategy by its ID.\n     *\n     * @param id The conversion strategy ID to unregister\n     * @returns true if the strategy was unregistered, false if it wasn't found\n     */\n    $unregister(id: TextmodeConversionMode): boolean;\n    /**\n     * Get a conversion strategy by ID.\n     * @internal\n     */\n    $get(id: TextmodeConversionMode): TextmodeConversionStrategy | undefined;\n    /**\n     * Check if a conversion strategy with the given ID is registered.\n     *\n     * @param id The conversion strategy ID to check\n     * @returns true if the strategy exists\n     */\n    $has(id: TextmodeConversionMode): boolean;\n    /**\n     * Dispose all resources.\n     * @internal\n     */\n    $dispose(): void;\n    /**\n     * Register all built-in conversion strategies.\n     */\n    private _registerBuiltInStrategies;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/conversion/index.d.ts": "export type { BuiltInConversionMode, TextmodeConversionMode, TextmodeConversionContext, TextmodeConversionStrategy, } from './ConversionRegistry';\nexport { ConversionRegistry } from './ConversionRegistry';\nexport { TextmodeConversionManager } from './ConversionManager';",
  "file:///node_modules/textmode.js/dist/types/textmode/conversion/strategies/brightness.d.ts": "import type { TextmodeConversionStrategy } from '../ConversionRegistry';\nexport declare const brightnessStrategy: TextmodeConversionStrategy;",
  "file:///node_modules/textmode.js/dist/types/textmode/filters/FilterManager.d.ts": "import type { GLRenderer, GLShader, GLFramebuffer } from '../../rendering';\nimport type { QueuedFilter, FilterName } from './types';\n/**\n * Manages filter registration, shader compilation, and filter chain application.\n *\n * Used both for layer-level filters and global post-processing filters.\n *\n * \n */\nexport declare class TextmodeFilterManager {\n    private readonly _renderer;\n    private readonly _shaderCache;\n    private readonly _copyShader;\n    private _pingPongBuffers;\n    private _isInitialized;\n    private _filterRegistry;\n    /**\n     * Create a new TextmodeFilterManager.\n     * @param renderer The WebGL renderer instance\n     * @ignore\n     */\n    constructor(renderer: GLRenderer);\n    /**\n     * Register a custom filter with the given ID, shader, and uniform definitions.\n     *\n     * @param id Unique filter identifier\n     * @param shader Pre-compiled GLShader, fragment shader source string, or path to a .frag/.glsl file\n     * @param uniformDefs Maps uniform names to [paramName, defaultValue] tuples\n     *\n     * \n     */\n    register(id: FilterName, shader: GLShader | string, uniformDefs?: Record<string, [paramName: string, defaultValue: unknown]>): Promise<void>;\n    /**\n     * Unregister a filter by its ID.\n     *\n     * @param id The filter ID to unregister\n     * @returns true if the filter was unregistered, false if it wasn't found\n     */\n    unregister(id: FilterName): boolean;\n    /**\n     * Check if a filter with the given ID is registered.\n     *\n     * @param id The filter ID to check\n     * @returns true if the filter exists\n     */\n    has(id: FilterName): boolean;\n    /**\n     * Initialize ping-pong buffers for filter chain processing.\n     * @param width Buffer width in pixels\n     * @param height Buffer height in pixels\n     * @ignore\n     */\n    $initialize(width: number, height: number): void;\n    /**\n     * Apply a chain of filters to the source texture, outputting to target.\n     * Uses the manager's internal ping-pong buffers.\n     *\n     * @param sourceTexture The input texture\n     * @param targetFramebuffer The output framebuffer\n     * @param filters The queue of filters to apply in order\n     * @param width Framebuffer width\n     * @param height Framebuffer height\n     * @ignore\n     */\n    $applyFilters(sourceTexture: WebGLTexture, targetFramebuffer: GLFramebuffer, filters: QueuedFilter[], width: number, height: number): void;\n    /**\n     * Apply a chain of filters using external ping-pong buffers.\n     * This allows sharing the filter registry while using different buffer sizes\n     * (e.g., layer filters at grid dimensions vs global filters at canvas dimensions).\n     *\n     * @param sourceTexture The input texture\n     * @param targetFramebuffer The output framebuffer\n     * @param filters The queue of filters to apply in order\n     * @param width Framebuffer width\n     * @param height Framebuffer height\n     * @param pingPongBuffers External ping-pong buffers to use\n     * @ignore\n     */\n    $applyFiltersWithBuffers(sourceTexture: WebGLTexture, targetFramebuffer: GLFramebuffer, filters: QueuedFilter[], width: number, height: number, pingPongBuffers: [GLFramebuffer, GLFramebuffer]): void;\n    /**\n     * Apply a single filter pass with explicit source buffer.\n     */\n    private _applyFilterWithBuffer;\n    /**\n     * Get or create a cached shader for the given filter.\n     */\n    private _getOrCreateShader;\n    /**\n     * Copy a texture to a framebuffer using the copy shader.\n     */\n    private _copyTexture;\n    /**\n     * Resize the ping-pong buffers.\n     * @param width New width in pixels\n     * @param height New height in pixels\n     * @ignore\n     */\n    $resize(width: number, height: number): void;\n    /**\n     * Dispose of all resources.\n     * @ignore\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/filters/FilterRegistry.d.ts": "import type { GLRenderer, GLShader } from '../../rendering';\nimport type { TextmodeFilterStrategy, FilterName } from './types';\n/**\n * Instance-based registry for filter strategies.\n *\n * Each {@link FilterManager} instance has its own FilterRegistry, allowing\n * filters to be scoped to a specific context rather than registered globally.\n *\n * \n * @ignore\n */\nexport declare class FilterRegistry {\n    private readonly _renderer;\n    private readonly _filters;\n    private readonly _shaderCache;\n    /**\n     * Create a new FilterRegistry.\n     * @param renderer The WebGL renderer instance\n     */\n    constructor(renderer: GLRenderer);\n    /**\n     * Define a filter using a simplified declarative syntax.\n     *\n     * This is the easiest way to create filters for add-on libraries.\n     * The shader is compiled immediately and cached.\n     *\n     * @param id Unique filter identifier\n     * @param shader Pre-compiled GLShader, fragment shader source string, or path to a fragment shader file (.frag or .glsl)\n     * @param uniforms Default uniform values. Keys map uniform names to [paramName, defaultValue] tuples.\n     *\n     * \n     */\n    $register(id: FilterName, shader: GLShader | string, defs?: Record<string, [paramName: string, defaultValue: unknown]>): Promise<void>;\n    /**\n     * Unregister a filter by its ID.\n     *\n     * @param id The filter ID to unregister\n     * @returns true if the filter was unregistered, false if it wasn't found\n     */\n    $unregister(id: FilterName): boolean;\n    /**\n     * Get a filter strategy by ID.\n     * @internal\n     */\n    $get(id: FilterName): TextmodeFilterStrategy | undefined;\n    /**\n     * Dispose all resources.\n     * @internal\n     */\n    $dispose(): void;\n    /**\n     * Register all built-in filters.\n     */\n    private _registerBuiltInFilters;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/filters/index.d.ts": "export type { FilterName, BuiltInFilterName, BuiltInFilterParams, QueuedFilter, FilterContext, TextmodeFilterStrategy, } from './types';\nexport { FilterRegistry } from './FilterRegistry';\nexport { TextmodeFilterManager } from './FilterManager';",
  "file:///node_modules/textmode.js/dist/types/textmode/filters/types.d.ts": "import type { GLShader } from '../../rendering';\nimport type { GLRenderer } from '../../rendering/webgl/core/Renderer';\n/**\n * Built-in filter names provided by textmode.js\n */\nexport type BuiltInFilterName = 'invert' | 'grayscale' | 'sepia' | 'threshold';\n/**\n * Filter name type that allows both built-in and custom filter names\n */\nexport type FilterName = BuiltInFilterName | string;\n/**\n * Filter parameter types for built-in filters.\n *\n * Most filters accept either a single number (for the primary parameter)\n * or an object with named properties.\n */\nexport interface BuiltInFilterParams {\n    /** Inverts all colors (no params needed) */\n    invert: void;\n    /** Converts to grayscale. Amount: 0-1, default 1 */\n    grayscale: number | {\n        amount?: number;\n    } | void;\n    /** Applies sepia tone. Amount: 0-1, default 1 */\n    sepia: number | {\n        amount?: number;\n    } | void;\n    /** Black/white threshold. Threshold: 0-1, default 0.5 */\n    threshold: number | {\n        threshold?: number;\n    };\n}\n/**\n * A queued filter operation to be applied during rendering\n * @ignore\n */\nexport interface QueuedFilter {\n    name: FilterName;\n    params: unknown;\n}\n/**\n * Context provided to filter strategies for shader creation\n * @ignore\n */\nexport interface FilterContext {\n    /** The WebGL renderer instance */\n    renderer: GLRenderer;\n    /** The WebGL2 rendering context */\n    gl: WebGL2RenderingContext;\n    /** Width of the framebuffer being filtered */\n    width: number;\n    /** Height of the framebuffer being filtered */\n    height: number;\n}\n/**\n * Interface for implementing custom filter strategies.\n * @ignore\n */\nexport interface TextmodeFilterStrategy {\n    /** Unique identifier for this filter */\n    readonly id: FilterName;\n    /**\n     * Create the shader program for this filter.\n     * Called once when the filter is first used (lazy initialization).\n     * @param context The filter context containing renderer and dimensions\n     * @returns The compiled shader program\n     */\n    createShader(context: FilterContext): GLShader;\n    /**\n     * Create uniform values for this filter based on user parameters.\n     * Called each time the filter is applied.\n     * @param params The parameters passed by the user (can be undefined)\n     * @param context The filter context containing dimensions\n     * @returns An object mapping uniform names to values\n     */\n    createUniforms(params: unknown, context: FilterContext): Record<string, unknown>;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/Grid.d.ts": "/**\n * Manages the grid of each `TextmodeLayer` instance.\n */\nexport declare class TextmodeGrid {\n    /** The number of columns in the grid. */\n    private _cols;\n    /** The number of rows in the grid. */\n    private _rows;\n    /** The total width of the grid in pixels. */\n    private _width;\n    /** The total height of the grid in pixels. */\n    private _height;\n    /** The offset to the outer canvas on the x-axis when centering the grid. */\n    private _offsetX;\n    /** The offset to the outer canvas on the y-axis when centering the grid. */\n    private _offsetY;\n    /** The canvas element used to determine the grid dimensions. */\n    private _canvas;\n    /** The width of each cell in the grid. */\n    private _cellWidth;\n    /** The height of each cell in the grid. */\n    private _cellHeight;\n    /** Tracks whether cols/rows were manually overridden. */\n    private _manualDimensionsSet;\n    /** Hooks to notify listeners when grid dimensions change. */\n    private _dimensionChangeListeners;\n    /** Updates derived metrics (width/height/offset) from current cols/rows. */\n    private _syncDerivedDimensions;\n    /**\n     * Create a new grid instance.\n     * @param canvas The canvas element used to determine the grid dimensions.\n     * @param cellWidth The width of each cell in the grid.\n     * @param cellHeight The height of each cell in the grid.\n     * @ignore\n     */\n    constructor(canvas: HTMLCanvasElement, cellWidth: number, cellHeight: number);\n    /**\n     * Register a listener invoked whenever grid dimensions change.\n     * @param handler The callback function to invoke on dimension changes.\n     * @ignore\n     */\n    $addOnDimensionsChange(handler: () => void): void;\n    /**\n     * Remove a previously registered dimensions change listener.\n     * @param handler The callback function to remove.\n     * @ignore\n     */\n    $removeOnDimensionsChange(handler: () => void): void;\n    /**\n     * Reset the grid to the default number of columns and rows based on the current canvas dimensions, and the grid cell dimensions.\n     * @ignore\n     */\n    $reset(): void;\n    /**\n     * Re-assign the grid cell dimensions and `reset()` the grid.\n     * @param newCellWidth The new cell width.\n     * @param newCellHeight The new cell height.\n     * @ignore\n     */\n    $resizeCellPixelDimensions(newCellWidth: number, newCellHeight: number): void;\n    /** Returns the width of each cell in the grid. */\n    get cellWidth(): number;\n    /** Returns the height of each cell in the grid. */\n    get cellHeight(): number;\n    /** Returns the number of columns in the grid. */\n    get cols(): number;\n    /** Sets the number of columns and locks grid sizing until `responsive()` is called. */\n    set cols(newCols: number);\n    /** Returns the number of rows in the grid. */\n    get rows(): number;\n    /** Sets the number of rows and locks grid sizing until `responsive()` is called. */\n    set rows(newRows: number);\n    /** Returns the total width of the grid. */\n    get width(): number;\n    /** Returns the total height of the grid. */\n    get height(): number;\n    /** Returns the offset to the outer canvas borders on the x-axis when centering the grid. */\n    get offsetX(): number;\n    /** Returns the offset to the outer canvas borders on the y-axis when centering the grid. */\n    get offsetY(): number;\n    /**\n     * Restores responsive sizing so subsequent `t.resizeCanvas` calls recompute cols/rows.\n     *\n     * A grid becomes non-responsive when either `cols` or `rows` is manually set.\n     */\n    responsive(): void;\n    /**\n     * Dispose the grid and remove all listeners.\n     * @ignore\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/interfaces/index.d.ts": "export type { ITextmodifier } from './ITextmodifier';",
  "file:///node_modules/textmode.js/dist/types/textmode/interfaces/ITextmodifier.d.ts": "import type { TextmodeGrid } from '../Grid';\nimport type { TextmodeFont } from '../loadables/font';\nimport type { TextmodeImage } from '../loadables/TextmodeImage';\nimport type { TextmodeCanvas } from '../Canvas';\nimport type { AnimationController } from '../AnimationController';\nimport type { GLRenderer } from '../../rendering/webgl/core/Renderer';\nimport type { MouseManager } from '../managers/MouseManager';\nimport type { KeyboardManager } from '../managers/KeyboardManager';\nimport type { TouchManager } from '../managers/TouchManager';\nimport type { IRenderingMixin } from '../mixins/interfaces/IRenderingMixin';\nimport type { IKeyboardMixin } from '../mixins/interfaces/IKeyboardMixin';\nimport type { ITouchMixin } from '../mixins/interfaces/ITouchMixin';\nimport type { IMouseMixin } from '../mixins/interfaces/IMouseMixin';\nimport type { IAnimationMixin } from '../mixins/interfaces/IAnimationMixin';\nimport type { LoadingScreenManager } from '../loading/LoadingScreenManager';\nimport type { TextmodeLayerManager } from '../layers';\nimport type { TextmodeLayer } from '../layers/TextmodeLayer';\nimport type { BuiltInFilterName, BuiltInFilterParams, TextmodeFilterManager, FilterName } from '../filters';\nimport type { TextmodeConversionManager } from '../conversion';\n/**\n * Manages textmode rendering on a [`HTMLCanvasElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) and provides methods for drawing,\n * exporting, font management, event handling, and animation control.\n *\n * If the `Textmodifier` instance is created without a canvas parameter,\n * it creates a new `HTMLCanvasElement` to draw on using the `textmode.js` drawing API.\n * If a canvas is provided, it will use that canvas instead.\n */\nexport interface ITextmodifier extends IRenderingMixin, IAnimationMixin, IMouseMixin, ITouchMixin, IKeyboardMixin {\n    /** Core WebGL renderer @ignore */\n    readonly _renderer: GLRenderer;\n    /** Canvas management @ignore */\n    readonly _canvas: TextmodeCanvas;\n    /** Animation controller for managing rendering loop @ignore */\n    readonly _animationController: AnimationController;\n    /** Mouse interaction manager @ignore */\n    readonly _mouseManager: MouseManager;\n    /** Touch interaction manager @ignore */\n    readonly _touchManager: TouchManager;\n    /** Keyboard interaction manager @ignore */\n    readonly _keyboardManager: KeyboardManager;\n    /** Loading screen manager for boot-time UX @ignore */\n    readonly _loading: LoadingScreenManager;\n    /** Conversion manager for image-to-ASCII conversion @ignore */\n    readonly _conversionManager: TextmodeConversionManager;\n    /** Layer manager for handling multiple layers @ignore */\n    readonly _layerManager: TextmodeLayerManager;\n    /** Active layer currently being rendered @ignore */\n    _activeLayer?: TextmodeLayer;\n    /** Main render method @ignore */\n    $render(): void;\n    /**\n     * Load a font for the base layer and return it.\n     *\n     * The returned font can be reused on other layers via {@link TextmodeLayer.loadFont}.\n     *\n     * @param fontSource The URL of the font to load.\n     * @returns The loaded TextmodeFont instance (base layer font).\n     *\n     * \n     */\n    loadFont(fontSource: string): Promise<TextmodeFont>;\n    /**\n     * Set the font size used for rendering.\n     * @param size The font size to set.\n     *\n     * \n     */\n    fontSize(size: number): void;\n    /**\n     * Get or set the grid used for mouse and touch input coordinate mapping.\n     *\n     * By default, input coordinates are mapped to the topmost visible layer's grid,\n     * which changes dynamically as layers are shown/hidden. Use this method to lock\n     * input mapping to a specific grid or layer, or to return to responsive mode.\n     *\n     * When called without arguments, returns the current input grid mode:<br/>\n     * - `'topmost'` if using responsive mode (default)<br/>\n     * - The specific `TextmodeGrid` if locked\n     *\n     * \n     */\n    inputGrid(target?: 'topmost' | TextmodeGrid): 'topmost' | TextmodeGrid | void;\n    /**\n     * Set a setup callback function that will be executed once when initialization is complete.\n     *\n     * This callback is called after font loading and grid initialization, allowing access to\n     * properties like `textmodifier.grid.cols` for calculating layout or setup variables.\n     *\n     * @param callback The function to call when setup is complete\n     *\n     * \n     */\n    setup(callback: () => void): void;\n    /**\n     * Set a draw callback function for the base layer.\n     *\n     * This callback function is where all drawing commands should be placed for textmode rendering on the main layer.\n     *\n     * If multiple layers are added via {@link Textmodifier.layers}, each layer has its own draw callback set via {@link TextmodeLayer.draw}.\n     * This allows for complex multi-layered compositions with independent rendering logic per layer.\n     *\n     * Calling this method is equivalent to setting the draw callback on the base layer,\n     * while the direct layer callback has precedence if both are set.\n     * ```js\n     * textmodifier.layers.base.draw(callback);\n     * ```\n     *\n     * @param callback The function to call before each render\n     *\n     * \n     */\n    draw(callback: () => void): void;\n    /**\n     * Set a callback function that will be called when the window is resized.\n     * @param callback The function to call when the window is resized.\n     *\n     * \n     */\n    windowResized(callback: () => void): void;\n    /**\n     * Resize the canvas and adjust all related components accordingly.\n     *\n     * @param width The new width of the canvas.\n     * @param height The new height of the canvas.\n     *\n     * \n     */\n    resizeCanvas(width: number, height: number): void;\n    /**\n     * Completely destroy this Textmodifier instance and free all associated resources.\n     *\n     * After calling this method, the instance should not be used and will be eligible for garbage collection.\n     *\n     * \n     */\n    destroy(): void;\n    /**\n     * Apply a filter to the final composited output.\n     *\n     * Filters are applied after all layers are composited but before\n     * the result is presented to the canvas. Multiple filters can be\n     * queued per frame and will be applied in order.\n     *\n     * @param name The name of the filter to apply (built-in or custom)\n     * @param params Optional parameters for the filter\n     *\n     * \n     */\n    filter<T extends BuiltInFilterName>(name: T, params?: BuiltInFilterParams[T]): void;\n    filter(name: FilterName, params?: unknown): void;\n    filter(name: FilterName, params?: unknown): void;\n    /**\n     * Get the grid whose layer is currently being drawn to.\n     * If called outside of a layers draw callback, returns the base layer's grid.\n     *\n     * If no grid is set (e.g., before user setup()), returns `undefined`.\n     */\n    readonly grid: TextmodeGrid | undefined;\n    /** Get the current font object used for rendering the base layer. */\n    readonly font: TextmodeFont;\n    /** Get the width of the canvas in pixels. */\n    readonly width: number;\n    /** Get the height of the canvas in pixels. */\n    readonly height: number;\n    /** Get the textmodifier canvas containing the rendered output. */\n    readonly canvas: HTMLCanvasElement;\n    /** Check if the instance has been disposed/destroyed. */\n    readonly isDisposed: boolean;\n    /**\n     * Access the filter manager for this Textmodifier instance.\n     *\n     * Use this to register custom filters that can be applied both globally\n     * (via {@link filter}) and on individual layers (via {@link TextmodeLayer.filter}).\n     *\n     * \n     */\n    readonly filters: TextmodeFilterManager;\n    /**\n     * Access the layer manager for this Textmodifier instance.\n     *\n     * Use this to create and manage multiple layers within the textmode rendering context.\n     * Each layer has its own grid, font, draw callback, and filters.\n     */\n    readonly layers: TextmodeLayerManager;\n    /**\n     * Access the conversion manager for this Textmodifier instance.\n     *\n     * Use this to register custom conversion strategies that can be used\n     * when converting images/videos/canvases into textmode representations.\n     */\n    readonly conversions: TextmodeConversionManager;\n    /**\n     * If in overlay mode, returns the {@link TextmodeImage} instance capturing the target canvas/video content,\n     * allowing further configuration of the conversion parameters.\n     *\n     * \n     */\n    readonly overlay: TextmodeImage | undefined;\n    /**\n     * Provides access to the loading screen manager to control boot-time loading UX.\n     *\n     * \n     */\n    readonly loading: LoadingScreenManager;\n    /**\n     * Check if rendering is currently in progress for this frame.\n     */\n    readonly isRenderingFrame: boolean;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/layers/index.d.ts": "export { TextmodeLayer } from './TextmodeLayer';\nexport { LayerManager as TextmodeLayerManager } from './LayerManager';\nexport { Layer2DCompositor as LayerCompositor } from './Layer2DCompositor';\nexport type { TextmodeLayerOptions, TextmodeLayerBlendMode } from './types';",
  "file:///node_modules/textmode.js/dist/types/textmode/layers/interfaces/ILayerManager.d.ts": "import type { TextmodeLayer } from '../TextmodeLayer';\nimport type { TextmodeLayerOptions } from '../types';\nimport type { TextmodeGrid } from '../../Grid';\nimport type { GLFramebuffer } from '../../../rendering/webgl/core/Framebuffer';\nexport interface ILayerManager {\n    /**\n     * Get all user layers as a readonly array.\n     */\n    readonly all: readonly TextmodeLayer[];\n    /**\n     * The base layer that is always rendered at the bottom of the layer stack.\n     * This layer represents the main drawing content before any user layers are composited.\n     */\n    readonly base: TextmodeLayer;\n    /**\n     * The framebuffer containing the final composited result after all layers and filters have been applied.\n     */\n    readonly resultFramebuffer: GLFramebuffer;\n    /**\n     * Add a new layer to the manager.\n     * @param options Layer configuration options.\n     * @returns The newly added layer.\n     */\n    add(options?: TextmodeLayerOptions): TextmodeLayer;\n    /**\n     * Remove a layer from the manager.\n     * @param layer The layer to remove.\n     */\n    remove(layer: TextmodeLayer): void;\n    /**\n     * Move a layer to a new index in the layer stack.\n     * @param layer The layer to move.\n     * @param newIndex The new index for the layer.\n     */\n    move(layer: TextmodeLayer, newIndex: number): void;\n    /**\n     * Swap the order of two layers if they exist in the same collection.\n     * @param layerA The first layer to swap.\n     * @param layerB The second layer to swap.\n     */\n    swap(layerA: TextmodeLayer, layerB: TextmodeLayer): void;\n    /**\n     * Remove all user-created layers from the manager.\n     * The base layer is not affected by this operation.\n     * This is useful for integration into live-coding environments where code is re-evaluated\n     * and layers need to be recreated from scratch.\n     */\n    clear(): void;\n    /**\n     * Get the grid of the topmost visible layer.\n     * Returns the topmost user layer's grid if any are visible, otherwise returns the base layer's grid.\n     * This is useful for input managers that need to map coordinates to the layer the user sees on top.\n     */\n    $getTopmostGrid(): TextmodeGrid | undefined;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/layers/interfaces/ITextmodeLayer.d.ts": "import type { GLFramebuffer } from '../../../rendering';\nimport type { TextmodeFont } from '../../loadables/font';\nimport type { TextmodeLayerBlendMode } from '../types';\nimport type { FilterName, BuiltInFilterName, BuiltInFilterParams } from '../../filters';\nimport type { TextmodeGrid } from '../../Grid';\n/**\n * A single layer within a multi-layered textmode rendering context.\n *\n * Layers are composited together using various blend modes\n * to create complex visual effects. Each layer can be independently\n * manipulated in terms of visibility, opacity, blend mode, and position.\n *\n * You can draw on each layer by providing a draw callback function,\n * like you would with the base layer's {@link Textmodifier.draw} method.\n *\n * Plugins can extend TextmodeLayer with additional methods using the plugin API's\n * `extendLayer` function. For example, the `textmode-synth` plugin adds a `.synth()`\n * method for hydra-like procedural generation.\n *\n * You can also apply a sequence of post-processing filters to each layer's\n * rendered output using the {@link ITextmodeLayer.filter} method.\n *\n * The base layer, which is always present at the bottom of the layer stack,\n * can be accessed via {@link Textmodifier.baseLayer}.\n */\nexport interface ITextmodeLayer {\n    /**\n     * Returns the WebGL texture of the final ASCII framebuffer.\n     * If the layer is not yet initialized, returns undefined.\n     */\n    readonly texture: WebGLTexture | undefined;\n    /**\n     * Get the grid associated with this layer.\n     */\n    readonly grid: TextmodeGrid | undefined;\n    /**\n     * Returns the width of the final ASCII framebuffer in pixels.\n     * If the layer is not yet initialized, returns 0.\n     */\n    readonly width: number;\n    /**\n     * Returns the height of the final ASCII framebuffer in pixels.\n     * If the layer is not yet initialized, returns 0.\n     */\n    readonly height: number;\n    /**\n     * Returns the draw framebuffer for this layer.\n     * If the layer is not yet initialized, returns undefined.\n     */\n    readonly drawFramebuffer: GLFramebuffer | undefined;\n    /**\n     * Get the framebuffer containing the rendered textmode output for this layer.\n     */\n    readonly asciiFramebuffer: GLFramebuffer | undefined;\n    /**\n     * The font used by this layer.\n     */\n    readonly font: TextmodeFont;\n    /**\n     * Define this layer's draw callback. The callback is executed each frame\n     * and should contain all drawing commands for this layer.\n     *\n     * Inside the callback, use `t` (your `Textmodifier` instance) to access drawing\n     * methods like `char()`, `charColor()`, `translate()`, and `rect()`.\n     *\n     * @param callback The function to call when drawing this layer.\n     *\n     * \n     */\n    draw(callback: () => void): void;\n    /**\n     * Store plugin-specific state on this layer.\n     * Plugins can use this to attach their own data to layer instances.\n     *\n     * @param pluginName Unique identifier for the plugin.\n     * @param state The state object to store.\n     */\n    setPluginState<T>(pluginName: string, state: T): void;\n    /**\n     * Retrieve plugin-specific state stored on this layer.\n     *\n     * @param pluginName Unique identifier for the plugin.\n     * @returns The stored state object, or undefined if not set.\n     */\n    getPluginState<T>(pluginName: string): T | undefined;\n    /** Check if plugin-specific state exists on this layer.\n     *\n     * @param pluginName Unique identifier for the plugin.\n     * @returns True if state exists, false otherwise.\n     */\n    hasPluginState(pluginName: string): boolean;\n    /** Delete plugin-specific state from this layer.\n     *\n     * @param pluginName Unique identifier for the plugin.\n     */\n    deletePluginState(pluginName: string): void;\n    /** Get or set the font size for this layer. */\n    fontSize(size?: number): number | void;\n    /**\n     * Load a font into this layer from a URL/path or reuse an existing {@link TextmodeFont} instance.\n     * Creates a new font instance for this layer and loads the font data when a string source is provided.\n     *\n     * @param fontSource The URL or path to the font file.\n     * @returns The loaded TextmodeFont instance.\n     *\n     * \n     */\n    loadFont(fontSource: string | TextmodeFont): Promise<TextmodeFont>;\n    /**\n     * Show this layer for rendering.\n     */\n    show(): void;\n    /**\n     * Hide this layer from rendering.\n     */\n    hide(): void;\n    /**\n     * Define or retrieve the layer's opacity.\n     * @param opacity The opacity value to set (between 0 and 1).\n     * @returns The current opacity if no parameter is provided.\n     */\n    opacity(opacity?: number): number | void;\n    /**\n     * Set or get the layer's blend mode for compositing with layers below.\n     *\n     * @param mode The blend mode to set.\n     * @returns The current blend mode if no parameter is provided.\n     *\n     * **Available blend modes:**\n     * - `'normal'` - Standard alpha compositing\n     * - `'additive'` - Adds colors together (great for glow/energy effects)\n     * - `'multiply'` - Darkens by multiplying colors\n     * - `'screen'` - Lightens; inverse of multiply\n     * - `'subtract'` - Subtracts layer from base\n     * - `'darken'` - Takes minimum of each channel\n     * - `'lighten'` - Takes maximum of each channel\n     * - `'overlay'` - Combines multiply/screen for contrast\n     * - `'softLight'` - Subtle contrast enhancement\n     * - `'hardLight'` - Intense overlay effect\n     * - `'colorDodge'` - Brightens base by blend color\n     * - `'colorBurn'` - Darkens base by blend color\n     * - `'difference'` - Absolute difference; creates inverted effects\n     * - `'exclusion'` - Softer difference effect\n     *\n     * \n     */\n    blendMode(mode: TextmodeLayerBlendMode): TextmodeLayerBlendMode | void;\n    /**\n     * Set or get the layer's offset in pixels.\n     * @param x The x offset in pixels.\n     * @param y The y offset in pixels.\n     * @returns The current offset if no parameters are provided.\n     *\n     * \n     */\n    offset(x?: number, y?: number): {\n        x: number;\n        y: number;\n    } | void;\n    /**\n     * Set or get the layer's rotation in degrees around its center.\n     *\n     * The rotation is applied during compositing around the center of the layer's\n     * rectangular bounds. The rotation origin remains at the center even when\n     * an offset is applied.\n     *\n     * @param z The rotation angle in degrees. Positive values rotate clockwise.\n     * @returns The current rotation in degrees if no parameter is provided.\n     *\n     * \n     */\n    rotateZ(z?: number): number | void;\n    /**\n     * Apply a post-processing filter to this layer's rendered output.\n     *\n     * Filters are applied after ASCII conversion in the order they are called.\n     * Call this method within your layer's draw callback to apply effects.\n     *\n     * **Built-in filters:**\n     * - `'invert'` - Inverts all colors\n     * - `'grayscale'` - Converts to grayscale (param: amount 0-1, default 1)\n     * - `'sepia'` - Applies sepia tone (param: amount 0-1, default 1)\n     * - `'threshold'` - Black/white threshold (param: threshold 0-1, default 0.5)\n     *\n     * @param name The name of the filter to apply (built-in or custom registered filter)\n     * @param params Optional parameters for the filter\n     *\n     * \n     */\n    filter<T extends BuiltInFilterName>(name: FilterName, params?: BuiltInFilterParams[T]): void;\n    /**\n     * Apply a custom filter registered via `t.layers.filters.register()`.\n     * @param name The name of the custom filter\n     * @param params Optional parameters for the custom filter\n     */\n    filter(name: FilterName, params?: unknown): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/layers/Layer2DCompositor.d.ts": "import type { GLRenderer, GLFramebuffer } from '../../rendering';\nimport type { TextmodeLayer } from './TextmodeLayer';\n/**\n * Parameters for the composite operation.\n */\nexport interface CompositeParams {\n    /** The base layer placement (texture + size + offset). */\n    base: CompositeLayerPlacement;\n    /** The array of user layer placements to composite on top of the base. */\n    layers: readonly CompositeLayerPlacement[];\n    /** The target framebuffer to render the final result into. */\n    targetFramebuffer: GLFramebuffer;\n    /** The background color as RGBA values (0-1 range). */\n    backgroundColor: [number, number, number, number];\n    /** Canvas width in pixels. */\n    canvasWidth: number;\n    /** Canvas height in pixels. */\n    canvasHeight: number;\n}\nexport interface CompositeLayerPlacement {\n    layer: TextmodeLayer;\n    texture: WebGLTexture;\n    width: number;\n    height: number;\n    offsetX: number;\n    offsetY: number;\n}\n/**\n * Handles the compositing of multiple layers using shader-based blending.\n *\n * This class is responsible for:\n * - Managing ping-pong framebuffers for layer compositing\n * - Applying blend modes via the composite shader\n * - Rendering the final composited result to a target framebuffer\n *\n * @ignore\n *\n * @remarks\n * The compositor uses a ping-pong buffer technique to avoid WebGL feedback loops\n * when reading from and writing to textures during blend operations.\n */\nexport declare class Layer2DCompositor {\n    private readonly _renderer;\n    private readonly _blendShader;\n    private _pingPongBuffers;\n    private _currentPingPongIndex;\n    /**\n     * Create a new LayerCompositor.\n     * @param renderer The WebGL renderer instance.\n     * @param canvasWidth The canvas width in pixels.\n     * @param canvasHeight The canvas height in pixels.\n     */\n    constructor(renderer: GLRenderer, canvasWidth: number, canvasHeight: number);\n    /**\n     * Composite all layers onto the target framebuffer.\n     * @param params The composite parameters.\n     */\n    $composite(params: CompositeParams): void;\n    /**\n     * Blend a single layer onto the current composite.\n     */\n    private _blendLayer;\n    /**\n     * Copy the final composite result to the target framebuffer.\n     */\n    private _copyToTarget;\n    /**\n     * Resize the compositor's framebuffers.\n     * @param canvasWidth The canvas width in pixels.\n     * @param canvasHeight The canvas height in pixels.\n     * @ignore\n     */\n    $resize(canvasWidth: number, canvasHeight: number): void;\n    /**\n     * Dispose of all compositor resources.\n     * @ignore\n     */\n    $dispose(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/layers/LayerManager.d.ts": "import type { GLFramebuffer } from '../../rendering';\nimport type { Textmodifier } from '../Textmodifier';\nimport { TextmodeLayer } from './TextmodeLayer';\nimport type { TextmodeLayerOptions } from './types';\nimport type { ILayerManager } from './interfaces/ILayerManager';\nimport type { TextmodeOptions } from '../types';\nimport type { TextmodeGrid } from '../Grid';\nimport { type FilterName, type BuiltInFilterName, type BuiltInFilterParams, TextmodeFilterManager } from '../filters';\n/**\n * Manages all user-defined layers within a Textmodifier in addition to the base layer.\n *\n * Responsibilities:\n * - Managing the collection of user layers (add, remove, move, swap)\n * - Coordinating layer rendering and compositing\n * - Owning the global post-processing pipeline (global filters + present to screen)\n *\n * The instance of this class can be accessed via {@link Textmodifier.layers}.\n *\n * The {@link base} layer is not part of the public layer stack, but is instead managed internally.\n */\nexport declare class LayerManager implements ILayerManager {\n    private readonly _textmodifier;\n    private readonly _renderer;\n    private readonly _compositor2D;\n    private readonly _filterManager;\n    private readonly _textmodeConversionShader;\n    private readonly _presentShader;\n    private readonly _layers;\n    private readonly _baseLayer;\n    private _isReady;\n    private readonly _gridDimensionChangeCallbacks;\n    private _globalFilterQueue;\n    private _preFilterFramebuffer;\n    private _postFilterFramebuffer;\n    /**\n     * Create a new LayerManager.\n     * @param textmodifier The Textmodifier instance this manager belongs to.\n     * @ignore\n     */\n    constructor(textmodifier: Textmodifier, opts: TextmodeOptions);\n    /**\n     * Initialize all pending layers, compositor, and global post-processing resources.\n     * @ignore\n     */\n    $initialize(): Promise<void>;\n    /**\n     * Queue a global filter to be applied after all layers are composited.\n     * Intended to be called by Textmodifier.filter().\n     * @ignore\n     */\n    $queueGlobalFilter<T extends BuiltInFilterName>(name: T, params?: BuiltInFilterParams[T]): void;\n    $queueGlobalFilter(name: FilterName, params?: unknown): void;\n    /**\n     * Clear any queued global filters for the current frame.\n     * @ignore\n     */\n    $clearGlobalFilterQueue(): void;\n    add(options?: TextmodeLayerOptions): TextmodeLayer;\n    remove(layer: TextmodeLayer): void;\n    move(layer: TextmodeLayer, newIndex: number): void;\n    swap(layerA: TextmodeLayer, layerB: TextmodeLayer): void;\n    /**\n     * Remove and dispose all user layers (keeps base layer intact).\n     */\n    clear(): void;\n    /**\n     * Render all layers (base and user) and composite them to the provided target framebuffer.\n     * This performs ONLY layer rendering + compositing (no global filters, no present).\n     *\n     * @param targetFramebuffer The framebuffer to render the final composited result to.\n     * @ignore\n     */\n    $renderAndComposite(targetFramebuffer: GLFramebuffer): void;\n    /**\n     * Render, composite, apply global filters, present to screen, run post-draw hooks.\n     * This replaces the removed \"Pass 3/4 + post hooks\" section from Textmodifier.$render().\n     *\n     * @param fallbackBaseDraw Fallback draw callback for the base layer if it has no own draw callback.\n     * @ignore\n     */\n    $renderAndPresent(): void;\n    /**\n     * Composite base + user layers onto the target framebuffer.\n     */\n    private _compositeLayers;\n    /**\n     * Resize all layers, compositor, and global post-processing buffers.\n     * @ignore\n     */\n    $resize(): void;\n    /**\n     * Dispose of the layer manager, all layers, compositor, and global post-processing resources.\n     * @ignore\n     */\n    $dispose(): void;\n    get all(): readonly TextmodeLayer[];\n    get base(): TextmodeLayer;\n    get filters(): TextmodeFilterManager;\n    get resultFramebuffer(): GLFramebuffer;\n    /**\n     * Get the grid of the topmost visible layer.\n     * Returns the topmost user layer's grid if any are visible, otherwise returns the base layer's grid.\n     * This is useful for input managers that need to map coordinates to the layer the user sees on top.\n     * @ignore\n     */\n    $getTopmostGrid(): TextmodeGrid | undefined;\n    /**\n     * Register a callback to be invoked whenever ANY layer's grid dimensions change.\n     * This includes the base layer and all user layers.\n     * @param callback The callback to invoke on dimension changes.\n     * @ignore\n     */\n    $onAnyGridDimensionChange(callback: () => void): void;\n    /**\n     * Notify all registered callbacks that a grid's dimensions have changed.\n     */\n    private _notifyGridDimensionChange;\n    /**\n     * Initialize a single layer with required dependencies.\n     */\n    private _initializeLayer;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/layers/TextmodeLayer.d.ts": "import type { GLFramebuffer, GLRenderer, GLShader } from '../../rendering';\nimport { TextmodeGrid } from '../Grid';\nimport { TextmodeFont } from '../loadables/font';\nimport { Textmodifier } from '../Textmodifier';\nimport type { TextmodeLayerBlendMode, TextmodeLayerOptions, LayerDependencies } from './types';\nimport type { FilterName, BuiltInFilterName, BuiltInFilterParams } from '../filters';\nimport type { ITextmodeLayer } from './interfaces/ITextmodeLayer';\n/**\n * A single layer within a multi-layered textmode rendering context.\n *\n * Layers are composited together using various blend modes\n * to create complex visual effects. Each layer can be independently\n * manipulated in terms of visibility, {@link opacity}, {@link blendMode}, {@link offset}, rotation, {@link TextmodeGrid}, and {@link TextmodeFont}.\n *\n * You can draw on each layer by providing a draw callback function,\n * like you would with the base layer's {@link Textmodifier.draw} method.\n *\n * Plugins can extend TextmodeLayer with additional methods using the plugin API's\n * `extendLayer` function. For example, the `textmode-synth` plugin adds a `.synth()`\n * method for hydra-like procedural generation.\n */\nexport declare class TextmodeLayer implements ITextmodeLayer {\n    /** @ignore */\n    $visible: boolean;\n    /** @ignore */\n    $opacity: number;\n    /** @ignore */\n    $blendMode: TextmodeLayerBlendMode;\n    /** @ignore */\n    $offsetX: number;\n    /** @ignore */\n    $offsetY: number;\n    /** @ignore */\n    $rotation: number;\n    /** @ignore */\n    $fontSize: number | undefined;\n    /** @ignore */\n    $fontSource: string | TextmodeFont | URL | undefined;\n    private _deps?;\n    private _grid?;\n    private _font;\n    private _drawFramebuffer;\n    private _asciiFramebuffer;\n    private _rawAsciiFramebuffer?;\n    private _pingPongBuffers?;\n    private _drawCallback;\n    private _filterQueue;\n    private _pluginState;\n    /**\n     * Create a new TextmodeLayer with the given options.\n     * @param options Layer configuration options.\n     * @ignore\n     */\n    constructor(renderer: GLRenderer, options?: TextmodeLayerOptions);\n    /**\n     * Attach necessary dependencies for this layer to function.\n     * @param deps Dependencies required by the layer.\n     * @ignore\n     */\n    $attachDependencies(deps: LayerDependencies): Promise<void>;\n    draw(callback: () => void): void;\n    show(): void;\n    hide(): void;\n    opacity(opacity?: number): number | void;\n    blendMode(mode: TextmodeLayerBlendMode): TextmodeLayerBlendMode | void;\n    offset(x?: number, y?: number): {\n        x: number;\n        y: number;\n    } | void;\n    rotateZ(z?: number): number | void;\n    filter<T extends BuiltInFilterName>(name: T, params?: BuiltInFilterParams[T]): void;\n    filter(name: FilterName, params?: unknown): void;\n    setPluginState<T>(pluginName: string, state: T): void;\n    getPluginState<T>(pluginName: string): T | undefined;\n    hasPluginState(pluginName: string): boolean;\n    deletePluginState(pluginName: string): boolean;\n    fontSize(size?: number): void;\n    loadFont(fontSource: string | TextmodeFont): Promise<TextmodeFont>;\n    /**\n     * Render the layer's content into its ASCII framebuffer.\n     * @param textmodifier The Textmodifier instance.\n     * @param conversionShader The shader used for conversion.\n     * @ignore\n     */\n    $render(textmodifier: Textmodifier, conversionShader: GLShader): void;\n    /**\n     * Resize the layer's framebuffers to match the given grid dimensions.\n     * @param grid The TextmodeGrid instance.\n     * @ignore\n     */\n    $resize(): void;\n    /**\n     * Dispose of the layer's resources.\n     * @ignore\n     */\n    $dispose(): void;\n    get texture(): WebGLTexture | undefined;\n    get grid(): TextmodeGrid | undefined;\n    get font(): TextmodeFont;\n    get width(): number;\n    get height(): number;\n    get drawFramebuffer(): GLFramebuffer | undefined;\n    get asciiFramebuffer(): GLFramebuffer | undefined;\n    private _syncGridToFont;\n\n    // Injected from textmode.synth.js\n    /**\n             * Set a synth source for this layer.\n             *\n             * The synth will render procedurally generated characters and colors\n             * directly to the layer's draw framebuffer before the draw callback runs.\n             *\n             * @param source A SynthSource chain defining the procedural generation\n             */\n            synth(source: SynthSource): void;\n            /**\n             * Clear the synth from this layer.\n             *\n             * This disposes all synth-related resources including the compiled shader\n             * and any ping-pong framebuffers used for feedback effects. After calling\n             * this method, the layer will no longer render synth content.\n             *\n             * Use this to reset a layer's synth state without removing the layer itself.\n             */\n            clearSynth(): void;\n            /**\n             * Set layer-specific BPM override for array modulation timing.\n             *\n             * This overrides the global BPM set by `t.bpm()` for this specific layer,\n             * allowing polyrhythmic compositions where different layers cycle at\n             * different speeds.\n             *\n             * @param value BPM value (beats per minute) for this layer\n             */\n            bpm(value: number): void;\n            /**\n             * Get the unique identifier for this layer.\n             *\n             * @returns The layer's unique identifier\n             */\n            get id(): string;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/layers/types.d.ts": "import type { GLFramebuffer } from '../../rendering';\nimport type { GLRenderer } from '../../rendering/webgl/core/Renderer';\nimport type { TextmodeFilterManager } from '../filters';\nimport type { TextmodeCanvas } from '../Canvas';\nimport type { TextmodeFont } from '../loadables';\n/**\n * Blend modes available for {@link TextmodeLayer} compositing in 2D mode.\n *\n * - `'normal'`: Standard alpha compositing. Opaque layer pixels fully replace the base; translucent pixels fade in.\n * - `'additive'`: Layer color is added on top of the base. Great for glow/energy effects but will clip as values approach white.\n * - `'multiply'`: `result = layer * base`. Darkens wherever both layers have color; any channel multiplied by 0 becomes 0.\n * - `'screen'`: Inverse of multiply. `result = 1 - (1 - layer) * (1 - base)`. Preserves highlights while lightening midtones.\n * - `'subtract'`: `result = base - layer`. Useful for cutting out or darkening effects.\n * - `'darken'`: Takes the minimum of layer and base per channel. Only darkens; never lightens.\n * - `'lighten'`: Takes the maximum of layer and base per channel. Only lightens; never darkens.\n * - `'overlay'`: Combines multiply and screen. Darkens darks and lightens lights, increasing contrast.\n * - `'softLight'`: Softer version of overlay. Subtle contrast enhancement.\n * - `'hardLight'`: Like overlay but more intense. Uses blend color to determine multiply/screen.\n * - `'colorDodge'`: Brightens the base by the blend color. Creates intense highlights.\n * - `'colorBurn'`: Darkens the base by the blend color. Creates deep shadows.\n * - `'difference'`: `result = |base - blend|`. Creates inverted/solarized effects.\n * - `'exclusion'`: Softer version of difference. `result = base + blend - 2 * base * blend`.\n */\nexport type TextmodeLayerBlendMode = 'normal' | 'additive' | 'multiply' | 'screen' | 'subtract' | 'darken' | 'lighten' | 'overlay' | 'softLight' | 'hardLight' | 'colorDodge' | 'colorBurn' | 'difference' | 'exclusion';\n/**\n * Options for configuring a new TextmodeLayer via {@link TextmodeLayerManager.add}.\n */\nexport interface TextmodeLayerOptions {\n    /**\n     * Whether the layer is visible. Default is `true`.\n     */\n    visible?: boolean;\n    /**\n     * The opacity of the layer, between 0 (fully transparent) and 1 (fully opaque). Default is `1`.\n     */\n    opacity?: number;\n    /**\n     * The blend mode used when rendering this layer. Default is `'normal'`.\n     */\n    blendMode?: TextmodeLayerBlendMode;\n    /**\n     * The horizontal offset of the layer in pixels. Default is `0`.\n     */\n    offsetX?: number;\n    /**\n     * The vertical offset of the layer in pixels. Default is `0`.\n     */\n    offsetY?: number;\n    /**\n     * The z-rotation of the layer in degrees around its center. Default is `0`.\n     */\n    rotationZ?: number;\n    /**\n     * The font size for the layer's text. Default is `16`.\n     */\n    fontSize?: number;\n    /**\n     * Source for the font to use in this layer.\n     *\n     * Can be a URL/path to a font file, or an existing TextmodeFont instance.\n     */\n    fontSource?: string | TextmodeFont;\n}\n/**\n * Dependencies required by a TextmodeLayer to function.\n * @internal\n */\nexport interface LayerDependencies {\n    renderer: GLRenderer;\n    canvas: TextmodeCanvas;\n    createFramebuffer: (width: number, height: number, attachments?: number, options?: {\n        depth?: boolean;\n    }) => GLFramebuffer;\n    /**\n     * The shared filter manager for applying post-ASCII filters.\n     */\n    filterManager: TextmodeFilterManager;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/CharacterColorMapper.d.ts": "import type { TextmodeCharacter } from './types.ts';\nimport type { TyprFont } from './typr/types.ts';\n/**\n * Handles color generation and mapping for characters.\n * This class manages the unique RGB color assignment for character identification.\n */\nexport declare class CharacterColorMapper {\n    private _fontTableReader;\n    constructor();\n    /**\n     * Creates TextmodeCharacter objects with unique color assignments.\n     * Returns both an array (for public API and iteration) and a Map (for O(1) lookups).\n     * @param characters Array of character strings\n     * @param font The parsed font object from Typr\n     * @returns Object containing both array and map of TextmodeCharacter objects\n     */\n    $createCharacterObjects(characters: string[], font: TyprFont): {\n        array: TextmodeCharacter[];\n        map: Map<string, TextmodeCharacter>;\n    };\n    /**\n     * Generates a unique RGB color for a character based on its index.\n     * @param index The index of the character\n     * @returns RGB color as a tuple [r, g, 0] with values from 0-1 for shader use\n     */\n    private _generateCharacterColor;\n    /**\n     * Gets glyph data for a character including advance width and path information.\n     * @param font The parsed font object from Typr\n     * @param character Character to get glyph data for\n     * @returns Parsed glyph data with advance width, or null if not found\n     */\n    private _getGlyphData;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/CharacterExtractor.d.ts": "import type { TyprFont } from './typr/types.ts';\n/**\n * Handles extraction of characters from font cmap tables.\n * This class encapsulates the complex logic for reading different cmap table formats.\n */\nexport declare class CharacterExtractor {\n    /**\n     * Extracts all available characters from a font's cmap tables.\n     * @param font The parsed font object from Typr\n     * @returns Array of unique character strings\n     */\n    $extractCharacters(font: TyprFont): string[];\n    /**\n     * Extracts characters from a Format 4 cmap table (Basic Multilingual Plane).\n     */\n    private _extractCharactersFromFormat4;\n    /**\n     * Extracts characters from a Format 12 cmap table (Extended Unicode ranges).\n     */\n    private _extractCharactersFromFormat12;\n    /**\n     * Calculates the glyph index for a character in a Format 4 cmap table.\n     */\n    private _calculateGlyphIndexFormat4;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/index.d.ts": "export { TextmodeFont } from './TextmodeFont.ts';\nexport type { TextmodeCharacter, GlyphDimensions } from './types.ts';\nexport type { TyprFont, CmapTable, CmapTableFormat4, CmapTableFormat12, HeadTable, HheaTable, HmtxTable, MaxpTable, CmapData, GlyphData, LocaTable, TyprStatic, } from './typr/types.ts';\nexport { default as Typr } from './typr/Typr.ts';\nexport { CharacterExtractor } from './CharacterExtractor.ts';\nexport { TextureAtlas as TextureAtlasCreation } from './TextureAtlas.ts';\nexport { FontMetricsCalculator as MetricsCalculation } from './MetricsCalculator.ts';\nexport { CharacterColorMapper as CharacterColorMapping } from './CharacterColorMapper.ts';",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/MetricsCalculator.d.ts": "import type { GlyphDimensions } from './types.ts';\nimport type { TyprFont } from './typr/types.ts';\n/**\n * Handles calculation of font metrics and glyph dimensions.\n * This class encapsulates the logic for measuring text and calculating font properties\n * directly from font data using Typr.ts, eliminating the need for Canvas-based measurement.\n */\nexport declare class FontMetricsCalculator {\n    private _tableReader;\n    /**\n     * Creates a new FontMetricsCalculator instance.\n     */\n    constructor();\n    /**\n     * Calculates the maximum glyph dimensions for a given set of characters\n     * using direct font metrics from the parsed font data.\n     * @param characters Array of character strings\n     * @param fontSize Font size to use for scaling measurements\n     * @param font Parsed TyprFont object containing font data\n     * @returns Object containing width and height dimensions\n     */\n    $calculateMaxGlyphDimensions(characters: string[], fontSize: number, font: TyprFont): GlyphDimensions;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/TextmodeFont.d.ts": "import type { GLRenderer } from '../../../rendering/webgl/core/Renderer.ts';\nimport type { GLFramebuffer } from '../../../rendering/webgl/core/Framebuffer.ts';\nimport type { TextmodeCharacter } from './types.ts';\nimport type { TyprFont } from './typr/types.ts';\n/**\n * Manages the font used for rendering characters via {@link TextmodeLayer.loadFont}.\n *\n * This class coordinates font loading, character extraction, texture atlas creation,\n * and provides character information.\n *\n * Each {@link TextmodeLayer} has its own instance of this class to allow for\n * layer-specific font configurations.\n */\nexport declare class TextmodeFont {\n    private _font;\n    private _characters;\n    private _characterMap;\n    private _fontFramebuffer;\n    private _fontSize;\n    private _textureColumns;\n    private _textureRows;\n    private _maxGlyphDimensions;\n    private _fontFace;\n    private _characterExtractor;\n    private _textureAtlas;\n    private _metricsCalculator;\n    private _characterColorMapper;\n    private _isInitialized;\n    /**\n     * Creates a new TextmodeFont instance.\n     * @param renderer Renderer instance for texture creation\n     * @param fontSize Font size to use for the texture atlas\n     * @ignore\n     */\n    constructor(renderer: GLRenderer, fontSize?: number);\n    /**\n     * Initializes the font manager by loading the font and creating the texture atlas.\n     * @param fontSource Optional URL to load a custom font. If not provided, uses embedded font (full builds only).\n     * @returns Promise that resolves when initialization is complete\n     * @ignore\n     */\n    $initialize(fontSource?: string | URL): Promise<void>;\n    /**\n     * Sets the font size for rendering.\n     * @param size The font size to set. If undefined, returns the current font size.\n     * @ignore\n     */\n    $setFontSize(size: number | undefined): void | number;\n    /**\n     * Loads a new font from a file path.\n     * @param fontPath Path to the .otf or .ttf font file\n     * @returns Promise that resolves when font loading is complete\n     * @ignore\n     */\n    $loadFont(fontPath: string): Promise<void>;\n    /**\n     * Loads a FontFace from a font buffer.\n     * @param fontBuffer ArrayBuffer containing font data\n     */\n    private _loadFontFace;\n    /**\n     * Initializes all font-dependent properties using the component classes.\n     */\n    private _initializeFont;\n    /**\n     * Get the color associated with a character using O(1) Map lookup.\n     * @param character The character to get the color for.\n     * @returns The RGB color as an array `[r, g, b]`.\n     * @ignore\n     */\n    $getCharacterColor(character: string): [number, number, number];\n    /**\n     * Get the colors associated with a string of characters using O(1) Map lookups.\n     * @param characters The string of characters to get colors for.\n     * @returns An array of RGB colors for each character in the string.\n     * Each color is represented as an array `[r, g, b]`.\n     * @ignore\n     */\n    $getCharacterColors(characters: string): [number, number, number][];\n    /**\n     * Dispose of all resources used by this font manager.\n     * @ignore\n     */\n    $dispose(): void;\n    /** Returns whether this font has been initialized. @ignore */\n    get $isInitialized(): boolean;\n    /** Returns the WebGL framebuffer containing the font texture atlas. */\n    get fontFramebuffer(): GLFramebuffer;\n    /** Returns the character map for O(1) lookups. */\n    get characterMap(): Map<string, TextmodeCharacter>;\n    /** Returns the array of {@link TextmodeCharacter} objects in the font. */\n    get characters(): TextmodeCharacter[];\n    /** Returns the number of columns in the texture atlas. */\n    get textureColumns(): number;\n    /** Returns the number of rows in the texture atlas. */\n    get textureRows(): number;\n    /** Returns the maximum dimensions of a glyph in the font. */\n    get maxGlyphDimensions(): {\n        width: number;\n        height: number;\n    };\n    /** Returns the font size used for rendering. */\n    get fontSize(): number;\n    /** Returns the Typr.js font object. @ignore */\n    get font(): TyprFont;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/TextureAtlas.d.ts": "import type { TextmodeCharacter, GlyphDimensions } from './types.ts';\nimport type { GLRenderer } from '../../../rendering/webgl/core/Renderer.ts';\nimport type { GLFramebuffer } from '../../../rendering/webgl/core/Framebuffer.ts';\nimport type { TyprFont } from './typr/types.ts';\n/**\n * Handles creation of texture atlases for font rendering.\n * This class manages the Canvas 2D rendering and WebGL framebuffer creation.\n * Supports both Typr.js path-based rendering for uniform cross-browser text\n * and fallback fillText rendering.\n */\nexport declare class TextureAtlas {\n    private _textureCanvas;\n    private _textureContext;\n    private _renderer;\n    /**\n     * Creates a new TextureAtlasCreation instance.\n     * @param renderer The WebGL renderer instance\n     */\n    constructor(renderer: GLRenderer);\n    /**\n     * Creates a texture atlas from the given characters.\n     * @param characters Array of TextmodeCharacter objects\n     * @param maxGlyphDimensions Maximum dimensions of glyphs\n     * @param fontSize Font size for rendering\n     * @param font Either Typr.js font data object for path rendering, or font family name string for fillText rendering\n     * @returns Object containing framebuffer, columns, and rows\n     */\n    $createTextureAtlas(characters: TextmodeCharacter[], maxGlyphDimensions: GlyphDimensions, fontSize: number, font: TyprFont): {\n        framebuffer: GLFramebuffer;\n        columns: number;\n        rows: number;\n    };\n    /**\n     * Sets up the canvas for rendering.\n     * @param width Canvas buffer width\n     * @param height Canvas buffer height\n     */\n    private _setupCanvas;\n    /**\n     * Renders all characters to the canvas in a grid layout using Typr.js paths.\n     * @param characters Array of characters to render\n     * @param maxGlyphDimensions Maximum glyph dimensions\n     * @param textureColumns Number of columns in the texture\n     * @param fontSize Font size\n     * @param fontData Typr.js font data\n     */\n    private _renderCharacters;\n    /**\n     * Renders a glyph to the canvas using direct path rendering from glyph outline data.\n     * @param glyphData Glyph data from Typr.js\n     * @param x X position\n     * @param y Y position (baseline position)\n     * @param scale Scale factor\n     */\n    private _renderGlyphToCanvas;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/types.d.ts": "/**\n * Glyph outline data for a character\n */\nexport type GlyphData = {\n    /** Number of contours (-1 for composite glyphs) */\n    noc: number;\n    /** Bounding box coordinates */\n    xMin: number;\n    yMin: number;\n    xMax: number;\n    yMax: number;\n    /** End points of each contour */\n    endPts: number[];\n    /** Point flags indicating curve/line segments */\n    flags: number[];\n    /** X coordinates of all points */\n    xs: number[];\n    /** Y coordinates of all points */\n    ys: number[];\n    /** Advance width of the character */\n    advanceWidth: number;\n    /** Composite glyph parts (for composite glyphs) */\n    parts?: any[];\n} | null;\n/**\n * Represents a single character in the {@link TextmodeFont.characters} array.\n */\nexport type TextmodeCharacter = {\n    /** The character itself. */\n    character: string;\n    /** The Unicode code point of the character. */\n    unicode: number;\n    /** The shader color associated with the character. */\n    color: [number, number, number];\n    /** Glyph outline data including advance width and path information. */\n    glyphData: GlyphData;\n};\n/**\n * Font glyph dimensions\n */\nexport interface GlyphDimensions {\n    width: number;\n    height: number;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/typr/types.d.ts": "/**\n * Type definitions for Typr.js - Font parsing library\n *\n * Comprehensive TypeScript types for all Typr font parsing structures,\n * tables, and interfaces used throughout the font processing pipeline.\n */\n/**\n * Binary reading utilities interface\n */\nexport interface TyprBinary {\n    /** Read signed 16-bit integer */\n    readShort: (buff: Uint8Array, p: number) => number;\n    /** Read unsigned 16-bit integer */\n    readUshort: (buff: Uint8Array, p: number) => number;\n    /** Read array of unsigned 16-bit integers */\n    readUshorts: (buff: Uint8Array, p: number, len: number) => number[];\n    /** Read unsigned 32-bit integer */\n    readUint: (buff: Uint8Array, p: number) => number;\n    /** Read ASCII string */\n    readASCII: (buff: Uint8Array, p: number, l: number) => string;\n    /** Shared typed array buffers for efficient reading */\n    t: {\n        uint8: Uint8Array;\n        int16: Int16Array;\n        uint16: Uint16Array;\n        uint32: Uint32Array;\n    };\n}\n/**\n * Interface for cmap table Format 4 (Basic Multilingual Plane)\n * Used for Unicode BMP character mapping\n */\nexport interface CmapTableFormat4 {\n    format: 4;\n    searchRange: number;\n    entrySelector: number;\n    rangeShift: number;\n    startCount: number[];\n    endCount: number[];\n    idRangeOffset: number[];\n    idDelta: number[];\n    glyphIdArray: number[];\n}\n/**\n * Interface for cmap table Format 12 (Extended Unicode ranges)\n * Used for full Unicode character mapping including supplementary planes\n */\nexport interface CmapTableFormat12 {\n    format: 12;\n    groups: Uint32Array;\n}\n/**\n * Union type for supported cmap table formats\n */\nexport type CmapTable = CmapTableFormat4 | CmapTableFormat12 | {\n    format: number;\n};\n/**\n * Character map data from OpenType/TrueType font\n * Contains multiple encoding tables and platform-specific mappings\n */\nexport interface CmapData {\n    /** Array of character mapping tables */\n    tables: CmapTable[];\n    /** Platform+encoding ID mappings to table indices */\n    ids: Record<string, number>;\n    /** Offset of cmap table in font data */\n    off: number;\n}\n/**\n * Head table from OpenType/TrueType font\n * Contains global font metrics and metadata\n */\nexport interface HeadTable {\n    /** Units per EM square */\n    unitsPerEm: number;\n    /** Minimum x coordinate across all glyphs */\n    xMin: number;\n    /** Minimum y coordinate across all glyphs */\n    yMin: number;\n    /** Maximum x coordinate across all glyphs */\n    xMax: number;\n    /** Maximum y coordinate across all glyphs */\n    yMax: number;\n    /** Format of location table (0 = short, 1 = long) */\n    indexToLocFormat: number;\n}\n/**\n * Horizontal header table from OpenType/TrueType font\n * Contains horizontal layout metrics\n */\nexport interface HheaTable {\n    /** Typographic ascender */\n    ascender: number;\n    /** Typographic descender */\n    descender: number;\n    /** Typographic line gap */\n    lineGap: number;\n    /** Maximum advance width */\n    advanceWidthMax: number;\n    /** Minimum left side bearing */\n    minLeftSideBearing: number;\n    /** Minimum right side bearing */\n    minRightSideBearing: number;\n    /** Maximum extent */\n    xMaxExtent: number;\n    /** Caret slope rise */\n    caretSlopeRise: number;\n    /** Caret slope run */\n    caretSlopeRun: number;\n    /** Caret offset */\n    caretOffset: number;\n    /** Reserved fields */\n    res0: number;\n    res1: number;\n    res2: number;\n    res3: number;\n    /** Metric data format */\n    metricDataFormat: number;\n    /** Number of horizontal metrics */\n    numberOfHMetrics: number;\n}\n/**\n * Horizontal metrics table from OpenType/TrueType font\n * Contains advance widths and left side bearings for all glyphs\n */\nexport interface HmtxTable {\n    /** Array of advance widths for each glyph */\n    aWidth: number[];\n    /** Array of left side bearings for each glyph */\n    lsBearing: number[];\n}\n/**\n * Maximum profile table from OpenType/TrueType font\n * Contains the number of glyphs and other maximums\n */\nexport interface MaxpTable {\n    /** Total number of glyphs in the font */\n    numGlyphs: number;\n}\n/**\n * Location table for glyph offsets\n * Maps glyph indices to their byte offsets in the glyf table\n */\nexport type LocaTable = number[];\n/**\n * Glyph data structure for parsed glyphs\n * Contains the actual glyph outline data\n */\nexport interface GlyphData {\n    /** Number of contours (-1 for composite glyphs) */\n    noc: number;\n    /** Bounding box coordinates */\n    xMin: number;\n    yMin: number;\n    xMax: number;\n    yMax: number;\n    /** End points of each contour */\n    endPts: number[];\n    /** Point flags indicating curve/line segments */\n    flags: number[];\n    /** X coordinates of all points */\n    xs: number[];\n    /** Y coordinates of all points */\n    ys: number[];\n    /** Composite glyph parts (for composite glyphs) */\n    parts?: any[];\n}\n/**\n * Font table parser interface\n * Each table parser implements this interface\n */\nexport interface TableParser<T = any> {\n    parseTab: (data: Uint8Array, offset: number, length: number, font: TyprFont) => T;\n}\n/**\n * Extended cmap parser with format-specific methods\n */\nexport interface CmapParser extends TableParser<CmapData> {\n    parse4: (data: Uint8Array, offset: number) => CmapTableFormat4;\n    parse12: (data: Uint8Array, offset: number) => CmapTableFormat12;\n}\n/**\n * Collection of all table parsers\n */\nexport interface TyprTableParsers {\n    cmap: CmapParser;\n    head: TableParser<HeadTable>;\n    hhea: TableParser<HheaTable>;\n    maxp: TableParser<MaxpTable>;\n    hmtx: TableParser<HmtxTable>;\n    loca: TableParser<LocaTable>;\n    glyf: TableParser<(GlyphData | null)[]> & {\n        _parseGlyf: (font: TyprFont, glyphIndex: number) => GlyphData | null;\n    };\n}\n/**\n * Complete TyprFont interface representing a parsed OpenType/TrueType font\n * This interface describes the structure returned by Typr.parse()\n */\nexport interface TyprFont {\n    /** Internal font data buffer */\n    _data: Uint8Array;\n    /** Font index in collection */\n    _index: number;\n    /** Font offset in data */\n    _offset: number;\n    /** Character map table */\n    cmap: CmapData;\n    /** Font header table */\n    head: HeadTable;\n    /** Horizontal header table */\n    hhea: HheaTable;\n    /** Horizontal metrics table */\n    hmtx: HmtxTable;\n    /** Maximum profile table */\n    maxp: MaxpTable;\n    /** Glyph location table */\n    loca: LocaTable;\n    /** Glyph data table - stores parsed glyph data (populated on demand) */\n    glyf: (GlyphData | null)[];\n    /** Additional font tables that may be present */\n    [tableName: string]: any;\n}\n/**\n * Main Typr interface\n * Provides font parsing and table lookup functionality\n */\nexport interface TyprStatic {\n    /** Parse font buffer and return array of fonts */\n    parse: (buffer: ArrayBuffer) => TyprFont[];\n    /** Find a specific table in font data */\n    findTable: (data: Uint8Array, tableName: string, offset: number) => [number, number] | null;\n    /** Collection of table parsers */\n    T: TyprTableParsers;\n    /** Binary reading utilities */\n    B: TyprBinary;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/typr/Typr.d.ts": "/**\n * Typr.ts - TypeScript Font Parsing Library for textmode.js\n *\n * A comprehensive TypeScript implementation of font parsing capabilities\n * for OpenType and TrueType fonts. Provides essential functionality including\n * character mapping, glyph data extraction, and font metrics processing.\n *\n * Originally based on Typr.js by photopea (https://github.com/photopea/Typr.js)\n * Rewritten in TypeScript with enhanced type safety and optimizations for textmode.js\n *\n * @license MIT\n */\nimport type { TyprStatic } from './types';\ndeclare function woffToOtfSync(buff: ArrayBuffer): ArrayBuffer;\n/**\n * Main Typr class implementation\n */\ndeclare const Typr: TyprStatic;\nexport default Typr;\nexport declare const convertWoffToOtf: typeof woffToOtfSync;",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/utils/FontTableReader.d.ts": "import type { TyprFont } from '../typr/types.ts';\n/**\n * Centralized font table reader that eliminates redundant font data access.\n * Provides access to font tables and metrics with consistent error handling.\n */\nexport declare class FontTableReader {\n    /**\n     * Gets the glyph index for a given Unicode code point.\n     * Searches through all available cmap tables to find the character.\n     */\n    $getGlyphIndex(font: TyprFont, codePoint: number): number;\n    /**\n     * Gets the glyph index for a character string.\n     * Convenience method that extracts the code point first.\n     */\n    $getGlyphIndexForCharacter(font: TyprFont, character: string): number;\n    /**\n     * Gets the advance width for a glyph from the horizontal metrics table.\n     */\n    $getGlyphAdvanceWidth(font: TyprFont, glyphIndex: number): number;\n    /**\n     * Gets font-level metrics scaled to the specified font size.\n     */\n    $getFontMetrics(font: TyprFont, fontSize: number): {\n        ascender: number;\n        descender: number;\n        lineGap: number;\n        lineHeight: number;\n        unitsPerEm: number;\n        scale: number;\n    };\n    /**\n     * Gets glyph index from format 4 cmap table (BMP Unicode).\n     */\n    private _getGlyphIndexFormat4;\n    /**\n     * Gets glyph index from format 12 cmap table (full Unicode).\n     */\n    private _getGlyphIndexFormat12;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/font/utils/index.d.ts": "/**\n * Font utilities - centralized font processing functionality.\n *\n * This module provides shared utilities that eliminate code duplication\n * across the font system components.\n */\nexport { FontTableReader } from './FontTableReader.ts';",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/index.d.ts": "export { TextmodeImage } from './TextmodeImage';\nexport { TextmodeVideo } from './video/TextmodeVideo';\nexport { TextmodeFont } from './font/TextmodeFont';\nexport type { TextmodeCharacter } from './font/types';",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/ITextmodeSource.d.ts": "import type { Material } from '../../rendering/webgl/materials/Material';\nimport type { TextmodeConversionMode } from '../conversion';\nimport type { TextmodeColor } from '../TextmodeColor';\nimport type { TextmodeFont } from './font/TextmodeFont';\n/**\n * Base interface for drawable textmode sources (images, videos, canvas, etc.).\n * Handles shared WebGL texture state, material creation, and color/character settings.\n */\nexport interface ITextmodeSource {\n    /**\n     * Select the conversion mode for this source.\n     *\n     * `textmode.js` includes only a single built-in conversion strategy `'brightness'`.\n     *\n     * Additional conversion strategies may be provided via add-on libraries.\n     *\n     * @param mode Conversion mode to use.\n     */\n    conversionMode(mode: TextmodeConversionMode): this;\n    /**\n     * Dispose of the underlying WebGL texture. Subclasses may extend for additional cleanup.\n     * @ignore\n     */\n    $dispose(): void;\n    /**\n     * Set the invert flag, swapping character and cell colors when enabled.\n     * @param v Invert flag\n     * @returns This instance for chaining.\n     */\n    invert(v?: boolean | number): this;\n    /**\n     * Set horizontal flip indicator flag.\n     * @param v Flip flag\n     * @returns This instance for chaining.\n     */\n    flipX(v?: boolean | number): this;\n    /**\n     * Set vertical flip indicator flag.\n     * @param v Flip flag\n     * @returns This instance for chaining.\n     */\n    flipY(v?: boolean | number): this;\n    /**\n     * Set the character rotation in degrees (0-360).\n     * @param degrees Rotation in degrees\n     * @returns This instance for chaining.\n     */\n    charRotation(degrees: number): this;\n    /**\n     * Set character color mode: `'sampled'` *(from source)* or `'fixed'`.\n     * @param mode The character color mode\n     * @returns This instance for chaining.\n     */\n    charColorMode(mode: 'sampled' | 'fixed'): this;\n    /**\n     * Set cell color mode: `'sampled'` *(from source)* or `'fixed'`.\n     * @param mode The cell color mode\n     * @returns This instance for chaining.\n     */\n    cellColorMode(mode: 'sampled' | 'fixed'): this;\n    /**\n     * Defines the character color when {@link charColorMode} is `'fixed'`.\n     * @param colorOrGray A grayscale value (0-255), hex string ('#RGB', '#RRGGBB', '#RRGGBBAA'), or TextmodeColor instance\n     * @param g Green component (0-255) if using RGB format\n     * @param b Blue component (0-255) if using RGB format\n     * @param a Alpha component (0-255) if using RGBA format\n     * @returns This instance for chaining.\n     */\n    charColor(colorOrGray: number | string | TextmodeColor, g?: number, b?: number, a?: number): this;\n    /**\n     * Defines the cell color when {@link cellColorMode} is `'fixed'`.\n     * @param colorOrGray A grayscale value (0-255), hex string ('#RGB', '#RRGGBB', '#RRGGBBAA'), or TextmodeColor instance\n     * @param g Green component (0-255) if using RGB format\n     * @param b Blue component (0-255) if using RGB format\n     * @param a Alpha component (0-255) if using RGBA format\n     * @returns This instance for chaining.\n     */\n    cellColor(colorOrGray: number | string | TextmodeColor, g?: number, b?: number, a?: number): this;\n    /**\n     * Defines the background color used for transparent pixels.\n     * @param colorOrGray A grayscale value (0-255), hex string ('#RGB', '#RRGGBB', '#RRGGBBAA'), or TextmodeColor instance\n     * @param g Green component (0-255) if using RGB format\n     * @param b Blue component (0-255) if using RGB format\n     * @param a Alpha component (0-255) if using RGBA format\n     * @returns This instance for chaining.\n     */\n    background(colorOrGray: number | TextmodeColor | string, g?: number, b?: number, a?: number): this;\n    /**\n     * Define the characters to use for brightness mapping as a string.\n     * Maximum length is 255; excess characters are ignored.\n     * @param chars String of characters to map\n     * @returns This instance for chaining.\n     */\n    characters(chars: string): this;\n    /**\n     * Set the active font for the current render pass.\n     * Called by the renderer before getMaterial() to ensure the source uses the correct layer's font.\n     * @param font The font to use for this render\n     * @ignore\n     */\n    $setActiveFont(font: TextmodeFont): void;\n    /** Return the WebGL texture currently backing this source. */\n    readonly texture: WebGLTexture;\n    /** Ideal width in grid cells. */\n    readonly width: number;\n    /** Ideal height in grid cells. */\n    readonly height: number;\n    /** Original pixel width. */\n    readonly originalWidth: number;\n    /** Original pixel height. */\n    readonly originalHeight: number;\n    /**\n     * Get or create the material for rendering this source.\n     * @ignore\n     */\n    $getMaterial(): Material;\n    /**\n     * Create base conversion uniforms shared across all strategies.\n     * @returns Uniforms object\n     * @ignore\n     */\n    createBaseConversionUniforms(): Record<string, any>;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/TextmodeImage.d.ts": "import type { GLRenderer } from '../../rendering/webgl/core/Renderer';\nimport { TextmodeSource } from './TextmodeSource';\nimport type { TextmodeConversionManager } from '../conversion';\n/**\n * Represents an image uploaded for textmode rendering via {@link Textmodifier.loadImage}.\n *\n * It can be drawn to the canvas via {@link Textmodifier.image}.\n *\n * An image uploaded currently runs through an adjustable brightness-converter that converts\n * the original image into a textmode representation using characters.\n * Those adjustable options are available via chainable methods on this class.\n *\n * \n */\nexport declare class TextmodeImage extends TextmodeSource {\n    private constructor();\n    /**\n     * Create a TextmodeImage from an HTML image/video/canvas element.\n     * Texture parameters use NEAREST and CLAMP to align with grid sampling.\n     * @ignore\n     */\n    static $fromSource(renderer: GLRenderer, conversionManager: TextmodeConversionManager, source: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, gridCols: number, gridRows: number): TextmodeImage;\n    protected $getActiveTexture(): WebGLTexture;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/TextmodeSource.d.ts": "import type { GLRenderer } from '../../rendering/webgl/core/Renderer';\nimport type { Material } from '../../rendering/webgl/materials/Material';\nimport { TextmodeColor } from '../TextmodeColor';\nimport type { TextmodeFont } from './font/TextmodeFont';\nimport type { ITextmodeSource } from './ITextmodeSource';\nimport type { TextmodeConversionMode, TextmodeConversionManager } from '../conversion';\ntype GlyphColor = [number, number, number];\nexport declare abstract class TextmodeSource implements ITextmodeSource {\n    protected _gl: WebGL2RenderingContext;\n    protected _renderer: GLRenderer;\n    protected _texture: WebGLTexture;\n    protected _originalWidth: number;\n    protected _originalHeight: number;\n    protected _width: number;\n    protected _height: number;\n    protected _material: Material | null;\n    protected _activeFont: TextmodeFont | null;\n    protected _conversionMode: TextmodeConversionMode;\n    private _cachedConversionStrategy;\n    private _conversionManager;\n    protected _invert: number;\n    protected _flipX: number;\n    protected _flipY: number;\n    protected _charRotation: number;\n    protected _charColorMode: 'sampled' | 'fixed';\n    protected _cellColorMode: 'sampled' | 'fixed';\n    protected _charColor: [number, number, number, number];\n    protected _cellColor: [number, number, number, number];\n    protected _backgroundColor: [number, number, number, number];\n    protected _glyphColors: GlyphColor[];\n    private _characterString;\n    protected constructor(gl: WebGL2RenderingContext, renderer: GLRenderer, texture: WebGLTexture, conversionManager: TextmodeConversionManager, originalWidth: number, originalHeight: number, width: number, height: number);\n    conversionMode(mode: TextmodeConversionMode): this;\n    $dispose(): void;\n    invert(v?: boolean | number): this;\n    flipX(v?: boolean | number): this;\n    flipY(v?: boolean | number): this;\n    charRotation(degrees: number): this;\n    charColorMode(mode: 'sampled' | 'fixed'): this;\n    cellColorMode(mode: 'sampled' | 'fixed'): this;\n    charColor(colorOrGray: number | string | TextmodeColor, g?: number, b?: number, a?: number): this;\n    cellColor(colorOrGray: number | string | TextmodeColor, g?: number, b?: number, a?: number): this;\n    background(colorOrGray: number | TextmodeColor | string, g?: number, b?: number, a?: number): this;\n    characters(chars: string): this;\n    /**\n     * Set the active font for the current render pass.\n     * Called by the renderer before getMaterial() to ensure the source uses the correct layer's font.\n     * @param font The font to use for this render\n     * @ignore\n     */\n    $setActiveFont(font: TextmodeFont): void;\n    get texture(): WebGLTexture;\n    get width(): number;\n    get height(): number;\n    get originalWidth(): number;\n    get originalHeight(): number;\n    $getMaterial(): Material;\n    protected $beforeMaterialUpdate(): void;\n    protected abstract $getActiveTexture(): WebGLTexture;\n    private _updateMaterial;\n    private _setColor;\n    private _applyCharacterPalette;\n    createBaseConversionUniforms(): Record<string, any>;\n    private _getActiveConversionStrategy;\n    private _createConversionContext;\n}\nexport {};",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/video/ITextmodeVideo.d.ts": "import type { Material } from '../../../rendering/webgl/materials/Material';\nimport type { ITextmodeSource } from '../ITextmodeSource';\nexport interface ITextmodeVideo extends ITextmodeSource {\n    /**\n     * Dispose of GPU resources and cleanup video element.\n     * @ignore\n     */\n    $dispose(): void;\n    /**\n     * Update the texture with the current video frame if needed.\n     * For preloaded videos, this returns the appropriate frame texture.\n     * For live videos, this updates the texture with current video data.\n     * @ignore\n     */\n    $updateTexture(): void;\n    /**\n     * Get or create the material for rendering this video.\n     * Always updates the material to ensure the latest video frame is used.\n     * @ignore\n     */\n    $getMaterial(): Material;\n    /**\n     * Play the video.\n     * @returns Promise that resolves when playback starts\n     */\n    play(): Promise<void>;\n    /**\n     * Pause the video.\n     */\n    pause(): void;\n    /**\n     * Stop the video and reset to beginning.\n     */\n    stop(): void;\n    /**\n     * Set the playback speed.\n     * @param rate Playback rate (1.0 = normal speed)\n     */\n    speed(rate: number): this;\n    /**\n     * Set whether the video should loop.\n     * @param shouldLoop Whether to loop (defaults to true)\n     */\n    loop(shouldLoop?: boolean): this;\n    /**\n     * Set the current time position in the video.\n     * @param seconds Time in seconds\n     */\n    time(seconds: number): this;\n    /**\n     * Set the volume.\n     * @param level Volume level (0.0-1.0)\n     */\n    volume(level: number): this;\n    /**\n     * WebGL texture handle containing the current video frame.\n     */\n    readonly texture: WebGLTexture;\n    /**\n     * The underlying HTML video element.\n     */\n    readonly videoElement: HTMLVideoElement;\n    /**\n     * Current playback time in seconds.\n     */\n    readonly currentTime: number;\n    /**\n     * Total duration of the video in seconds.\n     */\n    readonly duration: number;\n    /**\n     * Whether the video is currently playing.\n     */\n    readonly isPlaying: boolean;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loadables/video/TextmodeVideo.d.ts": "import type { GLRenderer } from '../../../rendering/webgl/core/Renderer';\nimport type { Material } from '../../../rendering/webgl/materials/Material';\nimport { TextmodeSource } from '../TextmodeSource';\nimport type { ITextmodeVideo } from './ITextmodeVideo';\nimport type { TextmodeConversionManager } from '../../conversion';\n/**\n * Represents a video element for textmode rendering via {@link Textmodifier.loadVideo}.\n *\n * It can be drawn to the canvas via {@link Textmodifier.image}.\n *\n * A video uploaded currently runs through an adjustable brightness-converter that converts\n * the video frames into a textmode representation using characters.\n * Those adjustable options are available via chainable methods on this interface.\n * ```javascript\n * const t = textmode.create({\n *     width: 800,\n *     height: 600,\n * });\n *\n * let video;\n *\n * t.setup(async () => {\n *     video = await t.loadVideo('https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4');\n *     // Start playback and enable looping so the video keeps playing\n *     video.play();\n *     video.loop();\n *\n *     video.characters(\" .:-=+*#%@\");\n *     // ... other adjustments like video.flipX(boolean), video.cellColorMode('sampled' | 'fixed'), etc.\n *     // (can also be chained or updated during runtime)\n * });\n *\n * t.draw(() => {\n *     t.background(0);\n *\n *      // Draw the loaded video\n *      t.image(video);\n * });\n * ```\n */\nexport declare class TextmodeVideo extends TextmodeSource implements ITextmodeVideo {\n    private _videoElement;\n    /**\n     * Create a TextmodeVideo from an HTML video element.\n     * @param gl WebGL context\n     * @param renderer GLRenderer instance\n     * @param texture WebGL texture\n     * @param conversionManager Conversion manager\n     * @param videoElement HTMLVideoElement source\n     * @param originalWidth Original width of the video\n     * @param originalHeight Original height of the video\n     * @param gridCols Grid columns\n     * @param gridRows Grid rows\n     */\n    private constructor();\n    /**\n     * Dispose of this TextmodeVideo and free its resources.\n     * @ignore\n     */\n    $dispose(): void;\n    $updateTexture(): void;\n    protected $getActiveTexture(): WebGLTexture;\n    /**\n     * Get or create the material for rendering this video.\n     * Always updates the material to ensure the latest video frame is used.\n     * @returns Material\n     * @ignore\n     */\n    $getMaterial(): Material;\n    protected $beforeMaterialUpdate(): void;\n    /**\n     * Create a TextmodeVideo from a video URL.\n     * @param renderer GLRenderer instance\n     * @param conversionManager Conversion manager\n     * @param source Video URL\n     * @param gridCols Number of grid columns\n     * @param gridRows Number of grid rows\n     * @returns Promise resolving to a TextmodeVideo instance\n     * @ignore\n     */\n    static $fromSource(renderer: GLRenderer, conversionManager: TextmodeConversionManager, source: string, gridCols: number, gridRows: number): Promise<TextmodeVideo>;\n    play(): Promise<void>;\n    pause(): void;\n    stop(): void;\n    speed(rate: number): this;\n    loop(shouldLoop?: boolean): this;\n    time(seconds: number): this;\n    volume(level: number): this;\n    get videoElement(): HTMLVideoElement;\n    get currentTime(): number;\n    get duration(): number;\n    get isPlaying(): boolean;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/index.d.ts": "export { LoadingScreenManager } from './LoadingScreenManager';\nexport { LoadingPhaseTracker } from './LoadingPhaseTracker';\nexport { LoadingScreenStateMachine } from './LoadingScreenState';\nexport { LoadingScreenTransition } from './LoadingScreenTransition';\nexport { $resolveTheme as resolveTheme, $resolveDefaultPalette as resolveDefaultPalette, $resolveColorInputs as resolveColorInputs, } from './LoadingScreenTheme';\nexport { LoadingPhase } from './LoadingPhase';\nexport type { LoadingPhaseSnapshot, LoadingScreenOptions, LoadingScreenRendererContext, LoadingScreenTheme, LoadingScreenState, } from './types';",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/LoadingPhase.d.ts": "import type { LoadingPhaseTracker } from './LoadingPhaseTracker';\nimport type { ILoadingPhase } from './types';\n/**\n * Represents a loading phase tracked by a LoadingPhaseTracker.\n *\n * Allows reporting progress, completion, and failure of the phase.\n *\n * Also provides a method to track asynchronous tasks within the phase.\n */\nexport declare class LoadingPhase implements ILoadingPhase {\n    private readonly _phaseTracker;\n    readonly id: string;\n    readonly label: string;\n    private readonly _onError?;\n    /**\n     * Creates a new LoadingPhase.\n     * @param _phaseTracker The LoadingPhaseTracker managing this phase\n     * @param id The unique identifier for this loading phase\n     * @param label The human-readable label for this loading phase\n     * @param _onError Callback to invoke when the phase fails\n     * @ignore\n     */\n    constructor(_phaseTracker: LoadingPhaseTracker, id: string, label: string, _onError?: ((error: Error | string) => void) | undefined);\n    report(progress: number): void;\n    complete(): void;\n    fail(error?: Error | string): void;\n    track<T>(task: Promise<T> | (() => Promise<T> | T)): Promise<T>;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/LoadingPhaseTracker.d.ts": "import type { LoadingPhaseSnapshot } from './types';\n/**\n * Tracks loading phases and their progress.\n * @ignore\n */\nexport declare class LoadingPhaseTracker {\n    private _phases;\n    private _phaseOrder;\n    private _totalWeight;\n    private _lastReportedProgress;\n    private _onProgressChange?;\n    get $totalWeight(): number;\n    get $progress(): number;\n    $setProgressChangeCallback(callback: (progress: number) => void): void;\n    $createPhase(label: string, weight?: number): string;\n    $updatePhaseProgress(id: string, progress: number): void;\n    $completePhase(id: string): void;\n    $failPhase(id: string): void;\n    $snapshotPhases(): LoadingPhaseSnapshot[];\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/LoadingScreenManager.d.ts": "import type { Textmodifier } from '../Textmodifier';\nimport type { RGBA } from '../utils/cssColor';\nimport { LoadingPhase } from './LoadingPhase';\nimport type { LoadingScreenOptions } from './types';\n/**\n * Manages the loading screen display and state. Can be accessed via {@link Textmodifier.loading}.\n */\nexport declare class LoadingScreenManager {\n    private readonly _textmodifier;\n    private readonly _options;\n    private readonly _stateMachine;\n    private readonly _phaseTracker;\n    private readonly _transition;\n    private readonly _loadingAnimationController;\n    private _loadingLayer;\n    private _customRenderer;\n    private _palette;\n    private _theme;\n    private _startTime;\n    private _loadingFrameCount;\n    private _isRendering;\n    private _isInitialized;\n    /**\n     * Initializes a new LoadingScreenManager.\n     * @param textmodifier Textmodifier instance to render on.\n     * @param opts Loading screen options.\n     * @param canvasBackground Background color of the canvas.\n     * @ignore\n     */\n    constructor(textmodifier: Textmodifier, opts: LoadingScreenOptions | undefined, canvasBackground: RGBA | null);\n    /**\n     * Initialize loading screen resources using a TextmodeLayer.\n     * Must be called after the renderer is ready.\n     * @param fontSource Optional font source for the loading screen\n     * @ignore\n     */\n    $initialize(): Promise<void>;\n    /**\n     * Indicates whether the loading screen should render this frame.\n     * @ignore\n     */\n    get $shouldRender(): boolean;\n    /**\n     * Start the independent loading screen animation loop.\n     * This runs independently of the user's animation loop.\n     * @ignore\n     */\n    $start(): void;\n    /**\n     * Stop the independent loading screen animation loop.\n     * @ignore\n     */\n    $stop(): void;\n    /**\n     * Handle canvas resize during loading.\n     * Delegates to the loading layer which handles grid and framebuffer resizing.\n     * @ignore\n     */\n    $resize(): void;\n    /**\n     * Dispose of the loading screen manager and clean up resources.\n     * @ignore\n     */\n    $dispose(): void;\n    /**\n     * Get the current overall loading progress (0-1).\n     *\n     * \n     */\n    get progress(): number;\n    /**\n     * Get or set the loading screen message.\n     * @param next Optional new message to set.\n     * @returns The current loading screen message.\n     *\n     * \n     */\n    message(next?: string): string | undefined;\n    /**\n     * Begin a new loading phase.\n     *\n     * With the returned {@link LoadingPhase} you can report progress,\n     * track asynchronous work, and manage the phase lifecycle.\n     *\n     * @param label Label for the loading phase.\n     * @param weight Weight of the loading phase (default is 1).\n     * @returns A handle to the created loading phase.\n     *\n     * \n     */\n    addPhase(label: string, weight?: number): LoadingPhase;\n    /**\n     * Finish the loading process.\n     * @ignore\n     */\n    $finish(): void;\n    private _notifyComplete;\n    private _onCompleteCallback?;\n    /**\n     * Set a callback to be invoked when loading is complete.\n     * @param callback The callback function to invoke.\n     * @ignore\n     */\n    $setOnComplete(callback: () => void): void;\n    /**\n     * Report an error that occurred during loading.\n     * @param error The error message or `Error` object.\n     *\n     * \n     */\n    error(error: Error | string): void;\n    /**\n     * Independent render loop for the loading screen.\n     * This runs on its own animation controller, separate from user animation.\n     * @ignore\n     */\n    private _renderLoadingFrame;\n    /**\n     * Performs the actual rendering of the loading screen.\n     * @ignore\n     */\n    private _performRender;\n    /**\n     * Update the background color used in the loading screen theme.\n     * @param color The new background color.\n     * @ignore\n     */\n    $updateBackgroundColor(color: RGBA | null): void;\n    private _resolveRenderer;\n    /**\n     * Renders the library branding tag at the bottom left of the loading screen.\n     * Uses obfuscation techniques to make removal more difficult.\n     * @ignore\n     */\n    private _renderBrandingTag;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/LoadingScreenState.d.ts": "import type { LoadingScreenState } from './types';\n/**\n * Manages the state of the loading screen.\n * @ignore\n */\nexport declare class LoadingScreenStateMachine {\n    private _state;\n    private _errorMessage;\n    private _errorDetails;\n    constructor(initialState?: LoadingScreenState);\n    get $state(): LoadingScreenState;\n    get $isEnabled(): boolean;\n    get $shouldRender(): boolean;\n    get $errorMessage(): string;\n    get $errorDetails(): string;\n    $activate(): void;\n    $finish(): void;\n    $startTransition(): void;\n    $completeTransition(): void;\n    $setError(error: Error | string): void;\n    $disable(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/LoadingScreenTheme.d.ts": "import type { LoadingScreenTheme, LoadingScreenOptions } from './types';\nimport type { Textmodifier } from '../Textmodifier';\nimport type { TextmodeColor } from '../TextmodeColor';\n/**\n * Resolves the loading screen theme based on options and background color.\n * @param options Loading screen options.\n * @param background Background color as RGBA or null.\n * @returns The resolved loading screen theme.\n * @ignore\n */\nexport declare function $resolveTheme(options: LoadingScreenOptions, background: [number, number, number, number] | null): LoadingScreenTheme;\n/**\n * Resolves the default color palette based on the theme mode.\n * @param theme The loading screen theme.\n * @returns An array of color strings representing the default palette.\n * @ignore\n */\nexport declare function $resolveDefaultPalette(theme: LoadingScreenTheme): string[];\n/**\n * Resolves an array of color inputs into TextmodeColor instances.\n * @param inputs Input colors as numbers, strings, or TextmodeColor instances.\n * @param textmodifier The Textmodifier instance used to create TextmodeColor objects.\n * @returns An array of TextmodeColor instances.\n * @ignore\n */\nexport declare function $resolveColorInputs(inputs: (number | string | TextmodeColor)[], textmodifier: Textmodifier): TextmodeColor[];",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/LoadingScreenTransition.d.ts": "export type TransitionType = 'none' | 'fade';\n/**\n * Handles loading screen transitions.\n * @ignore\n */\nexport declare class LoadingScreenTransition {\n    private _transitionStartTime;\n    private _transitionOpacity;\n    private _transitionType;\n    private _transitionDuration;\n    constructor(transitionType: TransitionType, transitionDuration: number);\n    get $opacity(): number;\n    get $isTransitioning(): boolean;\n    $start(): void;\n    $update(): boolean;\n    $reset(): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/templates/index.d.ts": "export { spinnerTemplate } from './SpinnerTemplate';",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/templates/SpinnerTemplate.d.ts": "import type { LoadingScreenRendererContext } from '../types';\nexport declare const spinnerTemplate: (context: LoadingScreenRendererContext) => void;",
  "file:///node_modules/textmode.js/dist/types/textmode/loading/types.d.ts": "import type { TextmodeGrid } from '../Grid';\nimport type { Textmodifier } from '../Textmodifier';\nimport type { TextmodeColor } from '../TextmodeColor';\n/**\n * Snapshot of a loading phase's state.\n */\nexport interface LoadingPhaseSnapshot {\n    /** The unique identifier of the loading phase. */\n    id: string;\n    /** The label or name of the loading phase. */\n    label: string;\n    /**\n     * The weight of this phase for calculating overall progress.\n     */\n    weight: number;\n    /** The progress of the loading phase, represented as a number between 0 and 1. */\n    progress: number;\n    /** The current status of the loading phase. */\n    status: 'pending' | 'running' | 'complete' | 'failed';\n}\n/**\n * Options for configuring the loading screen.\n *\n * \n */\nexport interface LoadingScreenOptions {\n    /**\n     * Message to display on the loading screen.  Default is `'loading...'`.\n     */\n    message?: string;\n    /**\n     * Color tone of the loading screen. Can be 'auto', 'light', or 'dark'. Default is 'auto'.\n     * <br/><br/>\n     * Based on the background color the `textmode.js` canvas is rendered on, the loading screen\n     * will automatically choose a light or dark theme when set to `'auto'`.\n     */\n    tone?: 'auto' | 'light' | 'dark';\n    /**\n     * Provides a custom renderer function for the loading screen,\n     * overriding the default loading screen. The `context` parameter is a {@link LoadingScreenRendererContext} object.\n     */\n    renderer?: (context: LoadingScreenRendererContext) => void;\n    /**\n     * Type of transition effect. Default is `'fade'`.\n     */\n    transition?: 'none' | 'fade';\n    /**\n     * Duration of the transition effect in milliseconds. Default is `500`ms.\n     */\n    transitionDuration?: number;\n}\n/**\n * Context object passed to a loading screen renderer function.\n *\n * Can be used to create a custom loading screen to fit your needs.\n *\n * \n */\nexport interface LoadingScreenRendererContext {\n    /** The Textmodifier instance for rendering text and graphics. */\n    textmodifier: Textmodifier;\n    /** The TextmodeGrid representing the screen grid. */\n    grid: TextmodeGrid;\n    /** The current loading progress (0-1). */\n    progress: number;\n    /** The elapsed time since the loading started, in milliseconds. */\n    elapsedMs: number;\n    /** The number of frames rendered since the loading started. */\n    frameCount: number;\n    /** The current loading message, if any. */\n    message?: string;\n    /** The palette of colors available for rendering based on the `theme`. */\n    palette: TextmodeColor[];\n    /** The current theme of the loading screen. */\n    theme: LoadingScreenTheme;\n    /** The phases of the loading process. */\n    phases: LoadingPhaseSnapshot[];\n    /** The opacity level for transition effects. */\n    transitionOpacity: number;\n    /** Indicates if the loading screen is in an error state. */\n    isError: boolean;\n    /** The error message to display, if any. */\n    errorMessage?: string;\n    /** Detailed error information, if any. */\n    errorDetails?: string;\n}\n/**\n * A function that renders the loading screen.\n */\nexport type LoadingScreenRenderer = (context: LoadingScreenRendererContext) => void;\n/**\n * Handle for managing a loading phase.\n */\nexport interface ILoadingPhase {\n    /**\n     * The unique identifier of the loading phase.\n     */\n    id: string;\n    /**\n     * The label or name of the loading phase.\n     */\n    label: string;\n    /**\n     * Update the progress of the loading phase.\n     * @param progress A number between 0 and 1 representing the phase's progress.\n     *\n     * \n     */\n    report(progress: number): void;\n    /**\n     * Mark the loading phase as complete.\n     *\n     * \n     */\n    complete(): void;\n    /**\n     * Mark the loading phase as failed.\n     *\n     * This will put the loading manager into an error state, displaying the\n     * error on the loading screen.\n     *\n     * @param error An optional error object or message describing the failure.\n     *\n     * \n     */\n    fail(error?: Error | string): void;\n    /**\n     * Track a task within this loading phase.\n     * @param task A promise or function representing the task to track.\n     * @returns A promise that resolves with the task's result.\n     *\n     * \n     */\n    track<T>(task: Promise<T> | (() => Promise<T> | T)): Promise<T>;\n}\n/**\n * Theme settings for the loading screen.\n */\nexport interface LoadingScreenTheme {\n    /** The color mode of the loading screen, either 'light' or 'dark'. */\n    mode: 'light' | 'dark';\n    /** The background color of the loading screen, or null for transparent. */\n    background: [number, number, number, number] | null;\n    /** The primary text color used on the loading screen. */\n    textColor: number | string | TextmodeColor;\n    /** The subtle text color used on the loading screen. */\n    subtleColor: number | string | TextmodeColor;\n}\n/**\n * The state of the loading screen.\n * @ignore\n */\nexport type LoadingScreenState = 'disabled' | 'active' | 'done' | 'transitioning' | 'error';",
  "file:///node_modules/textmode.js/dist/types/textmode/managers/index.d.ts": "/**\n * Types and interfaces for keyboard event handling\n */\nexport * as keyboard from '../managers/KeyboardManager';\n/**\n * Types and interfaces for mouse event handling\n */\nexport * as mouse from '../managers/MouseManager';\n/**\n * Types and interfaces for touch event handling\n */\nexport * as touch from '../managers/TouchManager';",
  "file:///node_modules/textmode.js/dist/types/textmode/managers/KeyboardManager.d.ts": "/**\n * Key event data passed to event handlers\n */\nexport interface KeyboardEventData {\n    /** The key that was pressed/released (e.g., 'a', 'Enter', 'ArrowLeft') */\n    key: string;\n    /** The key code (for compatibility) */\n    keyCode: number;\n    /** Whether Ctrl key is held down */\n    ctrlKey: boolean;\n    /** Whether Shift key is held down */\n    shiftKey: boolean;\n    /** Whether Alt key is held down */\n    altKey: boolean;\n    /** Whether Meta key (Windows/Cmd) is held down */\n    metaKey: boolean;\n    /** Whether this key is currently being held down (for keyPressed) or was released (for keyReleased) */\n    isPressed: boolean;\n    /** Original DOM keyboard event */\n    originalEvent: KeyboardEvent;\n}\n/**\n * Keyboard event handler function type\n */\nexport type KeyboardEventHandler = (data: KeyboardEventData) => void;\n/**\n * Key state information\n * @ignore\n */\nexport interface KeyState {\n    /** Whether the key is currently pressed */\n    isPressed: boolean;\n    /** Timestamp when the key was last pressed */\n    lastPressTime: number;\n    /** Timestamp when the key was last released */\n    lastReleaseTime: number;\n}\n/**\n * Manages all keyboard interaction for a Textmodifier instance.\n * Handles event listeners, key state tracking, and event dispatching.\n *\n * Provides keyboard functionality including:\n * - keyPressed() and keyReleased() callbacks\n * - Current key state tracking\n * - Special key handling (arrows, function keys, etc.)\n * - Modifier key support (Ctrl, Shift, Alt, Meta)\n * @ignore\n */\nexport declare class KeyboardManager {\n    private _keyStates;\n    private _lastKeyPressed;\n    private _lastKeyReleased;\n    private _keyDownListener;\n    private _keyUpListener;\n    private _areListenersSetup;\n    private _keyPressedCallback?;\n    private _keyReleasedCallback?;\n    private readonly _specialKeyMap;\n    /**\n     * Setup keyboard event listeners.\n     */\n    $setupListeners(): void;\n    /**\n     * Remove keyboard event listeners.\n     */\n    $cleanupListeners(): void;\n    /**\n     * Set a callback function that will be called when a key is pressed down.\n     * @param callback The function to call when a key is pressed\n     */\n    $setPressedCallback(callback: KeyboardEventHandler): void;\n    /**\n     * Set a callback function that will be called when a key is released.\n     * @param callback The function to call when a key is released\n     */\n    $setReleasedCallback(callback: KeyboardEventHandler): void;\n    /**\n     * Check if a specific key is currently being pressed.\n     * @param key The key to check (e.g., 'a', 'Enter', 'ArrowLeft', or special constants like 'SPACE')\n     * @returns true if the key is currently pressed, false otherwise\n     */\n    $isKeyPressed(key: string): boolean;\n    /**\n     * Get the last key that was pressed.\n     * @returns The key string of the last pressed key, or null if no key has been pressed\n     */\n    $getLastKeyPressed(): string | null;\n    /**\n     * Get the last key that was released.\n     * @returns The key string of the last released key, or null if no key has been released\n     */\n    $getLastKeyReleased(): string | null;\n    /**\n     * Get all currently pressed keys.\n     * @returns Array of key strings that are currently pressed\n     */\n    $getPressedKeys(): string[];\n    /**\n     * Check if any modifier key is currently pressed.\n     * @returns Object with boolean properties for each modifier key\n     */\n    $getModifierState(): {\n        ctrl: boolean;\n        shift: boolean;\n        alt: boolean;\n        meta: boolean;\n    };\n    /**\n     * Clear all key states (useful for focus loss scenarios).\n     */\n    $clearKeyStates(): void;\n    /**\n     * Handle key down events\n     */\n    private _handleKeyDown;\n    /**\n     * Handle key up events\n     */\n    private _handleKeyUp;\n    /**\n     * Normalize key names for consistency\n     */\n    private _normalizeKey;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/managers/MouseManager.d.ts": "import type { TextmodeCanvas } from '../Canvas';\nimport type { TextmodeGrid } from '../Grid';\n/**\n * Mouse coordinates in grid space using center-based coordinates.\n *\n * The coordinate system matches the main drawing/rendering space:\n * - `(0, 0)` is the center cell of the grid\n * - Negative X values are to the left of center\n * - Positive X values are to the right of center\n * - Negative Y values are above center\n * - Positive Y values are below center\n *\n * When the mouse is outside the grid bounds, both `x` and `y` are set to\n * `Number.NEGATIVE_INFINITY` to indicate an invalid/outside position.\n */\nexport interface MousePosition {\n    /** Grid X coordinate (column) in center-based coords. `Number.NEGATIVE_INFINITY` if outside grid. */\n    x: number;\n    /** Grid Y coordinate (row) in center-based coords. `Number.NEGATIVE_INFINITY` if outside grid. */\n    y: number;\n}\n/**\n * Mouse event data passed to event handlers\n */\nexport interface MouseEventData {\n    /** Current mouse position in grid coordinates */\n    position: MousePosition;\n    /** Previous mouse position in grid coordinates */\n    previousPosition: MousePosition;\n    /** Mouse button that triggered the event *(for click events)* */\n    button?: number;\n    /** Scroll delta for wheel events */\n    delta?: {\n        /** Scroll delta in X direction */\n        x: number;\n        /** Scroll delta in Y direction */\n        y: number;\n    };\n    /** Original DOM event */\n    originalEvent: MouseEvent | WheelEvent;\n}\n/**\n * Mouse event handler function type\n */\nexport type MouseEventHandler = (data: MouseEventData) => void;\n/**\n * Grid provider function type - returns the grid to use for coordinate calculations\n */\nexport type GridProvider = () => TextmodeGrid | undefined;\n/**\n * Manages all mouse interaction for a Textmodifier instance.\n * Handles event listeners, coordinate conversion, and event dispatching.\n * @ignore\n */\nexport declare class MouseManager {\n    private _canvas;\n    private _getGrid;\n    private _mousePosition;\n    private _previousMousePosition;\n    private _lastClientCoordinates;\n    private _suppressUntil;\n    private _mouseMoveListener;\n    private _mouseLeaveListener;\n    private _mouseDownListener;\n    private _mouseUpListener;\n    private _clickListener;\n    private _wheelListener;\n    private _areListenersSetup;\n    private _mouseClickedCallback?;\n    private _mousePressedCallback?;\n    private _mouseReleasedCallback?;\n    private _mouseMovedCallback?;\n    private _mouseScrolledCallback?;\n    /**\n     * Create a new MouseManager.\n     * @param canvas The canvas to track mouse events on.\n     * @param getGrid A function that returns the grid to use for coordinate calculations.\n     */\n    constructor(canvas: TextmodeCanvas, getGrid: GridProvider);\n    /**\n     * Temporarily suppress mouse event callbacks for a duration in milliseconds.\n     * Used to prevent synthetic mouse events from touch interactions from firing twice.\n     */\n    $suppressEventsFor(durationMs: number): void;\n    private _isSuppressed;\n    /**\n     * Set the CSS cursor for the textmode canvas.\n     * Pass a valid CSS cursor value (e.g. 'pointer', 'crosshair', 'move', 'nwse-resize', 'none').\n     * Call with no argument or an empty string to reset to the default cursor.\n     *\n     * Reference: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\n     */\n    $setCursor(cursor?: string): void;\n    /**\n     * Setup mouse event listeners on the canvas.\n     */\n    $setupListeners(): void;\n    /**\n     * Remove mouse event listeners from the canvas.\n     */\n    $cleanupListeners(): void;\n    /**\n     * Force an immediate update of the mouse position.\n     * This is useful when grid dimensions change (font size, window resize, etc.)\n     * and we need to recalculate the mouse coordinates without waiting for a mouse event.\n     */\n    $updatePositions(): void;\n    /**\n     * Set a callback function that will be called when the mouse is clicked.\n     * @param callback The function to call when the mouse is clicked\n     */\n    $setClickedCallback(callback: MouseEventHandler): void;\n    /**\n     * Set a callback function that will be called when the mouse is pressed down.\n     * @param callback The function to call when the mouse is pressed\n     */\n    $setPressedCallback(callback: MouseEventHandler): void;\n    /**\n     * Set a callback function that will be called when the mouse is released.\n     * @param callback The function to call when the mouse is released\n     */\n    $setReleasedCallback(callback: MouseEventHandler): void;\n    /**\n     * Set a callback function that will be called when the mouse moves.\n     * @param callback The function to call when the mouse moves\n     */\n    $setMovedCallback(callback: MouseEventHandler): void;\n    /**\n     * Set a callback function that will be called when the mouse wheel is scrolled.\n     * @param callback The function to call when the mouse wheel is scrolled\n     */\n    $setScrolledCallback(callback: MouseEventHandler): void;\n    /**\n     * Get the current mouse position in grid coordinates.\n     * Returns a copy to prevent external modification.\n     */\n    $getPosition(): MousePosition;\n    /**\n     * Handle mouse moved events\n     */\n    private _handleMouseMoved;\n    /**\n     * Handle mouse pressed events\n     */\n    private _handleMousePressed;\n    /**\n     * Handle mouse released events\n     */\n    private _handleMouseReleased;\n    /**\n     * Handle mouse clicked events\n     */\n    private _handleMouseClicked;\n    /**\n     * Handle mouse scrolled events\n     */\n    private _handleMouseScrolled;\n    /**\n     * Update mouse position based on mouse event.\n     * Converts pixel coordinates to center-based grid coordinates.\n     */\n    private _updateMousePosition;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/managers/PluginManager.d.ts": "import type { Textmodifier } from '../Textmodifier';\nimport type { GLRenderer } from '../../rendering/webgl/core/Renderer';\nimport type { GLFramebuffer } from '../../rendering';\nimport type { TextmodeFont } from '../loadables/font';\nimport type { TextmodeGrid } from '../Grid';\nimport type { TextmodeCanvas } from '../Canvas';\nimport type { TextmodeLayer } from '../layers/TextmodeLayer';\nimport type { TextmodeLayerManager } from '../layers';\n/**\n * Callback type for simple plugin hooks without parameters.\n */\nexport type TextmodePluginHook = () => void;\n/**\n * Callback type for setup lifecycle hooks.\n * Can be synchronous or return a Promise for async operations.\n */\nexport type SetupLifecycleHook = () => void | Promise<void>;\n/**\n * Callback type for layer lifecycle events.\n */\nexport type LayerLifecycleHook = (layer: TextmodeLayer) => void;\n/**\n * Callback type for layer render hooks.\n */\nexport type LayerRenderHook = (layer: TextmodeLayer) => void;\n/**\n * An extended API provided to plugins when they are installed on a {@link Textmodifier} instance.\n */\nexport interface TextmodePluginAPI {\n    /** The WebGL renderer used by the Textmodifier instance. */\n    renderer: GLRenderer;\n    /** The font used by the Textmodifier instance (from base layer). */\n    font: TextmodeFont;\n    /** The grid used by the Textmodifier instance (from base layer). */\n    grid: TextmodeGrid;\n    /** The canvas used by the Textmodifier instance. */\n    canvas: TextmodeCanvas;\n    /** The framebuffer the user draws to with 3 render targets (from base layer). */\n    drawFramebuffer: GLFramebuffer;\n    /**\n     * The framebuffer containing the ASCII representation (from base layer).<br/>\n     * This framebuffer only has a single render target.\n     */\n    asciiFramebuffer: GLFramebuffer;\n    /** The layer manager for accessing and managing all layers. */\n    layerManager: TextmodeLayerManager;\n    /**\n     * Register a callback to be invoked before each draw cycle.\n     * Happens just before any framebuffer\n     * @returns A function to unregister the hook.\n     */\n    registerPreDrawHook(callback: () => void): () => void;\n    /**\n     * Register a callback to be invoked after each draw cycle.\n     * Happens outside of the draw framebuffer being bound after the final result is drawn to the screen.\n     * @returns A function to unregister the hook.\n     */\n    registerPostDrawHook(callback: () => void): () => void;\n    /**\n     * Register a callback to be invoked when a layer is about to be disposed.\n     * @param callback The callback to invoke with the layer being disposed.\n     * @returns A function to unregister the hook.\n     */\n    registerLayerDisposedHook(callback: LayerLifecycleHook): () => void;\n    /**\n     * Register a callback to be invoked before each layer's render cycle.\n     * This happens after the layer's visibility check but before any drawing operations.\n     * Useful for rendering content to the layer's framebuffer before user draw callbacks.\n     * @param callback The callback to invoke with the layer and render context.\n     * @returns A function to unregister the hook.\n     */\n    registerLayerPreRenderHook(callback: LayerRenderHook): () => void;\n    /**\n     * Register a callback to be invoked after each layer's render cycle.\n     * This happens after the user draw callback but before ASCII conversion.\n     * @param callback The callback to invoke with the layer and render context.\n     * @returns A function to unregister the hook.\n     */\n    registerLayerPostRenderHook(callback: LayerRenderHook): () => void;\n    /**\n     * Register a callback to be invoked before the user's setup callback runs.\n     * This happens after the Textmodifier and all layers are fully initialized,\n     * but before user code in `setup()` executes.\n     * Useful for plugins that need to prepare resources or state before user setup.\n     * @param callback The callback to invoke before setup.\n     * @returns A function to unregister the hook.\n     */\n    registerPreSetupHook(callback: () => void | Promise<void>): () => void;\n    /**\n     * Register a callback to be invoked after the user's setup callback completes.\n     * This happens after user code in `setup()` has finished executing,\n     * but before the loading screen finishes and the main render loop begins.\n     * Useful for plugins that need to finalize initialization after user setup.\n     * @param callback The callback to invoke after setup.\n     * @returns A function to unregister the hook.\n     */\n    registerPostSetupHook(callback: () => void | Promise<void>): () => void;\n    /**\n     * Extend TextmodeLayer instances with a new method.\n     * The method will be available on all existing and future layer instances.\n     *\n     * @param methodName The name of the method to add.\n     * @param implementation The implementation function. `this` will be bound to the TextmodeLayer instance.\n     *\n     * \n     */\n    extendLayer<TArgs extends unknown[], TReturn>(methodName: string, implementation: (this: TextmodeLayer, ...args: TArgs) => TReturn): void;\n    /**\n     * Remove a method extension from TextmodeLayer.\n     * @param methodName The name of the method to remove.\n     */\n    removeLayerExtension(methodName: string): void;\n}\n/**\n * A plugin interface for extending the functionality of a {@link Textmodifier} instance.\n *\n * Users can create plugins by implementing this interface.\n *\n * @note\n * Plugins are currently experimental and the API may change in future releases.\n * The documentation is still lacking, but there are some add-on libraries already available,\n * all of which are fully open source and can be used as references for creating your own plugins.\n */\nexport interface TextmodePlugin {\n    /** Unique name for the plugin. */\n    name: string;\n    /** Version string for the plugin. */\n    version?: string;\n    /**\n     * Called when the plugin is installed on a {@link Textmodifier} instance.\n     * @param textmodifier The Textmodifier instance the plugin is being installed on.\n     * @param api An API object providing access to the Textmodifier's context and hook registration methods.\n     */\n    install(textmodifier: Textmodifier, api: TextmodePluginAPI): void | Promise<void>;\n    /**\n     * Called when the plugin is uninstalled from a {@link Textmodifier} instance.\n     * @param textmodifier The Textmodifier instance the plugin is being uninstalled from.\n     * @param api An API object providing access to the Textmodifier's context and hook registration methods.\n     */\n    uninstall?(textmodifier: Textmodifier, api: TextmodePluginAPI): void | Promise<void>;\n}\n/**\n * Manager for handling TextmodePlugin installation, uninstallation, and hook execution.\n * @ignore\n */\nexport declare class TextmodePluginManager {\n    private readonly _textmodifier;\n    private readonly _plugins;\n    private readonly _installationOrder;\n    private readonly _preDrawHooks;\n    private readonly _postDrawHooks;\n    private readonly _layerDisposedHooks;\n    private readonly _layerPreRenderHooks;\n    private readonly _layerPostRenderHooks;\n    private readonly _preSetupHooks;\n    private readonly _postSetupHooks;\n    private readonly _layerExtensions;\n    constructor(textmodifier: Textmodifier);\n    /**\n     * Install plugins synchronously.\n     * This is called from the constructor to ensure layer method extensions\n     * are available immediately after textmode.create() returns.\n     *\n     * Plugin install() methods should be synchronous or return void.\n     * Any async operations in install() will be started but not awaited.\n     *\n     * @ignore\n     */\n    $installManySync(plugins: TextmodePlugin[]): void;\n    $installMany(plugins: TextmodePlugin[]): Promise<void>;\n    $unuse(pluginName: string): Promise<void>;\n    $runPreDrawHooks(): void;\n    $runPostDrawHooks(): void;\n    /**\n     * Notify plugins that a layer is about to be disposed.\n     * Called by LayerManager/TextmodeLayer before disposal.\n     * @ignore\n     */\n    $notifyLayerDisposed(layer: TextmodeLayer): void;\n    /**\n     * Run all registered pre-render hooks for a layer.\n     * Called by TextmodeLayer.$render() before drawing.\n     * @ignore\n     */\n    $runLayerPreRenderHooks(layer: TextmodeLayer): void;\n    /**\n     * Run all registered post-render hooks for a layer.\n     * Called by TextmodeLayer.$render() after drawing but before ASCII conversion.\n     * @ignore\n     */\n    $runLayerPostRenderHooks(layer: TextmodeLayer): void;\n    /**\n     * Run all registered pre-setup hooks.\n     * Called by Textmodifier before the user's setup callback.\n     * @ignore\n     */\n    $runPreSetupHooks(): Promise<void>;\n    /**\n     * Run all registered post-setup hooks.\n     * Called by Textmodifier after the user's setup callback completes.\n     * @ignore\n     */\n    $runPostSetupHooks(): Promise<void>;\n    $disposeAll(): Promise<void>;\n    private _createAPI;\n    private _registerHook;\n    private _removePluginHooks;\n    private _runHooks;\n    private _runLayerLifecycleHooks;\n    private _runLayerRenderHooks;\n    /**\n     * Run setup lifecycle hooks in plugin installation order.\n     * Supports both synchronous and async hooks.\n     */\n    private _runSetupHooks;\n    private _addLayerExtension;\n    private _removeLayerExtension;\n    private _addMethodToLayerPrototype;\n    private _removeMethodFromLayerPrototype;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/managers/TouchManager.d.ts": "import type { TextmodeCanvas } from '../Canvas';\nimport type { MouseManager, GridProvider } from './MouseManager';\n/**\n * Touch position expressed both in grid and client coordinates.\n *\n * The grid coordinate system uses center-based coordinates matching the rendering space:\n * - `(0, 0)` is the center cell of the grid\n * - Negative X values are to the left of center\n * - Positive X values are to the right of center\n * - Negative Y values are above center\n * - Positive Y values are below center\n *\n * When the touch is outside the grid bounds, `x` and `y` are set to\n * `Number.NEGATIVE_INFINITY` to indicate an invalid/outside position.\n */\nexport interface TouchPosition {\n    /** Identifier provided by the browser for a touch point */\n    id: number;\n    /** Grid X coordinate (column) in center-based coords. `Number.NEGATIVE_INFINITY` if outside grid. */\n    x: number;\n    /** Grid Y coordinate (row) in center-based coords. `Number.NEGATIVE_INFINITY` if outside grid. */\n    y: number;\n    /** Client X coordinate in CSS pixels */\n    clientX: number;\n    /** Client Y coordinate in CSS pixels */\n    clientY: number;\n    /** Touch pressure (0-1) when supported */\n    pressure?: number;\n    /** Contact ellipse radius on the X axis in CSS pixels */\n    radiusX?: number;\n    /** Contact ellipse radius on the Y axis in CSS pixels */\n    radiusY?: number;\n    /** Contact ellipse angle in radians when provided */\n    rotationAngle?: number;\n}\n/**\n * Touch event data.\n *\n * The coordinate system uses center-based coordinates matching the main rendering space:\n * - `(0, 0)` is the center cell of the grid\n * - Coordinates can be used directly with `translate()` and other drawing functions\n */\nexport interface TouchEventData {\n    /** The touch point that triggered this event */\n    touch: TouchPosition;\n    /** The previous position for this touch if available */\n    previousTouch?: TouchPosition;\n    /** All active touches mapped to grid coordinates */\n    touches: TouchPosition[];\n    /** Active touches snapshot before this event */\n    previousTouches: TouchPosition[];\n    /** Touches that changed during this event */\n    changedTouches: TouchPosition[];\n    /** Milliseconds elapsed since the previous update for this touch */\n    deltaTime: number;\n    /** Original browser event */\n    originalEvent: TouchEvent;\n}\n/**\n * Tap (single or double) event data\n */\nexport interface TouchTapEventData {\n    /** Position of the tap */\n    touch: TouchPosition;\n    /** Number of taps recognised (1 or 2) */\n    taps: 1 | 2;\n    /** Original browser event */\n    originalEvent: TouchEvent;\n}\n/**\n * Long press event data\n */\nexport interface TouchLongPressEventData {\n    /** Touch position at the time the long press fired */\n    touch: TouchPosition;\n    /** Duration in milliseconds the press was held */\n    duration: number;\n    /** Original browser event */\n    originalEvent: TouchEvent;\n}\n/**\n * Swipe event data reported when the finger travels a minimum distance within a time window\n */\nexport interface TouchSwipeEventData {\n    /** Touch point at the end of the swipe */\n    touch: TouchPosition;\n    /** Normalised swipe direction vector */\n    direction: {\n        x: number;\n        y: number;\n    };\n    /** Total distance travelled in CSS pixels */\n    distance: number;\n    /** Velocity in CSS pixels per millisecond */\n    velocity: {\n        /** Velocity in X direction */\n        x: number;\n        /** Velocity in Y direction */\n        y: number;\n    };\n    /** Original browser event */\n    originalEvent: TouchEvent;\n}\n/**\n * Pinch gesture event data describing the scaling factor between the initial and current distance\n */\nexport interface TouchPinchEventData {\n    /** Touch points participating in the pinch, always two entries */\n    touches: [TouchPosition, TouchPosition];\n    /** Scale factor relative to the initial distance *(1 == unchanged)* */\n    scale: number;\n    /** Scale delta compared to the previous callback */\n    deltaScale: number;\n    /** Centre of the gesture in grid coordinates */\n    center: {\n        /** Grid X coordinate *(column)* */\n        x: number;\n        /** Grid Y coordinate *(row)* */\n        y: number;\n    };\n    /** Original browser event */\n    originalEvent: TouchEvent;\n}\n/**\n * Rotate gesture event data describing the angle change between the initial and current segment\n */\nexport interface TouchRotateEventData {\n    /** Touch points participating in the rotation, always two entries */\n    touches: [TouchPosition, TouchPosition];\n    /** Total rotation in degrees relative to the initial angle */\n    rotation: number;\n    /** Change in rotation since the previous callback */\n    deltaRotation: number;\n    /** Centre of the gesture in grid coordinates */\n    center: {\n        /** Grid X coordinate *(column)* */\n        x: number;\n        /** Grid Y coordinate *(row)* */\n        y: number;\n    };\n    /** Original browser event */\n    originalEvent: TouchEvent;\n}\n/** Touch event handler function type */\nexport type TouchEventHandler = (data: TouchEventData) => void;\n/** Touch tap event handler function type */\nexport type TouchTapHandler = (data: TouchTapEventData) => void;\n/** Touch long press event handler function type */\nexport type TouchLongPressHandler = (data: TouchLongPressEventData) => void;\n/** Touch swipe event handler function type */\nexport type TouchSwipeHandler = (data: TouchSwipeEventData) => void;\n/** Touch pinch event handler function type */\nexport type TouchPinchHandler = (data: TouchPinchEventData) => void;\n/** Touch rotate event handler function type */\nexport type TouchRotateHandler = (data: TouchRotateEventData) => void;\n/**\n * Manages all touch interactions for a Textmodifier instance.\n * Handles event listeners, coordinate conversion, gesture detection, and event dispatching.\n * @ignore\n */\nexport declare class TouchManager {\n    private readonly _canvas;\n    private readonly _mouseManager?;\n    private readonly _getGrid;\n    private _activeTouches;\n    private _previousTouches;\n    private _touchInfo;\n    private _gestureBaseline;\n    private readonly _originalTouchAction;\n    private readonly _originalUserSelect;\n    private _touchStartListener;\n    private _touchMoveListener;\n    private _touchEndListener;\n    private _touchCancelListener;\n    private _areListenersSetup;\n    private _touchStartedCallback?;\n    private _touchMovedCallback?;\n    private _touchEndedCallback?;\n    private _touchCancelledCallback?;\n    private _tapCallback?;\n    private _doubleTapCallback?;\n    private _longPressCallback?;\n    private _swipeCallback?;\n    private _pinchCallback?;\n    private _rotateCallback?;\n    private readonly _tapMaxDuration;\n    private readonly _doubleTapMaxInterval;\n    private readonly _tapMovementTolerance;\n    private readonly _longPressDuration;\n    private readonly _longPressMovementTolerance;\n    private readonly _swipeMinDistance;\n    private readonly _swipeMaxDuration;\n    private readonly _pinchThreshold;\n    private readonly _rotationThreshold;\n    private readonly _mouseSuppressionDuration;\n    private _lastTapTime;\n    private _lastTapPosition;\n    /**\n     * Create a new TouchManager.\n     * @param canvas The canvas to track touch events on.\n     * @param getGrid A function that returns the grid to use for coordinate calculations.\n     * @param mouseManager Optional mouse manager for suppressing mouse events during touch.\n     */\n    constructor(canvas: TextmodeCanvas, getGrid: GridProvider, mouseManager?: MouseManager);\n    /** Install touch listeners onto the canvas */\n    $setupListeners(): void;\n    /** Remove all touch listeners */\n    $cleanupListeners(): void;\n    /**\n     * Recalculate touch positions after grid size or offset changes.\n     * Uses stored client coordinates to project touches into the new grid.\n     */\n    $updatePositions(): void;\n    /** Retrieve a snapshot of all active touches */\n    $getTouches(): TouchPosition[];\n    $setStartedCallback(callback: TouchEventHandler): void;\n    $setMovedCallback(callback: TouchEventHandler): void;\n    $setEndedCallback(callback: TouchEventHandler): void;\n    $setCancelledCallback(callback: TouchEventHandler): void;\n    $setTapCallback(callback: TouchTapHandler): void;\n    $setDoubleTapCallback(callback: TouchTapHandler): void;\n    $setLongPressCallback(callback: TouchLongPressHandler): void;\n    $setSwipeCallback(callback: TouchSwipeHandler): void;\n    $setPinchCallback(callback: TouchPinchHandler): void;\n    $setRotateCallback(callback: TouchRotateHandler): void;\n    private _handleTouchStart;\n    private _handleTouchMove;\n    private _handleTouchEnd;\n    private _handleTouchCancel;\n    private _mapTouchList;\n    private _projectTouch;\n    private _projectClientToGrid;\n    private _buildTouchEventData;\n    private _initializeGestureBaseline;\n    private _updatePinchAndRotate;\n    private _gestureCenter;\n    private _evaluateTapAndSwipe;\n    private _detectDoubleTap;\n    private _cloneTouchPosition;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/AnimationMixin.d.ts": "import type { Mixin } from './TextmodifierMixin';\nimport type { IAnimationMixin } from './interfaces/IAnimationMixin';\n/**\n * Mixin that adds animation capabilities to a class\n * @param Base The base class to extend\n * @returns Extended class with animation capabilities\n */\nexport declare const AnimationMixin: Mixin<IAnimationMixin>;",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/index.d.ts": "export { type Constructor, type Mixin, $applyMixins } from './TextmodifierMixin';\nexport { RenderingMixin } from './RenderingMixin';\nexport { AnimationMixin } from './AnimationMixin';\nexport { MouseMixin } from './MouseMixin';\nexport { TouchMixin } from './TouchMixin';\nexport { KeyboardMixin } from './KeyboardMixin';\nexport type { MousePosition, MouseEventData, MouseEventHandler } from '../managers/MouseManager';\nexport type { KeyboardEventData, KeyboardEventHandler, KeyState } from '../managers/KeyboardManager';\nexport type { TouchEventData, TouchLongPressEventData, TouchPinchEventData, TouchPosition, TouchRotateEventData, TouchSwipeEventData, TouchTapEventData, } from '../managers/TouchManager';",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/interfaces/IAnimationMixin.d.ts": "/**\n * Interface for animation capabilities that will be mixed into Textmodifier\n */\nexport interface IAnimationMixin {\n    /**\n     * Set the target frame rate. If called without arguments, returns the current measured frame rate.\n     * @param fps The maximum frames per second for rendering.\n     *\n     * \n     */\n    frameRate(fps?: number): number | void;\n    /**\n     * Set or get the target frame rate limit.\n     *\n     * Works similarly to {@link frameRate}, but gets the target frame rate instead of the current measured frame rate.\n     *\n     * @param fps Optional new target frame rate. If not provided, returns current target frame rate.\n     * @returns Current target frame rate when getting, void when setting\n     *\n     * \n     */\n    targetFrameRate(fps?: number): number | void;\n    /**\n     * Get the number of milliseconds since the sketch started running.\n     *\n     * `millis` keeps track of how long a sketch has been running in milliseconds\n     * (thousandths of a second). This information is often helpful for timing events\n     * and animations.\n     *\n     * Time tracking begins before the code in {@link setup} runs. If loading screen is\n     * enabled, `millis` begins tracking as soon as the loading screen starts.\n     *\n     * This property is connected to {@link secs} - setting one will affect the other.\n     *\n     * @returns Number of milliseconds since starting the sketch.\n     *\n     * \n     * \n     * \n     */\n    get millis(): number;\n    /**\n     * Set the elapsed milliseconds by adjusting the internal start time.\n     *\n     * This allows seeking/scrubbing in animations. Setting `millis` will also\n     * affect the value returned by {@link secs} since they are connected.\n     *\n     * @param value The new elapsed time in milliseconds\n     */\n    set millis(value: number);\n    /**\n     * Get the number of seconds since the sketch started running.\n     *\n     * `secs` is a convenience property that returns the elapsed time in seconds\n     * instead of milliseconds. Equivalent to `millis / 1000`.\n     *\n     * Time tracking begins before the code in {@link setup} runs. If loading screen is\n     * enabled, `secs` begins tracking as soon as the loading screen starts.\n     *\n     * This property is connected to {@link millis} - setting one will affect the other.\n     *\n     * @returns Number of seconds since starting the sketch.\n     *\n     * \n     * \n     */\n    get secs(): number;\n    /**\n     * Set the elapsed seconds by adjusting the internal start time.\n     *\n     * This allows seeking/scrubbing in animations. Setting `secs` will also\n     * affect the value returned by {@link millis} since they are connected.\n     *\n     * @param value The new elapsed time in seconds\n     */\n    set secs(value: number);\n    /**\n     * Returns the time in milliseconds between the current frame and the previous frame.\n     *\n     * `deltaTime()` is useful for creating frame-rate-independent animations. By multiplying\n     * velocities and movements by `deltaTime()`, animations will run at consistent speeds\n     * regardless of the actual frame rate.\n     *\n     * @returns Time elapsed between current and previous frame in milliseconds.\n     *\n     * \n     */\n    deltaTime(): number;\n    /**\n     * Stop the automatic rendering loop.\n     *\n     * This method pauses the render loop without, allowing\n     * it to be resumed later with {@link loop}. This is useful for temporarily pausing\n     * animation while maintaining the ability to continue it.\n     *\n     * \n     */\n    noLoop(): void;\n    /**\n     * Resume the rendering loop if it was stopped by {@link noLoop}.\n     *\n     * \n     */\n    loop(): void;\n    /**\n     * Execute the render function a specified number of times.\n     *\n     * This method is useful when the render loop has been stopped with {@link noLoop},\n     * allowing you to trigger rendering on demand.\n     *\n     * @param n The number of times to execute the render function. Defaults to 1.\n     *\n     * \n     */\n    redraw(n?: number): void;\n    /**\n     * Check whether the textmodifier is currently running the automatic render loop.\n     * @returns True if the render loop is currently active, false otherwise.\n     *\n     * \n     */\n    isLooping(): boolean;\n    /**\n     * Get the current frame count.\n     */\n    get frameCount(): number;\n    /**\n     * Set the current frame count.\n     */\n    set frameCount(value: number);\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/interfaces/IKeyboardMixin.d.ts": "import type { KeyboardEventHandler } from '../../managers/KeyboardManager';\n/**\n * Capabilities provided by the KeyboardMixin\n */\nexport interface IKeyboardMixin {\n    /**\n     * Check if a specific key is currently being pressed.\n     *\n     * @param key The key to check (e.g., 'a', 'Enter', 'ArrowLeft')\n     * @returns true if the key is currently pressed, false otherwise\n     *\n     * \n     */\n    isKeyPressed(key: string): boolean;\n    /**\n     * Set a callback function that will be called when a key is pressed down.\n     *\n     * @param callback The function to call when a key is pressed\n     *\n     * \n     */\n    keyPressed(callback: KeyboardEventHandler): void;\n    /**\n     * Set a callback function that will be called when a key is released.\n     *\n     * @param callback The function to call when a key is released\n     *\n     * \n     */\n    keyReleased(callback: KeyboardEventHandler): void;\n    /**\n     * Get the last key that was pressed.\n     *\n     * Returns the key string of the last pressed key, or null if no key has been pressed.\n     *\n     * \n     */\n    get lastKeyPressed(): string | null;\n    /**\n     * Get the last key that was released.\n     *\n     * Returns the key string of the last released key, or null if no key has been released.\n     *\n     * \n     */\n    get lastKeyReleased(): string | null;\n    /**\n     * Get all currently pressed keys.\n     *\n     * Returns an array of key strings that are currently being held down.\n     *\n     * \n     */\n    get pressedKeys(): string[];\n    /**\n     * Get current modifier key states.\n     *\n     * Returns an object with boolean properties for each modifier key.\n     *\n     * \n     */\n    get modifierState(): {\n        /**\n         * Whether the Ctrl key is currently pressed\n         */\n        ctrl: boolean;\n        /**\n         * Whether the Shift key is currently pressed\n         */\n        shift: boolean;\n        /**\n         * Whether the Alt key is currently pressed\n         */\n        alt: boolean;\n        /**\n         * Whether the Meta key *(Command on Mac, Windows key on Windows)* is currently pressed\n         */\n        meta: boolean;\n    };\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/interfaces/IMouseMixin.d.ts": "import type { MouseEventHandler, MousePosition } from '../../managers/MouseManager';\n/**\n * Capabilities provided by the MouseMixin\n */\nexport interface IMouseMixin {\n    /**\n     * Set a callback function that will be called when the mouse is clicked.\n     *\n     * @param callback The function to call when the mouse is clicked\n     *\n     * \n     */\n    mouseClicked(callback: MouseEventHandler): void;\n    /**\n     * Set a callback function that will be called when the mouse is pressed down.\n     *\n     * @param callback The function to call when the mouse is pressed\n     *\n     * \n     */\n    mousePressed(callback: MouseEventHandler): void;\n    /**\n     * Set a callback function that will be called when the mouse is released.\n     *\n     * @param callback The function to call when the mouse is released\n     *\n     * \n     */\n    mouseReleased(callback: MouseEventHandler): void;\n    /**\n     * Set a callback function that will be called when the mouse moves.\n     *\n     * @param callback The function to call when the mouse moves\n     *\n     * \n     */\n    mouseMoved(callback: MouseEventHandler): void;\n    /**\n     * Set a callback function that will be called when the mouse wheel is scrolled.\n     *\n     * @param callback The function to call when the mouse wheel is scrolled\n     *\n     * \n     */\n    mouseScrolled(callback: MouseEventHandler): void;\n    /**\n     * Get the current mouse position in center-based grid coordinates.\n     *\n     * Returns the mouse position as grid cell coordinates where `(0, 0)` is the center cell.\n     * This matches the drawing coordinate system, so coordinates can be used directly with `translate()`.\n     *\n     * If the mouse is outside the grid or the instance is not ready,\n     * it returns `{ x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY }`.\n     *\n     * \n     */\n    get mouse(): MousePosition;\n    /**\n     * Set the mouse cursor for the textmode canvas.\n     *\n     * Provide any valid CSS cursor value (e.g. 'default', 'pointer', 'crosshair', 'move', 'text', 'grab', 'grabbing',\n     * 'none', 'zoom-in', 'zoom-out', 'ns-resize', 'ew-resize', 'nwse-resize', 'nesw-resize', etc.),\n     * or a CSS `url(...)` cursor. Call with no argument or an empty string to reset to default.\n     *\n     * See MDN for all options: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\n     *\n     * \n     */\n    cursor(cursor?: string): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/interfaces/IRenderingMixin.d.ts": "import type { GLFramebuffer, GLShader, TextmodeFramebufferOptions, UniformValue } from '../../../rendering/webgl';\nimport type { TextmodeImage } from '../../loadables/TextmodeImage';\nimport type { TextmodeColor } from '../../TextmodeColor';\nimport type { TextmodeVideo } from '../../loadables';\n/**\n * Interface for rendering capabilities that will be mixed into Textmodifier\n */\nexport interface IRenderingMixin {\n    /**\n     * Set a custom shader for subsequent rendering operations.\n     * @param shader The custom shader to use\n     *\n     * \n     */\n    shader(shader: GLShader): void;\n    /**\n     * Create a new framebuffer for offscreen rendering.\n     *\n     * The framebuffer uses the same MRT structure as the main rendering pipeline.\n     * By default it allocates 4 attachments (character + color data).\n     *\n     * @param options Configuration options for the framebuffer.\n     * @returns A new Framebuffer instance.\n     *\n     * \n     */\n    createFramebuffer(options: TextmodeFramebufferOptions): GLFramebuffer;\n    /**\n     * Draw a TextmodeFramebuffer, TextmodeImage, or TextmodeVideo to the current render target.\n     *\n     * @param source The TextmodeFramebuffer or TextmodeSource to render\n     * @param width Width to potentially scale the content\n     * @param height Height to potentially scale the content\n     *\n     * \n     */\n    image(source: GLFramebuffer | TextmodeImage | TextmodeVideo, width?: number, height?: number): void;\n    /**\n     * Load an image and return a TextmodeImage that can be drawn with image().\n     *\n     * The loaded image can be rendered to the canvas using the {@link image} method.\n     * This function returns a Promise that resolves when the image has loaded.\n     *\n     * @param src URL or existing HTMLImageElement\n     * @returns A Promise that resolves to a TextmodeImage object\n     *\n     * \n     */\n    loadImage(src: string | HTMLImageElement): Promise<TextmodeImage>;\n    /**\n     * Load a video and return a TextmodeVideo that can be drawn with image().\n     * @param src URL or existing HTMLVideoElement\n     * @param options Optional configuration for preloading behavior. Provide `frameRate` to preload frames, `onProgress` to observe preload progress, `onComplete` to know when preloading finished, and `onError` to catch preload failures.\n     *\n     * \n     */\n    loadVideo(src: string | HTMLVideoElement): Promise<TextmodeVideo>;\n    /**\n     * Set a uniform value for the current custom shader.\n     * @param name The name of the uniform variable\n     * @param value The value to set\n     *\n     * \n     */\n    setUniform(name: string, value: UniformValue): void;\n    /**\n     * Set multiple uniform values for the current custom shader.\n     * @param uniforms Object containing uniform name-value pairs\n     *\n     * \n     */\n    setUniforms(uniforms: Record<string, UniformValue>): void;\n    /**\n     * Create a custom filter shader from fragment shader source code or a file path.\n     * The fragment shader automatically receives the standard vertex shader inputs\n     * and must output to the 3 MRT attachments (character/transform, primary color, secondary color).\n     * @param fragmentSource The fragment shader source code or a file path (e.g., './shader.frag')\n     * @returns A Promise that resolves to a compiled shader ready for use with {@link shader}\n     *\n     * \n     */\n    createFilterShader(fragmentSource: string): Promise<GLShader>;\n    /**\n     * Create a shader from vertex and fragment source code or file paths.\n     * Accepts inline shader source or file paths (e.g. './shader.frag', './shader.vert', '.frag', '.vert').\n     * @param vertexSource The vertex shader source code or a file path\n     * @param fragmentSource The fragment shader source code or a file path\n     * @returns A Promise that resolves to a compiled shader\n     */\n    createShader(vertexSource: string, fragmentSource: string): Promise<GLShader>;\n    /**\n     * Sets the rotation angles for subsequent shape rendering operations.\n     *\n     * All geometries rotate around the center of the shape.\n     *\n     * @param degreesX The rotation angle in degrees around the X-axis (optional, defaults to 0)\n     * @param degreesY The rotation angle in degrees around the Y-axis (optional, defaults to 0)\n     * @param degreesZ The rotation angle in degrees around the Z-axis (optional, defaults to 0)\n     *\n     * \n     */\n    rotate(degreesX?: number, degreesY?: number, degreesZ?: number): void;\n    /**\n     * Sets the X-axis rotation angle for subsequent shape rendering operations.\n     *\n     * All geometries rotate around the center of the shape.\n     *\n     * @param degrees The rotation angle in degrees around the X-axis\n     *\n     * \n     */\n    rotateX(degrees: number): void;\n    /**\n     * Sets the Y-axis rotation angle for subsequent shape rendering operations.\n     *\n     * All geometries rotate around the center of the shape.\n     *\n     * @param degrees The rotation angle in degrees around the Y-axis\n     *\n     * \n     */\n    rotateY(degrees: number): void;\n    /**\n     * Sets the Z-axis rotation angle for subsequent shape rendering operations.\n     *\n     * All geometries rotate around the center of the shape.\n     *\n     * @param degrees The rotation angle in degrees around the Z-axis\n     *\n     * \n     */\n    rotateZ(degrees: number): void;\n    /**\n     * Sets the translation offsets for subsequent shape rendering operations.\n     *\n     * All geometries are displaced by the specified amounts. Similar to p5.js translate().\n     *\n     * @param x Translation along the X-axis in pixels (optional, defaults to 0)\n     * @param y Translation along the Y-axis in pixels (optional, defaults to 0)\n     * @param z Translation along the Z-axis in pixels (optional, defaults to 0)\n     *\n     * \n     */\n    translate(x?: number, y?: number, z?: number): void;\n    /**\n     * Sets the X-axis translation offset for subsequent shape rendering operations.\n     *\n     * @param pixels The translation offset in pixels along the X-axis\n     *\n     * \n     */\n    translateX(pixels: number): void;\n    /**\n     * Sets the Y-axis translation offset for subsequent shape rendering operations.\n     *\n     * @param pixels The translation offset in pixels along the Y-axis\n     *\n     * \n     */\n    translateY(pixels: number): void;\n    /**\n     * Sets the Z-axis translation offset for subsequent shape rendering operations.\n     *\n     * @param pixels The translation offset in pixels along the Z-axis\n     *\n     * \n     */\n    translateZ(pixels: number): void;\n    /**\n     * Save the current rendering state to the state stack.\n     * Use with {@link pop} to isolate style changes within a block.\n     *\n     * \n     */\n    push(): void;\n    /**\n     * Restore the most recently saved rendering state from the state stack.\n     * Use with {@link push} to isolate style changes within a block.\n     *\n     * \n     */\n    pop(): void;\n    /**\n     * Create a reusable color object compatible with textmode drawing APIs.\n     *\n     * Accepts grayscale, RGB, RGBA, and hex string values as arguments. Returned\n     * {@link TextmodeColor} instances can be passed to {@link background},\n     * {@link char}, {@link charColor}, {@link cellColor}, and more.\n     *\n     * @param value Grayscale value, hex string, single character, or an existing color\n     * @param g Optional green component, or `value` when using grayscale form\n     * @param b Optional blue component, or `value` when using grayscale form\n     * @param a Optional alpha component when using RGB form\n     *\n     * Example usage of the {@link color} helper.\n     *\n     * \n     */\n    color(value: number | string | TextmodeColor, g?: number, b?: number, a?: number): TextmodeColor;\n    /**\n     * Draw a rectangle with the current settings.\n     * Position is controlled via {@link translate}, {@link push}, and {@link pop}.\n     * @param width Width of the rectangle\n     * @param height Height of the rectangle\n     *\n     * \n     */\n    rect(width?: number, height?: number): void;\n    /**\n     * Draw a 1x1 rectangle with the current settings.\n     *\n     * \n     */\n    point(): void;\n    /**\n     * Draw a line from point (x1, y1) to point (x2, y2) with the settings.\n     * @param x1 X-coordinate of the line start point\n     * @param y1 Y-coordinate of the line start point\n     * @param x2 X-coordinate of the line end point\n     * @param y2 Y-coordinate of the line end point\n     *\n     * \n     */\n    line(x1: number, y1: number, x2: number, y2: number): void;\n    /**\n     * Set the background color of the layer currently drawing to.\n     *\n     * Used to clear the layer to a specific color at the start of its drawing cycle.\n     *\n     * @param value A {@link TextmodeColor}, hex string, grayscale value, or single RGB channel\n     * @param g Optional green component when providing RGB channels or alpha when used with grayscale\n     * @param b Optional blue component when providing RGB channels\n     * @param a Optional alpha component (0-255)\n     *\n     * \n     */\n    background(value: number | string | TextmodeColor, g?: number, b?: number, a?: number): void;\n    /**\n     * Clear the layer currently drawing to.\n     *\n     * Used to clear the layer at the start of its drawing cycle.\n     *\n     * \n     */\n    clear(): void;\n    /**\n     * Update the line weight (thickness) for subsequent {@link line} and {@link bezierCurve} calls.\n     * @param weight The line weight (thickness) to set.\n     *\n     * \n     */\n    lineWeight(weight: number): void;\n    /**\n     * Draw a smooth cubic bezier curve between two points with two control points.\n     * The curve thickness is controlled by the current {@link lineWeight} setting.\n     * @param x1 Start point X coordinate\n     * @param y1 Start point Y coordinate\n     * @param cp1x First control point X coordinate\n     * @param cp1y First control point Y coordinate\n     * @param cp2x Second control point X coordinate\n     * @param cp2y Second control point Y coordinate\n     * @param x2 End point X coordinate\n     * @param y2 End point Y coordinate\n     *\n     * \n     */\n    bezierCurve(x1: number, y1: number, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x2: number, y2: number): void;\n    /**\n     * Set the character to be used for subsequent rendering operations.\n     * Accepts a single character string.\n     *\n     * @param character The character to set for rendering\n     *\n     * \n     */\n    char(character: string): void;\n    /**\n     * Set the character color for subsequent rendering operations.\n     * Accepts channel values, hex strings, or a {@link TextmodeColor} instance.\n     * @param value Color object, hex string, or grayscale value (0-255)\n     * @param g Optional green component when providing RGB values or alpha when using grayscale form\n     * @param b Optional blue component when providing RGB values\n     * @param a Optional alpha component (0-255)\n     *\n     * \n     */\n    charColor(value: number | string | TextmodeColor, g?: number, b?: number, a?: number): void;\n    /**\n     * Set the cell background color for subsequent rendering operations.\n     * Accepts channel values, hex strings, or a {@link TextmodeColor} instance.\n     * @param value Color object, hex string, or grayscale value (0-255)\n     * @param g Optional green component when providing RGB values or alpha when using grayscale form\n     * @param b Optional blue component when providing RGB values\n     * @param a Optional alpha component (0-255)\n     *\n     * \n     */\n    cellColor(value: number | string | TextmodeColor, g?: number, b?: number, a?: number): void;\n    /**\n     * Toggle horizontal flipping for subsequent character rendering.\n     * @param toggle Whether to flip horizontally\n     *\n     * \n     */\n    flipX(toggle: boolean): void;\n    /**\n     * Toggle vertical flipping for subsequent character rendering.\n     * @param toggle Whether to flip vertically\n     *\n     * \n     */\n    flipY(toggle: boolean): void;\n    /**\n     * Set the character rotation angle for subsequent character rendering.\n     * @param degrees The rotation angle in degrees\n     *\n     * \n     */\n    charRotation(degrees: number): void;\n    /**\n     * Toggle color inversion for subsequent character rendering.\n     * @param toggle Whether to invert colors\n     *\n     * \n     */\n    invert(toggle: boolean): void;\n    /**\n     * Draw an ellipse with the current settings.\n     * Position is controlled via {@link translate}, {@link push}, and {@link pop}.\n     * @param width Width of the ellipse\n     * @param height Height of the ellipse\n     *\n     * \n     */\n    ellipse(width: number, height: number): void;\n    /**\n     * Draw a triangle with the current settings.\n     * @param x1 X-coordinate of the first vertex\n     * @param y1 Y-coordinate of the first vertex\n     * @param x2 X-coordinate of the second vertex\n     * @param y2 Y-coordinate of the second vertex\n     * @param x3 X-coordinate of the third vertex\n     * @param y3 Y-coordinate of the third vertex\n     *\n     * \n     */\n    triangle(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;\n    /**\n     * Draw an arc with the current settings.\n     * Position is controlled via {@link translate}, {@link push}, and {@link pop}.\n     * @param width Width of the arc\n     * @param height Height of the arc\n     * @param startAngle Starting angle in degrees\n     * @param endAngle Ending angle in degrees\n     *\n     * \n     */\n    arc(width: number, height: number, startAngle: number, endAngle: number): void;\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/interfaces/ITouchMixin.d.ts": "import type { TouchEventHandler, TouchLongPressHandler, TouchPinchHandler, TouchPosition, TouchRotateHandler, TouchSwipeHandler, TouchTapHandler } from '../../managers/TouchManager';\n/**\n * Capabilities exposed by the TouchMixin for handling touch interaction and gestures.\n */\nexport interface ITouchMixin {\n    /**\n     * Set a callback function that will be called when a touch point begins.\n     *\n     * The callback receives {@link TouchEventData} containing the touch that triggered the event,\n     * all active touches, and the original DOM event. Use this to react when the user places one or\n     * more fingers on the canvas.\n     *\n     * @param callback The function to call when a touch starts.\n     *\n     * \n     */\n    touchStarted(callback: TouchEventHandler): void;\n    /**\n     * Set a callback function that will be called when a touch point moves across the canvas.\n     *\n     * The provided callback is invoked continuously while the browser reports move events. Use the\n     * `previousTouch` and `deltaTime` fields to derive velocity or gesture behaviour.\n     *\n     * @param callback The function to call when a touch moves.\n     *\n     * \n     */\n    touchMoved(callback: TouchEventHandler): void;\n    /**\n     * Set a callback function that will be called when a touch ends normally.\n     *\n     * This fires after the finger leaves the canvas surface and the browser raises a `touchend`\n     * event. Use it to finalise state such as drawing strokes or completing gestures.\n     *\n     * @param callback The function to call when a touch ends.\n     *\n     * \n     */\n    touchEnded(callback: TouchEventHandler): void;\n    /**\n     * Set a callback function that will be called when a touch is cancelled by the browser.\n     *\n     * Cancellation can occur when the browser takes ownership for scrolling or if the gesture\n     * leaves the window. Treat this as an aborted touch and clean up any in-progress state.\n     *\n     * @param callback The function to call when a touch is cancelled.\n     *\n     * \n     */\n    touchCancelled(callback: TouchEventHandler): void;\n    /**\n     * Register a callback for tap gestures.\n     *\n     * A tap is fired when the user quickly touches and releases the canvas without travelling far.\n     * Use {@link TouchTapEventData.taps} to determine whether the gesture is a single or multi tap.\n     *\n     * @param callback The function to call when a tap gesture is detected.\n     *\n     * \n     */\n    tap(callback: TouchTapHandler): void;\n    /**\n     * Register a callback for double tap gestures.\n     *\n     * Double taps reuse the same {@link TouchTapEventData} as taps with `taps` set to `2`. This\n     * helper lets you supply a dedicated handler when you want to treat double taps differently.\n     *\n     * @param callback The function to call when a double tap is detected.\n     *\n     * \n     */\n    doubleTap(callback: TouchTapHandler): void;\n    /**\n     * Register a callback for long press gestures.\n     *\n     * A long press is emitted when the user keeps a finger on the canvas without moving beyond the\n     * configured tolerance. The event includes the press duration in milliseconds.\n     *\n     * @param callback The function to call when a long press gesture is detected.\n     *\n     * \n     */\n    longPress(callback: TouchLongPressHandler): void;\n    /**\n     * Register a callback for swipe gestures.\n     *\n     * Swipes provide the dominant direction (`up`, `down`, `left`, `right`), travelled distance, and\n     * velocity in CSS pixels per millisecond. Useful for panning, flicks, or quick shortcuts.\n     *\n     * @param callback The function to call when a swipe gesture is detected.\n     *\n     * \n     */\n    swipe(callback: TouchSwipeHandler): void;\n    /**\n     * Register a callback for pinch gestures, receiving scale deltas.\n     *\n     * Pinch gestures involve two touch points. The callback receives the current scale relative to\n     * the initial distance and the change since the previous update, enabling zoom interactions.\n     *\n     * @param callback The function to call when a pinch gesture is detected.\n     *\n     * \n     */\n    pinch(callback: TouchPinchHandler): void;\n    /**\n     * Register a callback for rotate gestures, receiving rotation deltas in degrees.\n     *\n     * Rotation callbacks provide the cumulative rotation and delta rotation since the last update,\n     * along with the gesture centre in grid coordinates. Ideal for dial-like interactions.\n     *\n     * @param callback The function to call when a rotation gesture is detected.\n     *\n     * \n     */\n    rotateGesture(callback: TouchRotateHandler): void;\n    /**\n     * Get the currently active touches in grid coordinates.\n     *\n     * Returns a copy of each touch, including grid position, client coordinates, and pressure when\n     * available. Use this inside a draw loop to react to active multi-touch scenarios.\n     *\n     * \n     */\n    get touches(): TouchPosition[];\n}",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/KeyboardMixin.d.ts": "import type { Mixin } from './TextmodifierMixin';\nimport type { IKeyboardMixin } from './interfaces/IKeyboardMixin';\n/**\n * Mixin that adds keyboard interaction capabilities to Textmodifier.\n *\n * This is a thin wrapper around KeyboardManager that provides the public API\n * for keyboard interaction. All the actual implementation is handled by the\n * KeyboardManager instance in the ITextmodifier.\n *\n * Provides p5.js-like keyboard functionality including key state tracking,\n * event callbacks, and special key handling.\n */\nexport declare const KeyboardMixin: Mixin<IKeyboardMixin>;",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/MouseMixin.d.ts": "import type { Mixin } from './TextmodifierMixin';\nimport type { IMouseMixin } from './interfaces/IMouseMixin';\n/**\n * Mixin that adds mouse tracking capabilities to Textmodifier.\n *\n * This is a thin wrapper around MouseManager that provides the public API\n * for mouse interaction. All the actual implementation is handled by the\n * MouseManager instance in the ITextmodifier.\n */\nexport declare const MouseMixin: Mixin<IMouseMixin>;",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/RenderingMixin.d.ts": "import type { Mixin } from './TextmodifierMixin';\nimport type { IRenderingMixin } from './interfaces/IRenderingMixin';\n/**\n * Mixin that adds rendering capabilities to a class by delegating to GLRenderer\n * @param Base The base class to extend\n * @returns Extended class with rendering capabilities\n */\nexport declare const RenderingMixin: Mixin<IRenderingMixin>;",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/TextmodifierMixin.d.ts": "/**\n * Base types and utilities for the mixin system\n */\nimport type { ITextmodifier } from '../interfaces';\n/**\n * Constructor type for mixin pattern\n */\nexport type Constructor<T = {}> = new (...args: any[]) => T;\n/**\n * Mixin function type that takes a base class and returns an extended class\n */\nexport type Mixin<T> = <TBase extends Constructor<ITextmodifier>>(Base: TBase) => TBase & Constructor<T>;\n/**\n * Simple utility function to apply multiple mixins to a base class\n * @param Base The base class to extend\n * @param mixins Array of mixin functions to apply\n * @returns The composed class with all mixins applied\n */\nexport declare function $applyMixins<T extends Constructor>(Base: T, ...mixins: any[]): T;",
  "file:///node_modules/textmode.js/dist/types/textmode/mixins/TouchMixin.d.ts": "import type { Mixin } from './TextmodifierMixin';\nimport type { ITouchMixin } from './interfaces/ITouchMixin';\n/**\n * Mixin that wires the public touch API to the underlying TouchManager implementation.\n */\nexport declare const TouchMixin: Mixin<ITouchMixin>;",
  "file:///node_modules/textmode.js/dist/types/textmode/TextmodeColor.d.ts": "type ColorTuple = [number, number, number] | [number, number, number, number];\n/**\n * Represents a color in the `textmode.js` rendering system.\n *\n * Values are stored as `0-255` integers for compatibility with public APIs,\n * while normalized versions are derived on demand for shader uploads.\n *\n * Use {@link Textmodifier.color} to create colors.\n */\nexport declare class TextmodeColor {\n    private readonly _rgba;\n    private readonly _normalized;\n    /** Red component *(0-255)* */\n    readonly r: number;\n    /** Green component *(0-255)* */\n    readonly g: number;\n    /** Blue component *(0-255)* */\n    readonly b: number;\n    /** Alpha component *(0-255)* */\n    readonly a: number;\n    private constructor();\n    /**\n     * Create a color from any supported source.\n     * Accepts an existing {@link TextmodeColor}, CSS hex strings, single characters\n     * (resolved through a glyph resolver), grayscale values, RGB(A) tuples, or\n     * normalized component arrays.\n     * @ignore\n     */\n    static $from(value: TextmodeColor | string | number | ColorTuple, g?: number, b?: number, a?: number): TextmodeColor;\n    /**\n     * Create a color from RGB or RGBA components (0-255 range).\n     * @ignore\n     */\n    static $fromRGBA(r: number, g: number, b: number, a?: number): TextmodeColor;\n    /**\n     * Create a grayscale color. Optional alpha can be provided.\n     * @ignore\n     */\n    static $fromGray(gray: number, alpha?: number): TextmodeColor;\n    /**\n     * Create a color from a CSS-style hex string.\n     * @ignore\n     */\n    static $fromHex(hex: string): TextmodeColor;\n    /** Returns a plain RGB array with integer components. */\n    get rgb(): [number, number, number];\n    /** Returns a plain RGBA array with integer components. */\n    get rgba(): [number, number, number, number];\n    /** Returns the normalized *(0-1)* RGBA array. */\n    get normalized(): [number, number, number, number];\n    /**\n     * Create a copy of this color with a different alpha value.\n     */\n    withAlpha(alpha: number): TextmodeColor;\n    /**\n     * Runtime type guard.\n     * @ignore\n     */\n    static $isColor(value: unknown): value is TextmodeColor;\n}\nexport {};",
  "file:///node_modules/textmode.js/dist/types/textmode/Textmodifier.d.ts": "import { GLRenderer } from '../rendering/webgl/core/Renderer';\nimport { TextmodeFont } from './loadables/font';\nimport { TextmodeGrid } from './Grid';\nimport { TextmodeCanvas } from './Canvas';\nimport { TextmodeImage } from './loadables/TextmodeImage';\nimport { AnimationController } from './AnimationController';\nimport { MouseManager } from './managers/MouseManager';\nimport { KeyboardManager } from './managers/KeyboardManager';\nimport { TouchManager } from './managers/TouchManager';\nimport { TextmodePluginManager } from './managers/PluginManager';\nimport type { ITextmodifier } from './interfaces';\nimport type { TextmodeOptions } from './types';\nimport type { IAnimationMixin } from './mixins/interfaces/IAnimationMixin';\nimport type { IRenderingMixin } from './mixins/interfaces/IRenderingMixin';\nimport type { IKeyboardMixin } from './mixins/interfaces/IKeyboardMixin';\nimport type { ITouchMixin } from './mixins/interfaces/ITouchMixin';\nimport type { IMouseMixin } from './mixins/interfaces/IMouseMixin';\nimport { LoadingScreenManager } from './loading/LoadingScreenManager';\nimport { LayerManager } from './layers/LayerManager';\nimport type { TextmodeLayer, TextmodeLayerManager } from './layers';\nimport type { TextmodeFilterManager } from './filters';\nimport type { FilterName, BuiltInFilterName, BuiltInFilterParams } from './filters';\nimport { TextmodeConversionManager } from './conversion';\ndeclare const Textmodifier_base: {\n    new (): {};\n};\n/**\n * Manages textmode rendering on a [`HTMLCanvasElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) and provides methods for drawing,\n * font management, event handling, layer management, animation control, and more. The heart of the `textmode.js` library.\n *\n * If the `Textmodifier` instance is created without a canvas parameter,\n * it creates a new `HTMLCanvasElement` to draw on using the `textmode.js` drawing API.\n * If a canvas is provided, it will use that canvas instead.\n */\nexport declare class Textmodifier extends Textmodifier_base implements ITextmodifier {\n    _renderer: GLRenderer;\n    _canvas: TextmodeCanvas;\n    _animationController: AnimationController;\n    _mouseManager: MouseManager;\n    _touchManager: TouchManager;\n    _keyboardManager: KeyboardManager;\n    _loading: LoadingScreenManager;\n    _layerManager: TextmodeLayerManager;\n    _activeLayer?: TextmodeLayer;\n    _conversionManager: TextmodeConversionManager;\n    /** @ignore */\n    _pluginManager: TextmodePluginManager;\n    private _destroyRequested;\n    private _isRenderingFrame;\n    private _isDisposed;\n    private _setupComplete;\n    private _setupCallback;\n    private _resizedCallback;\n    private _windowResizeListener;\n    private _resizeObserver?;\n    private _isOverlay;\n    private _targetCanvasImage?;\n    private _inputGridOverride?;\n    /**\n     * Create a new Textmodifier instance.\n     * @param opts Configuration options for the Textmodifier instance.\n     * @ignore\n     */\n    constructor(opts?: TextmodeOptions);\n    private _initialize;\n    /**\n     * Setup event listeners for window resize and input handling.\n     * @ignore\n     */\n    $setupEventListeners(): void;\n    $render(): void;\n    resizeCanvas(width: number, height: number): void;\n    destroy(): void;\n    private _performDestroy;\n    filter<T extends BuiltInFilterName>(name: T, params?: BuiltInFilterParams[T]): void;\n    filter(name: FilterName, params?: unknown): void;\n    draw(callback: () => void): void;\n    loadFont(fontSource: string): Promise<TextmodeFont>;\n    fontSize(size: number): void;\n    inputGrid(target?: 'topmost' | TextmodeGrid): 'topmost' | TextmodeGrid | void;\n    /**\n     * Get the grid used for input coordinate mapping.\n     * Returns the override grid/layer's grid if set, otherwise the topmost visible layer's grid.\n     */\n    private _getInputGrid;\n    setup(callback: () => void | Promise<void>): Promise<void>;\n    windowResized(callback: () => void): void;\n    get grid(): TextmodeGrid | undefined;\n    get font(): TextmodeFont;\n    get width(): number;\n    get height(): number;\n    get canvas(): HTMLCanvasElement;\n    get isDisposed(): boolean;\n    get overlay(): TextmodeImage | undefined;\n    get loading(): LoadingScreenManager;\n    get layers(): LayerManager;\n    get filters(): TextmodeFilterManager;\n    get conversions(): TextmodeConversionManager;\n    get isRenderingFrame(): boolean;\n\n    // Injected from textmode.synth.js\n    /**\n             * Set the global BPM (Beats Per Minute) for array modulation timing.\n             *\n             * This sets the master tempo for all layers. Individual layers can override\n             * this with `layer.bpm(value)` for polyrhythmic compositions.\n             *\n             * In live coding, BPM controls how fast arrays cycle through their values.\n             * By default, BPM is 60, meaning arrays advance 1 element per second.\n             * At BPM 120, they advance 2 elements per second.\n             *\n             * @param value - BPM value (beats per minute)\n             * @returns The BPM value that was set (for chaining)\n             */\n            bpm(value: number): number;\n}\nexport interface Textmodifier extends IRenderingMixin, IAnimationMixin, IMouseMixin, ITouchMixin, IKeyboardMixin {\n\n    // Injected from textmode.synth.js\n    /**\n             * Set the global BPM (Beats Per Minute) for array modulation timing.\n             *\n             * This sets the master tempo for all layers. Individual layers can override\n             * this with `layer.bpm(value)` for polyrhythmic compositions.\n             *\n             * In live coding, BPM controls how fast arrays cycle through their values.\n             * By default, BPM is 60, meaning arrays advance 1 element per second.\n             * At BPM 120, they advance 2 elements per second.\n             *\n             * @param value - BPM value (beats per minute)\n             * @returns The BPM value that was set (for chaining)\n             */\n            bpm(value: number): number;\n}\nexport {};",
  "file:///node_modules/textmode.js/dist/types/textmode/types.d.ts": "import type { TextmodePlugin } from './managers/PluginManager';\nimport type { LoadingScreenOptions } from './loading/';\n/**\n * Options when creating a {@link Textmodifier} instance.\n */\nexport type TextmodeOptions = {\n    /**\n     * An existing [HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) to use instead of creating a new one.\n     *\n     * **Note:**\n     * If using `overlay` mode, this should be the target canvas or video element to overlay on.\n     * `textmode.js` will create its own canvas applied on top of the target element, always matching its size and position.\n     */\n    canvas?: HTMLCanvasElement;\n    /** The font size to use for text rendering. Defaults to 16. */\n    fontSize?: number;\n    /** Maximum frames per second for auto rendering. Defaults to 60. */\n    frameRate?: number;\n    /** The width of the canvas when creating a new canvas. Defaults to 800. */\n    width?: number;\n    /** The height of the canvas when creating a new canvas. Defaults to 600. */\n    height?: number;\n    /**\n     * URL or path to a custom font file *(.otf/.ttf)*.\n     */\n    fontSource?: string;\n    /**\n     * Use `textmode.js` in overlay mode,\n     * which sets up the textmode `<canvas>` on top of an existing HTMLCanvasElement or HTMLVideoElement,\n     * automatically resizing and positioning it to match the target element.\n     *\n     * In this mode `textmode.js` fetches the content of the target element and loads it into an adjustable {@link loadables.TextmodeImage},\n     * that can be accessed via {@link Textmodifier.overlay}, and drawn via {@link Textmodifier.image},\n     *\n     * Useful for applying textmode conversion to p5.js sketches, YouTube videos, and sooo much more.\n     *\n     * All functionality of `textmode.js` remains available.\n     * Resizing the `textmode.js` canvas is not recommended though,\n     * since the overlay target automatically updates the size.\n     */\n    overlay?: boolean;\n    /** List of plugins to install when the Textmodifier instance is created. */\n    plugins?: TextmodePlugin[];\n    /** Configure the built-in loading screen experience. */\n    loadingScreen?: LoadingScreenOptions;\n};",
  "file:///node_modules/textmode.js/dist/types/textmode/utils/cssColor.d.ts": "export type RGBA = [number, number, number, number];\n/**\n * Parses a CSS color string (hex, rgb, rgba) into an RGBA tuple.\n * Returns null if the value cannot be parsed or is fully transparent.\n */\nexport declare function parseCssColor(value?: string | null): RGBA | null;\nexport declare function luminance(rgba: RGBA | null): number;\nexport declare function rgbaToCss(rgba: RGBA): string;",
  "file:///node_modules/textmode.js/dist/types/Textmode.d.ts": "import { type TextmodeErrorLevel } from './errors';\nimport { Textmodifier } from './textmode/Textmodifier';\nimport type { TextmodeOptions } from './textmode/types';\n/**\n * The main entry point for the `textmode.js` library.\n *\n * Provides static methods for creating {@link Textmodifier} instances and managing global settings.\n */\nexport declare class Textmode {\n    private constructor();\n    /**\n     * Create a new {@link Textmodifier} instance with optional configuration.\n     * @param opts Configuration options for the Textmodifier instance\n     * @returns A new Textmodifier instance\n     *\n     * \n     */\n    static create(opts?: TextmodeOptions): Textmodifier;\n    /**\n     * Set the global error handling level for the library. This applies to all {@link Textmodifier} instances present.\n     *\n     * @param level The error handling level to set.\n     *\n     * \n     */\n    static setErrorLevel(level: TextmodeErrorLevel): void;\n    /**\n     * Returns the version of `textmode.js` being used.\n     *\n     * \n     */\n    static get version(): string;\n}",
  "file:///node_modules/textmode.js/dist/types/utils/array.d.ts": "/**\n * Copy elements from a source array to a target array in-place.\n * This performs zero allocations by mutating the target array directly.\n * Optimized for fixed-size arrays used in real-time rendering.\n *\n * @param source - The source array to copy from\n * @param target - The target array to copy into (mutated in-place)\n *\n * \n */\nexport declare function copyArray<T extends number>(source: readonly T[], target: T[]): void;\n/**\n * Normalize 0-255 color values to 0-1 range and set in-place.\n * Zero allocations - mutates target array directly.\n *\n * @param target - Pre-allocated RGBA array to mutate\n * @param r - Red channel (0-255)\n * @param g - Green channel (0-255), defaults to r for grayscale\n * @param b - Blue channel (0-255), defaults to r for grayscale\n * @param a - Alpha channel (0-255), defaults to 255 (opaque)\n *\n * \n */\nexport declare function setColor(target: [number, number, number, number], r: number, g?: number, b?: number, a?: number): void;",
  "file:///node_modules/textmode.js/dist/types/utils/color.d.ts": "export declare function parseHexColor(hexString: string): [number, number, number, number];",
  "file:///node_modules/textmode.js/dist/types/utils/math.d.ts": "/**\n * Convert degrees to radians.\n *\n * @param degrees Angle in degrees\n * @returns Angle in radians\n *\n * \n */\nexport declare function degToRad(degrees: number): number;\n/**\n * Convert radians to degrees.\n *\n * @param radians Angle in radians\n * @returns Angle in degrees\n *\n * \n */\nexport declare function radToDeg(radians: number): number;\n/**\n * Calculate the angle in degrees between two points.\n * @param x1 - X coordinate of the first point\n * @param y1 - Y coordinate of the first point\n * @param x2 - X coordinate of the second point\n * @param y2 - Y coordinate of the second point\n * @returns The angle in degrees\n */\nexport declare function angleBetweenPoints(x1: number, y1: number, x2: number, y2: number): number;\n/**\n * Calculate the Euclidean distance between two points.\n * @param x1 - X coordinate of the first point\n * @param y1 - Y coordinate of the first point\n * @param x2 - X coordinate of the second point\n * @param y2 - Y coordinate of the second point\n * @returns The distance between the two points\n */\nexport declare function distanceBetweenPoints(x1: number, y1: number, x2: number, y2: number): number;\n/**\n * Clamp a value between a minimum and maximum range.\n * @param value Value to clamp\n * @param min Minimum allowable value\n * @param max Maximum allowable value\n * @returns Clamped value\n */\nexport declare function clamp(value: number, min: number, max: number): number;\n/**\n * Encode a rotation angle (in degrees) into a single normalized channel for GPU.\n *\n * This encoding packs a 0-360 rotation into a single 0-1 value by normalizing\n * the angle to the full channel range.\n *\n * **How it works:**\n * 1. Normalize degrees to 0-360 range (handle wrapping)\n * 2. Divide by 360 to get 0-1 range\n *\n * This provides ~256 discrete rotation steps (in an 8-bit channel), which is\n * sufficient for textmode rendering (~1.41 precision per step).\n *\n * @param degrees Rotation angle in degrees (0-360)\n * @returns Normalized value (0-1) representing the rotation\n *\n * \n */\nexport declare function encodeRotation(degrees: number): number;\n/**\n * Convert rotation angles from degrees to radians for 3D transformations.\n *\n * @param rotationXDegrees - Rotation around X-axis in degrees\n * @param rotationYDegrees - Rotation around Y-axis in degrees\n * @param rotationZDegrees - Rotation around Z-axis in degrees\n * @returns Object containing rotation values in radians for each axis\n *\n * \n */\nexport declare function calculateRotationParams(rotationXDegrees: number, rotationYDegrees: number, rotationZDegrees: number): {\n    radiansX: number;\n    radiansY: number;\n    radiansZ: number;\n};",
  "file:///node_modules/textmode.js/dist/types/utils/TextmodeCollection.d.ts": "/**\n * A generic, managed collection for objects that require lifecycle management.\n *\n * This class provides CRUD operations (Create/Read/Update/Delete) with support for:\n * - Adding and removing items\n * - Reordering items (move, swap)\n * - Deferred initialization via pending items\n * - Automatic disposal of removed items\n * - Event callbacks for lifecycle events\n *\n * @typeParam T - The type of items stored in the collection\n *\n * \n */\nexport declare class TextmodeCollection<T> implements Iterable<T> {\n    private _items;\n    private _pendingItems;\n    private _isReady;\n    private readonly _options;\n    /**\n     * Create a new TextmodeCollection.\n     *\n     * @param options Configuration options for the collection\n     */\n    constructor(options?: TextmodeCollectionOptions<T>);\n    /**\n     * Mark the collection as ready and move all pending items to the active list.\n     *\n     * Call this after async initialization is complete. Any items added before\n     * this call will be moved from the pending queue to the active collection.\n     *\n     * @param initializeItem Optional async function to initialize each pending item\n     * @returns Promise that resolves when all pending items are initialized\n     */\n    initialize(initializeItem?: (item: T) => Promise<void>): Promise<void>;\n    /**\n     * Check if the collection has been initialized.\n     */\n    get isReady(): boolean;\n    /**\n     * Add an item to the collection.\n     *\n     * If the collection is not yet ready, the item is added to a pending queue.\n     * Once `initialize()` is called, pending items are moved to the active collection.\n     *\n     * @param item The item to add\n     * @returns The added item (for chaining)\n     */\n    add(item: T): T;\n    /**\n     * Add multiple items to the collection.\n     *\n     * @param items The items to add\n     * @returns The added items\n     */\n    addMany(items: T[]): T[];\n    /**\n     * Remove an item from the collection and dispose it.\n     *\n     * @param item The item to remove\n     * @returns true if the item was found and removed, false otherwise\n     */\n    remove(item: T): boolean;\n    /**\n     * Remove an item at a specific index.\n     *\n     * @param index The index of the item to remove\n     * @returns The removed item, or undefined if index is out of bounds\n     */\n    removeAt(index: number): T | undefined;\n    /**\n     * Move an item to a new index in the collection.\n     *\n     * @param item The item to move\n     * @param newIndex The target index\n     * @returns true if the item was found and moved, false otherwise\n     */\n    move(item: T, newIndex: number): boolean;\n    /**\n     * Swap the positions of two items in the collection.\n     *\n     * @param itemA The first item\n     * @param itemB The second item\n     * @returns true if both items were found and swapped, false otherwise\n     */\n    swap(itemA: T, itemB: T): boolean;\n    /**\n     * Remove and dispose all items from the collection.\n     *\n     * This clears both active and pending items.\n     */\n    clear(): void;\n    /**\n     * Dispose the collection and all its items.\n     *\n     * After calling this, the collection should not be used.\n     */\n    dispose(): void;\n    /**\n     * Get all active items as a readonly array.\n     */\n    get all(): readonly T[];\n    /**\n     * Get all pending items as a readonly array.\n     */\n    get pending(): readonly T[];\n    /**\n     * Get the number of active items.\n     */\n    get length(): number;\n    /**\n     * Get the total number of items (active + pending).\n     */\n    get totalLength(): number;\n    /**\n     * Check if the collection is empty (no active items).\n     */\n    get isEmpty(): boolean;\n    /**\n     * Get an item at a specific index.\n     *\n     * @param index The index of the item\n     * @returns The item, or undefined if index is out of bounds\n     */\n    get(index: number): T | undefined;\n    /**\n     * Get the first item in the collection.\n     */\n    get first(): T | undefined;\n    /**\n     * Get the last item in the collection.\n     */\n    get last(): T | undefined;\n    /**\n     * Get the index of an item.\n     *\n     * @param item The item to find\n     * @returns The index, or -1 if not found\n     */\n    indexOf(item: T): number;\n    /**\n     * Check if an item exists in the collection.\n     *\n     * @param item The item to check\n     * @returns true if the item exists (in active or pending)\n     */\n    has(item: T): boolean;\n    /**\n     * Iterate over all active items.\n     */\n    [Symbol.iterator](): Iterator<T>;\n    /**\n     * Execute a callback for each active item.\n     *\n     * @param callback Function to execute for each item\n     */\n    forEach(callback: (item: T, index: number) => void): void;\n    /**\n     * Map active items to a new array.\n     *\n     * @param callback Function to transform each item\n     * @returns New array with transformed items\n     */\n    map<U>(callback: (item: T, index: number) => U): U[];\n    /**\n     * Filter active items.\n     *\n     * @param predicate Function to test each item\n     * @returns New array with items that pass the test\n     */\n    filter(predicate: (item: T, index: number) => boolean): T[];\n    /**\n     * Find an item matching a predicate.\n     *\n     * @param predicate Function to test each item\n     * @returns The first matching item, or undefined\n     */\n    find(predicate: (item: T, index: number) => boolean): T | undefined;\n    /**\n     * Find the index of an item matching a predicate.\n     *\n     * @param predicate Function to test each item\n     * @returns The index of the first matching item, or -1\n     */\n    findIndex(predicate: (item: T, index: number) => boolean): number;\n    /**\n     * Check if any item matches a predicate.\n     *\n     * @param predicate Function to test each item\n     * @returns true if any item matches\n     */\n    some(predicate: (item: T, index: number) => boolean): boolean;\n    /**\n     * Check if all items match a predicate.\n     *\n     * @param predicate Function to test each item\n     * @returns true if all items match\n     */\n    every(predicate: (item: T, index: number) => boolean): boolean;\n    /**\n     * Reduce active items to a single value.\n     *\n     * @param callback Reducer function\n     * @param initialValue Initial accumulator value\n     * @returns The final accumulated value\n     */\n    reduce<U>(callback: (accumulator: U, item: T, index: number) => U, initialValue: U): U;\n    /**\n     * Dispose a single item using the configured disposal callback.\n     */\n    private _disposeItem;\n}\n/**\n * Configuration options for TextmodeCollection.\n *\n * @typeParam T - The type of items stored in the collection\n */\nexport interface TextmodeCollectionOptions<T> {\n    /**\n     * Called when an item is added to the active collection.\n     * Not called for pending items until they become active.\n     */\n    onAdd?: (item: T) => void;\n    /**\n     * Called when an item is about to be removed from the collection.\n     * This is called before `onDispose`.\n     */\n    onRemove?: (item: T) => void;\n    /**\n     * Called to dispose an item when it's removed from the collection.\n     * This is where you should clean up resources.\n     */\n    onDispose?: (item: T) => void;\n    /**\n     * Called when an item is moved to a new index.\n     */\n    onMove?: (item: T, oldIndex: number, newIndex: number) => void;\n    /**\n     * Called when two items are swapped.\n     */\n    onSwap?: (itemA: T, itemB: T, indexA: number, indexB: number) => void;\n}",
  "file:///node_modules/textmode.synth.js/dist/types/api/index.d.ts": "/**\n * API module barrel - exports all public API functions.\n *\n * @module\n */\nexport { cellColor, char, charColor, gradient, noise, osc, paint, shape, solid, src, voronoi, } from './sources';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/api/sources.d.ts": "/**\n * Typed source function exports for the public API.\n *\n * @module\n */\nimport type { SynthContext } from '../core/types';\nimport { SynthSource } from '../core/SynthSource';\nimport { TextmodeLayer } from 'textmode.js';\n/**\n * Create a synth source with cell background color defined.\n *\n * This function creates a SynthSource where the cell background color\n * is driven by the provided source pattern. This is compositional and can be\n * combined with `char()` and `charColor()`.\n *\n * @param source - A SynthSource producing color values for cell background\n * @returns A new SynthSource configured with cell color\n *\n * \n */\nexport declare const cellColor: (source: SynthSource) => SynthSource;\n/**\n * Create a character source from any color/pattern source.\n *\n * This function converts any pattern (like `osc()`, `noise()`, `voronoi()`) into\n * character indices. The pattern's luminance or color values are mapped to character indices.\n *\n * @param source - A SynthSource producing color values that will be mapped to characters\n * @param charCount - Number of different characters to use (default: 256)\n * @returns A new SynthSource configured for character generation\n *\n * \n */\nexport declare const char: (source: SynthSource, charCount?: number) => SynthSource;\n/**\n * Create a synth source with character foreground color defined.\n *\n * This function creates a SynthSource where the character foreground color\n * is driven by the provided source pattern. This is compositional and can be\n * combined with `char()` and `cellColor()`.\n *\n * @param source - A SynthSource producing color values for character foreground\n * @returns A new SynthSource configured with character color\n *\n * \n */\nexport declare const charColor: (source: SynthSource) => SynthSource;\n/**\n * Generate a rotating radial gradient.\n * @param speed - Rotation speed (default: 0.0)\n *\n * \n */\nexport declare function gradient(speed?: number | number[] | ((ctx: SynthContext) => number)): SynthSource;\n/**\n * Generate Perlin noise patterns.\n * @param scale - Scale of the noise pattern (default: 10.0)\n * @param offset - Offset in noise space (default: 0.1)\n *\n * \n */\nexport declare function noise(scale?: number | number[] | ((ctx: SynthContext) => number), offset?: number | number[] | ((ctx: SynthContext) => number)): SynthSource;\n/**\n * Generate oscillating patterns using sine waves.\n * @param frequency - Frequency of the oscillation (default: 60.0)\n * @param sync - Synchronization offset (default: 0.1)\n * @param offset - Phase offset (default: 0.0)\n *\n * \n */\nexport declare function osc(frequency?: number | number[] | ((ctx: SynthContext) => number), sync?: number | number[] | ((ctx: SynthContext) => number), offset?: number | number[] | ((ctx: SynthContext) => number)): SynthSource;\n/**\n * Create a synth source with both character and cell colors defined.\n *\n * This function creates a SynthSource where both the character foreground color\n * and the cell background color are driven by the same source pattern.\n * This is a convenience function equivalent to calling both `charColor()` and\n * `cellColor()` with the same source, allowing for easy pixel art without visible characters.\n *\n * @param source - A SynthSource producing color values for both character and cell colors\n * @returns A new SynthSource configured with both color sources\n *\n * \n */\nexport declare const paint: (source: SynthSource) => SynthSource;\n/**\n * Generate geometric shapes (polygons).\n * @param sides - Number of sides (default: 3)\n * @param radius - Radius of the shape (default: 0.3)\n * @param smoothing - Edge smoothing amount (default: 0.01)\n *\n * \n */\nexport declare function shape(sides?: number | number[] | ((ctx: SynthContext) => number), radius?: number | number[] | ((ctx: SynthContext) => number), smoothing?: number | number[] | ((ctx: SynthContext) => number)): SynthSource;\n/**\n * Generate a solid color.\n * @param r - Red channel (0-1, default: 0.0)\n * @param g - Green channel (0-1, default: 0.0)\n * @param b - Blue channel (0-1, default: 0.0)\n * @param a - Alpha channel (0-1, default: 1.0)\n *\n * \n */\nexport declare function solid(r?: number | number[] | ((ctx: SynthContext) => number), g?: number | number[] | ((ctx: SynthContext) => number), b?: number | number[] | ((ctx: SynthContext) => number), a?: number | number[] | ((ctx: SynthContext) => number)): SynthSource;\n/**\n * Sample the previous frame's output for feedback effects.\n *\n * This is the core of feedback loops - it reads from the previous frame,\n * enabling effects like trails, motion blur, and recursive patterns.\n *\n * **Context-aware behavior:** When called without arguments, `src()` automatically\n * samples the appropriate texture based on where it's used in the synth chain:\n * - Inside `char(...)`  samples previous frame's character data\n * - Inside `charColor(...)`  samples previous frame's primary color\n * - Inside `cellColor(...)`  samples previous frame's cell color\n *\n * **Cross-layer sampling:** When called with a layer argument, `src(layer)` samples\n * from another layer's output, enabling hydra-style multi-output compositions:\n * - The sampled texture is still context-aware based on the current compilation target\n *\n * Equivalent to hydra's `src(o0)`.\n *\n * @param layer - Optional TextmodeLayer to sample from. If omitted, samples from self (feedback).\n * @returns A new SynthSource that samples the specified layer or self\n *\n * \n */\nexport declare const src: (layer?: TextmodeLayer) => SynthSource;\n/**\n * Generate voronoi patterns.\n * @param scale - Scale of voronoi cells (default: 5.0)\n * @param speed - Animation speed (default: 0.3)\n * @param blending - Blending between cell regions (default: 0.3)\n *\n * \n */\nexport declare function voronoi(scale?: number | number[] | ((ctx: SynthContext) => number), speed?: number | number[] | ((ctx: SynthContext) => number), blending?: number | number[] | ((ctx: SynthContext) => number)): SynthSource;\n//# sourceMappingURL=sources.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/augmentations/index.d.ts": "/**\n * Augmentations module barrel - imports all type augmentations for side effects.\n *\n * @module\n */\nimport './textmode';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/augmentations/textmode.d.ts": "/**\n * Type augmentations for textmode.js\n *\n * This module extends the TextmodeLayer and Textmodifier interfaces\n * when the textmode.synth.js package is imported.\n *\n * @module\n */\nimport type { SynthSource } from '../core/SynthSource';\n\n//# sourceMappingURL=textmode.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/bootstrap.d.ts": "/**\n * Bootstrap module - Initializes the synth system on import.\n *\n * This module handles all side-effect initialization required for\n * the synth system to function. It runs once when the library is imported.\n */\n/**\n * Generated standalone functions for source transforms (e.g., osc(), noise())\n */\nexport declare const generatedFunctions: import(\"./transforms\").GeneratedFunctions;\n//# sourceMappingURL=bootstrap.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/compiler/ExternalLayerManager.d.ts": "import type { ExternalLayerInfo, CompilationTarget } from './types';\nimport type { ExternalLayerReference } from '../core/types';\n/**\n * Manages external layer references and uniform prefix generation.\n *\n * When a synth chain references another layer via `src(layer)`, this manager:\n * 1. Generates unique uniform prefixes for the external layer's textures\n * 2. Tracks which textures (char, primary, cellColor) are actually sampled\n * 3. Provides mapping from layer IDs to uniform prefixes for code generation\n */\nexport declare class ExternalLayerManager {\n    /** Map from layer ID to external layer info */\n    private readonly _externalLayers;\n    /** Counter for generating unique uniform prefixes */\n    private _counter;\n    /** Map from layer ID to uniform prefix for consistent naming */\n    private readonly _layerIdToPrefix;\n    /**\n     * Get or create a uniform prefix for an external layer.\n     *\n     * @param layerId - Unique identifier for the layer\n     * @returns The uniform prefix (e.g., 'extLayer0', 'extLayer1')\n     */\n    getPrefix(layerId: string): string;\n    /**\n     * Track usage of an external layer's textures.\n     *\n     * @param ref - The external layer reference\n     * @param target - The current compilation target (determines which texture is sampled)\n     */\n    trackUsage(ref: ExternalLayerReference, target: CompilationTarget): void;\n    /**\n     * Check if a layer ID has been registered.\n     */\n    hasLayer(layerId: string): boolean;\n    /**\n     * Get info for a specific external layer.\n     */\n    getLayerInfo(layerId: string): ExternalLayerInfo | undefined;\n    /**\n     * Get all external layer references.\n     *\n     * @returns A new Map containing all external layer info\n     */\n    getExternalLayers(): Map<string, ExternalLayerInfo>;\n    /**\n     * Check if any external layers are referenced.\n     */\n    get hasExternalLayers(): boolean;\n    /**\n     * Get the count of external layers.\n     */\n    get count(): number;\n    /**\n     * Reset all external layer tracking state.\n     * Should be called at the start of each compilation.\n     */\n    reset(): void;\n}\n//# sourceMappingURL=ExternalLayerManager.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/compiler/FeedbackTracker.d.ts": "import type { CompilationTarget } from './types';\n/**\n * Feedback usage state returned by the tracker.\n */\nexport interface FeedbackUsage {\n    /** Whether character color feedback (prevCharColorBuffer) is used */\n    usesCharColorFeedback: boolean;\n    /** Whether character feedback (prevCharBuffer) is used */\n    usesCharFeedback: boolean;\n    /** Whether cell color feedback (prevCellColorBuffer) is used */\n    usesCellColorFeedback: boolean;\n}\n/**\n * Tracks which feedback textures are used during compilation.\n *\n * The synth system supports three separate feedback buffers:\n * - Character color (character foreground)\n * - Character data (character indices)\n * - Cell color (character background)\n *\n * Each `src()` call samples from a context-aware buffer based on\n * where it appears in the synth chain.\n */\nexport declare class FeedbackTracker {\n    private _usesFeedback;\n    private _usesCharFeedback;\n    private _usesCellColorFeedback;\n    /**\n     * Track feedback usage for a given compilation target.\n     * @param target - The current compilation target context\n     */\n    trackUsage(target: CompilationTarget): void;\n    /**\n     * Reset all feedback tracking state.\n     * Should be called at the start of each compilation.\n     */\n    reset(): void;\n    /**\n     * Get the current feedback usage state.\n     */\n    getUsage(): FeedbackUsage;\n    /**\n     * Check if any feedback is used.\n     */\n    get usesAnyFeedback(): boolean;\n    /** Whether character color feedback is used */\n    get usesCharColorFeedback(): boolean;\n    /** Whether character feedback is used */\n    get usesCharFeedback(): boolean;\n    /** Whether cell color feedback is used */\n    get usesCellColorFeedback(): boolean;\n}\n//# sourceMappingURL=FeedbackTracker.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/compiler/GLSLGenerator.d.ts": "/**\n * GLSLGenerator - Generates GLSL shader code from compiled data.\n *\n * This module is responsible for assembling the final GLSL fragment\n * shader from collected functions, uniforms, and main code.\n */\nimport type { SynthUniform, CharacterMapping } from '../core/types';\nimport type { ExternalLayerInfo } from './types';\n/**\n * Options for shader generation.\n */\nexport interface ShaderGenerationOptions {\n    /** Uniform declarations */\n    uniforms: Map<string, SynthUniform>;\n    /** GLSL function definitions */\n    glslFunctions: Set<string>;\n    /** Main function code lines */\n    mainCode: string[];\n    /** Character output code */\n    charOutputCode: string;\n    /** Primary color variable name */\n    primaryColorVar: string;\n    /** Cell color variable name */\n    cellColorVar: string;\n    /** Character mapping (if any) */\n    charMapping?: CharacterMapping;\n    /** Whether primary color feedback (src) is used */\n    usesFeedback?: boolean;\n    /** Whether character feedback (src) is used */\n    usesCharFeedback?: boolean;\n    /** Whether cell color feedback (src) is used */\n    usesCellColorFeedback?: boolean;\n    /** Whether char() function is used */\n    usesCharSource?: boolean;\n    /** External layer references used in this shader */\n    externalLayers?: Map<string, ExternalLayerInfo>;\n}\n/**\n * Generate the complete fragment shader.\n */\nexport declare function generateFragmentShader(options: ShaderGenerationOptions): string;\n/**\n * Generate character output code based on chain result.\n */\nexport declare function generateCharacterOutputCode(hasCharVar: boolean, charVar: string, colorVar: string): string;\n//# sourceMappingURL=GLSLGenerator.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/compiler/index.d.ts": "/**\n * Compiler module exports.\n *\n * The compiler system is modular, with responsibilities split across:\n * - SynthCompiler: Main compilation orchestration\n * - FeedbackTracker: Feedback texture usage tracking\n * - ExternalLayerManager: Cross-layer sampling management\n * - TransformCodeGenerator: Individual transform code generation\n * - UniformManager: Shader uniform handling\n * - GLSLGenerator: Final shader assembly\n */\nexport * from './types';\nexport { compileSynthSource } from './SynthCompiler';\nexport type { CompiledSynthShader } from './types';\nexport { FeedbackTracker, type FeedbackUsage } from './FeedbackTracker';\nexport { ExternalLayerManager } from './ExternalLayerManager';\nexport { TransformCodeGenerator, type TransformCodeResult } from './TransformCodeGenerator';\nexport { UniformManager } from './UniformManager';\nexport * from './GLSLGenerator';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/compiler/SynthCompiler.d.ts": "/**\n * SynthCompiler - Compiles SynthSource chains into MRT GLSL shaders.\n *\n * This compiler takes a SynthSource chain and produces a GLSL fragment shader\n * that outputs to textmode.js's triple-target MRT rendering:\n *   - Target 0: Character data (indexLow, indexHigh, packedFlags, rotation)\n *   - Target 1: Primary/foreground color (RGBA)\n *   - Target 2: Secondary/cell background color (RGBA)\n *\n * The compilation process is modular, delegating to:\n *   - FeedbackTracker: Manages feedback texture usage\n *   - ExternalLayerManager: Manages cross-layer sampling\n *   - TransformCodeGenerator: Generates GLSL for individual transforms\n *   - UniformManager: Manages shader uniforms\n *   - GLSLGenerator: Assembles the final shader\n */\nimport type { SynthSource } from '../core/SynthSource';\nimport type { CompiledSynthShader } from './types';\n/**\n * Compile a SynthSource chain into a complete MRT GLSL shader.\n *\n * @param source The SynthSource chain to compile\n * @returns A compiled shader with fragment source and uniform definitions\n */\nexport declare function compileSynthSource(source: SynthSource): CompiledSynthShader;\n//# sourceMappingURL=SynthCompiler.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/compiler/TransformCodeGenerator.d.ts": "import type { ProcessedTransform } from '../transforms/TransformDefinition';\nimport type { CompilationTarget } from './types';\nimport type { ExternalLayerReference } from '../core/types';\n/**\n * Result of generating code for a transform.\n */\nexport interface TransformCodeResult {\n    /** The color variable name after this transform */\n    colorVar: string;\n    /** The character variable name (if modified) */\n    charVar?: string;\n    /** The flags variable name (if modified) */\n    flagsVar?: string;\n    /** The rotation variable name (if modified) */\n    rotationVar?: string;\n}\n/**\n * Generates GLSL code for individual transforms.\n *\n * This module handles the code generation logic for each transform type,\n * including context-aware function naming for src() operations.\n */\nexport declare class TransformCodeGenerator {\n    /**\n     * Generate a context-aware GLSL function for src().\n     *\n     * When the transform is 'src', this generates a context-specific GLSL function\n     * that samples the appropriate texture based on the current compilation target:\n     * - char context  samples prevCharBuffer\n     * - charColor/main context  samples prevCharColorBuffer (primary color)\n     * - cellColor context  samples prevCellColorBuffer\n     *\n     * For external layer references, generates a function that samples from\n     * the external layer's texture uniforms.\n     *\n     * @param def - The processed transform definition\n     * @param name - The transform name\n     * @param currentTarget - The current compilation target\n     * @param externalRef - Optional external layer reference\n     * @param getExternalPrefix - Function to get external layer uniform prefix\n     * @returns The GLSL function code\n     */\n    getContextAwareGlslFunction(def: ProcessedTransform, name: string, currentTarget: CompilationTarget, externalRef?: ExternalLayerReference, getExternalPrefix?: (layerId: string) => string): string;\n    /**\n     * Get the function name to call for a transform.\n     * Handles context-aware naming for src() operations.\n     */\n    getFunctionName(def: ProcessedTransform, currentTarget: CompilationTarget, externalRef?: ExternalLayerReference, getExternalPrefix?: (layerId: string) => string): string;\n    /**\n     * Generate GLSL code for a transform and append to mainCode.\n     *\n     * @param mainCode - Array to append generated code lines\n     * @param def - The processed transform definition\n     * @param varId - Unique variable ID for this transform\n     * @param coordVar - Current coordinate variable name\n     * @param colorVar - Current color variable name\n     * @param charVar - Current character variable name (if any)\n     * @param flagsVar - Current flags variable name (if any)\n     * @param rotationVar - Current rotation variable name (if any)\n     * @param args - Processed argument strings\n     * @param currentTarget - Current compilation target\n     * @param nestedColorVar - Nested source color variable (for combine ops)\n     * @param externalRef - External layer reference (if any)\n     * @param getExternalPrefix - Function to get external layer prefix\n     * @returns The transform code result with updated variable names\n     */\n    generateTransformCode(mainCode: string[], def: ProcessedTransform, varId: number, coordVar: string, colorVar: string, charVar: string | undefined, flagsVar: string | undefined, rotationVar: string | undefined, args: string[], currentTarget: CompilationTarget, nestedColorVar?: string, externalRef?: ExternalLayerReference, getExternalPrefix?: (layerId: string) => string): TransformCodeResult;\n    /**\n     * Generate GLSL function for external layer src().\n     */\n    private _generateExternalSrcFunction;\n    /**\n     * Generate GLSL function for self-feedback src().\n     */\n    private _generateSelfFeedbackSrcFunction;\n}\n//# sourceMappingURL=TransformCodeGenerator.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/compiler/types.d.ts": "/**\n * Compiler types and interfaces.\n */\nimport type { SynthUniform, SynthContext, CharacterMapping } from '../core/types';\n/**\n * Compilation target context determining which texture `src()` samples from.\n *\n * - `char`: Compiling a character source chain  src() samples prevCharBuffer\n * - `charColor`: Compiling a character color chain  src() samples prevCharColorBuffer\n * - `cellColor`: Compiling a cell color chain  src() samples prevCellColorBuffer\n * - `main`: Compiling the main chain  src() samples prevCharColorBuffer\n */\nexport type CompilationTarget = 'char' | 'charColor' | 'cellColor' | 'main';\n/**\n * Information about an external layer reference used in the shader.\n * Tracks which textures from the external layer are sampled.\n */\nexport interface ExternalLayerInfo {\n    /** Unique identifier for this external layer in the shader */\n    layerId: string;\n    /** Uniform prefix for this layer's samplers (e.g., 'extLayer0') */\n    uniformPrefix: string;\n    /** Whether the character texture is sampled */\n    usesChar: boolean;\n    /** Whether the primary color texture is sampled */\n    usesCharColor: boolean;\n    /** Whether the cell color texture is sampled */\n    usesCellColor: boolean;\n}\n/**\n * Result of compiling a SynthSource.\n */\nexport interface CompiledSynthShader {\n    /** Complete fragment shader source */\n    fragmentSource: string;\n    /** Uniform definitions with their values/updaters */\n    uniforms: Map<string, SynthUniform>;\n    /** Dynamic uniform updaters keyed by uniform name */\n    dynamicUpdaters: Map<string, (ctx: SynthContext) => number | number[]>;\n    /** Character mapping if charMap was used */\n    charMapping?: CharacterMapping;\n    /** Whether this shader uses character color feedback (src) - reads from prevCharColorBuffer */\n    usesCharColorFeedback: boolean;\n    /** Whether this shader uses character feedback (src) - reads from prevCharBuffer */\n    usesCharFeedback: boolean;\n    /** Whether this shader uses cell color feedback (src) - reads from prevCellColorBuffer */\n    usesCellColorFeedback: boolean;\n    /** Whether this shader uses char() function for character indices */\n    usesCharSource: boolean;\n    /** External layer references used in this shader, keyed by layer ID */\n    externalLayers: Map<string, ExternalLayerInfo>;\n}\n/**\n * Intermediate representation node for a transform.\n */\nexport interface IRNode {\n    /** Transform name */\n    name: string;\n    /** Resolved argument strings (GLSL literals or uniform names) */\n    args: string[];\n    /** Transform type */\n    type: string;\n    /** Reference to nested source result (for combine operations) */\n    nestedColorVar?: string;\n}\n/**\n * Result from compiling a chain.\n */\nexport interface ChainCompilationResult {\n    /** Current coordinate variable name */\n    coordVar: string;\n    /** Current color variable name */\n    colorVar: string;\n    /** Character output variable (if any) */\n    charVar?: string;\n    /** Flags variable (if any) */\n    flagsVar?: string;\n    /** Rotation variable (if any) */\n    rotationVar?: string;\n}\n/**\n * Context for code generation.\n */\nexport interface GenerationContext {\n    /** Counter for unique variable names */\n    varCounter: number;\n    /** Accumulated GLSL function definitions */\n    glslFunctions: Set<string>;\n    /** Accumulated main code lines */\n    mainCode: string[];\n    /** Collected uniforms */\n    uniforms: Map<string, SynthUniform>;\n    /** Dynamic uniform updaters */\n    dynamicUpdaters: Map<string, (ctx: SynthContext) => number | number[]>;\n}\n//# sourceMappingURL=types.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/compiler/UniformManager.d.ts": "import type { SynthParameterValue, SynthContext, SynthUniform } from '../core/types';\nimport type { TransformInput } from '../transforms/TransformDefinition';\n/**\n * Result of processing a single argument.\n */\nexport interface ProcessedArgument {\n    /** GLSL code to use in function call */\n    glslValue: string;\n    /** Uniform created (if any) */\n    uniform?: SynthUniform;\n    /** Dynamic updater (if any) */\n    updater?: (ctx: SynthContext) => number | number[];\n}\n/**\n * Handles uniform extraction and management.\n *\n * This module processes transform arguments and creates uniform\n * definitions for dynamic values that need to be updated each frame.\n */\nexport declare class UniformManager {\n    private readonly _uniforms;\n    private readonly _dynamicUpdaters;\n    /**\n     * Process an argument and return its GLSL representation.\n     */\n    processArgument(value: SynthParameterValue, input: TransformInput, prefix: string): ProcessedArgument;\n    /**\n     * Process default value for an input.\n     */\n    private processDefault;\n    /**\n     * Get all collected uniforms.\n     */\n    getUniforms(): Map<string, SynthUniform>;\n    /**\n     * Get all dynamic updaters.\n     */\n    getDynamicUpdaters(): Map<string, (ctx: SynthContext) => number | number[]>;\n    /**\n     * Clear all collected data.\n     */\n    clear(): void;\n}\n/**\n * Format a number for GLSL (ensure decimal point for floats).\n */\nexport declare function formatNumber(n: number): string;\n//# sourceMappingURL=UniformManager.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/core/GlobalState.d.ts": "/**\n * Global state for textmode.synth.js.\n *\n * This module maintains global configuration that affects all layers,\n * such as the master BPM for array modulation timing.\n */\n/**\n * Set the global BPM for all layers.\n *\n * This sets the master tempo for array cycling. Layers will use this value\n * unless they have a layer-specific BPM set via layer.bpm().\n *\n * @param value - BPM value (beats per minute)\n *\n * \n */\nexport declare function setGlobalBpm(value: number): void;\n/**\n * Get the current global BPM.\n * @returns Current global BPM value\n */\nexport declare function getGlobalBpm(): number;\n//# sourceMappingURL=GlobalState.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/core/index.d.ts": "/**\n * Core module exports.\n *\n * Provides the core types, classes, and state management for the synth engine.\n *\n * @module\n */\nexport * from './types';\nexport { SynthChain, type TransformRecord } from './SynthChain';\nexport { SynthSource } from './SynthSource';\nexport type { ISynthSource } from './ISynthSource';\nexport { setGlobalBpm, getGlobalBpm } from './GlobalState';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/core/ISynthSource.d.ts": "import type { SynthParameterValue } from './types';\n/**\n * Interface defining all chainable methods available on SynthSource.\n *\n * This interface serves as the authoritative documentation for all\n * synthesis methods.\n */\nexport interface ISynthSource {\n    /**\n     * Map character indices to a specific character set.\n     * This is the primary textmode-native way to define which characters to use.\n     *\n     * @param chars A string of characters to map indices to\n     * @returns The SynthSource for chaining\n     *\n     * \n     */\n    charMap(chars: string): this;\n    /**\n     * Set the character foreground color using a color source chain.\n     *\n     * @param source A SynthSource producing color values, or RGBA values\n     * @returns The SynthSource for chaining\n     *\n     * \n     */\n    charColor(source: ISynthSource): this;\n    /**\n     * Set the cell background colors using a color source chain.\n     *\n     * @param source A SynthSource producing color values, or RGBA values\n     * @returns The SynthSource for chaining\n     *\n     * \n     */\n    cellColor(source: ISynthSource): this;\n    /**\n     * Set the character indices using a character source chain.\n     * The number of characters is determined by `charMap()` if defined,\n     * otherwise falls back to the total characters in the layer's font.\n     *\n     * @param source A synth source producing character indices\n     * @returns The SynthSource for chaining\n     *\n     * \n     */\n    char(source: ISynthSource): this;\n    /**\n     * Set both character foreground and cell background color using the same source chain.\n     * This is a convenience method that combines `.charColor()` and `.cellColor()` in one call.\n     *\n     * After calling `paint()`, you can still override the cell color separately using `.cellColor()`.\n     *\n     * Otherwise useful for pixel art styles where both colors are the same, making the characters redundant.\n     *\n     * @param source A SynthSource producing color values\n     * @returns The SynthSource for chaining\n     *\n     * \n     */\n    paint(source: ISynthSource): this;\n    /**\n     * Create a deep clone of this SynthSource.\n     * Useful when you want to create a modified version of an existing chain\n     * without affecting the original.\n     *\n     * @returns A new SynthSource with the same transform chain\n     *\n     * \n     */\n    clone(): ISynthSource;\n    /**\n     * Generate oscillating patterns using sine waves.\n     * @param frequency - Frequency of the oscillation (default: 60.0)\n     * @param sync - Synchronization offset (default: 0.1)\n     * @param offset - Phase offset (default: 0.0)\n     */\n    osc(frequency?: SynthParameterValue, sync?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Generate Perlin noise patterns.\n     * @param scale - Scale of the noise pattern (default: 10.0)\n     * @param speed - Animation speed (default: 0.1)\n     */\n    noise(scale?: SynthParameterValue, speed?: SynthParameterValue): this;\n    /**\n     * Generate voronoi patterns.\n     * @param scale - Scale of voronoi cells (default: 5.0)\n     * @param speed - Animation speed (default: 0.3)\n     * @param blending - Blending between cell regions (default: 0.3)\n     */\n    voronoi(scale?: SynthParameterValue, speed?: SynthParameterValue, blending?: SynthParameterValue): this;\n    /**\n     * Generate a rotating radial gradient.\n     * @param speed - Rotation speed (default: 0.0)\n     *\n     * \n     */\n    gradient(speed?: SynthParameterValue): this;\n    /**\n     * Generate geometric shapes (polygons).\n     * @param sides - Number of sides (default: 3)\n     * @param radius - Radius of the shape (default: 0.3)\n     * @param smoothing - Edge smoothing amount (default: 0.01)\n     */\n    shape(sides?: SynthParameterValue, radius?: SynthParameterValue, smoothing?: SynthParameterValue): this;\n    /**\n     * Generate a solid color.\n     * @param r - Red channel (0-1, default: 0.0)\n     * @param g - Green channel (0-1, default: 0.0)\n     * @param b - Blue channel (0-1, default: 0.0)\n     * @param a - Alpha channel (0-1, default: 1.0)\n     */\n    solid(r?: SynthParameterValue, g?: SynthParameterValue, b?: SynthParameterValue, a?: SynthParameterValue): this;\n    /**\n     * Sample the previous frame for feedback effects, or sample from another layer.\n     *\n     * **Self-feedback (no argument):** `src()` samples the current layer's previous frame.\n     * The sampled texture is context-aware based on where it's used in the synth chain:\n     *\n     * - Inside `char(...)`  samples previous frame's character data\n     * - Inside `charColor(...)`  samples previous frame's primary color (character foreground)\n     * - Inside `cellColor(...)`  samples previous frame's cell color (character background)\n     * - Outside all three  samples previous frame's primary color\n     *\n     * **Cross-layer sampling (with layer argument):** `src(layer)` samples from another\n     * layer's output, enabling hydra-style multi-output compositions. The sampled texture\n     * is still context-aware based on the current compilation target.\n     *\n     * This is the core of feedback loops and multi-layer compositions - enabling effects\n     * like trails, motion blur, recursive patterns, and complex layered visuals.\n     * Equivalent to hydra's `src(o0)`.\n     *\n     * @param layer - Optional TextmodeLayer to sample from. If omitted, samples from self (feedback).\n     *\n     * \n     */\n    src(layer?: unknown): this;\n    /**\n     * Rotate coordinates.\n     * @param angle - Rotation angle in radians (default: 10.0)\n     * @param speed - Rotation speed multiplier (default: 0.0)\n     *\n     * \n     */\n    rotate(angle?: SynthParameterValue, speed?: SynthParameterValue): this;\n    /**\n     * Scale coordinates.\n     * @param amount - Scale amount (default: 1.5)\n     * @param xMult - X axis multiplier (default: 1.0)\n     * @param yMult - Y axis multiplier (default: 1.0)\n     * @param offsetX - X offset (default: 0.5)\n     * @param offsetY - Y offset (default: 0.5)\n     *\n     * \n     */\n    scale(amount?: SynthParameterValue, xMult?: SynthParameterValue, yMult?: SynthParameterValue, offsetX?: SynthParameterValue, offsetY?: SynthParameterValue): this;\n    /**\n     * Scroll coordinates in both X and Y directions.\n     * @param scrollX - X scroll amount (default: 0.5)\n     * @param scrollY - Y scroll amount (default: 0.5)\n     * @param speedX - X scroll speed (default: 0.0)\n     * @param speedY - Y scroll speed (default: 0.0)\n     *\n     * \n     */\n    scroll(scrollX?: SynthParameterValue, scrollY?: SynthParameterValue, speedX?: SynthParameterValue, speedY?: SynthParameterValue): this;\n    /**\n     * Scroll coordinates in X direction.\n     * @param scrollX - X scroll amount (default: 0.5)\n     * @param speed - Scroll speed (default: 0.0)\n     */\n    scrollX(scrollX?: SynthParameterValue, speed?: SynthParameterValue): this;\n    /**\n     * Scroll coordinates in Y direction.\n     * @param scrollY - Y scroll amount (default: 0.5)\n     * @param speed - Scroll speed (default: 0.0)\n     */\n    scrollY(scrollY?: SynthParameterValue, speed?: SynthParameterValue): this;\n    /**\n     * Pixelate the output.\n     * @param pixelX - Pixel size in X (default: 20.0)\n     * @param pixelY - Pixel size in Y (default: 20.0)\n     *\n     * \n     */\n    pixelate(pixelX?: SynthParameterValue, pixelY?: SynthParameterValue): this;\n    /**\n     * Repeat coordinates in both X and Y directions.\n     * @param repeatX - Number of X repetitions (default: 3.0)\n     * @param repeatY - Number of Y repetitions (default: 3.0)\n     * @param offsetX - X offset between repetitions (default: 0.0)\n     * @param offsetY - Y offset between repetitions (default: 0.0)\n     *\n     * \n     */\n    repeat(repeatX?: SynthParameterValue, repeatY?: SynthParameterValue, offsetX?: SynthParameterValue, offsetY?: SynthParameterValue): this;\n    /**\n     * Repeat coordinates in X direction.\n     * @param reps - Number of repetitions (default: 3.0)\n     * @param offset - Offset between repetitions (default: 0.0)\n     */\n    repeatX(reps?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Repeat coordinates in Y direction.\n     * @param reps - Number of repetitions (default: 3.0)\n     * @param offset - Offset between repetitions (default: 0.0)\n     */\n    repeatY(reps?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Apply kaleidoscope effect.\n     * @param nSides - Number of kaleidoscope sides (default: 4.0)\n     *\n     * \n     */\n    kaleid(nSides?: SynthParameterValue): this;\n    /**\n     * Adjust brightness.\n     * @param amount - Brightness adjustment amount (default: 0.4)\n     *\n     * \n     */\n    brightness(amount?: SynthParameterValue): this;\n    /**\n     * Adjust contrast.\n     * @param amount - Contrast amount (default: 1.6)\n     *\n     * \n     */\n    contrast(amount?: SynthParameterValue): this;\n    /**\n     * Invert colors.\n     * @param amount - Inversion amount (default: 1.0)\n     *\n     * \n     */\n    invert(amount?: SynthParameterValue): this;\n    /**\n     * Adjust color saturation.\n     * @param amount - Saturation amount (default: 2.0)\n     *\n     * \n     */\n    saturate(amount?: SynthParameterValue): this;\n    /**\n     * Shift hue.\n     * @param hue - Hue shift amount (default: 0.4)\n     *\n     * \n     */\n    hue(hue?: SynthParameterValue): this;\n    /**\n     * Apply colorama effect (hue rotation based on luminance).\n     * @param amount - Effect amount (default: 0.005)\n     *\n     * \n     */\n    colorama(amount?: SynthParameterValue): this;\n    /**\n     * Posterize colors to limited palette.\n     * @param bins - Number of color bins (default: 3.0)\n     * @param gamma - Gamma correction (default: 0.6)\n     *\n     * \n     */\n    posterize(bins?: SynthParameterValue, gamma?: SynthParameterValue): this;\n    /**\n     * Apply threshold based on luminance.\n     * @param threshold - Threshold value (default: 0.5)\n     * @param tolerance - Tolerance range (default: 0.1)\n     *\n     * \n     */\n    luma(threshold?: SynthParameterValue, tolerance?: SynthParameterValue): this;\n    /**\n     * Apply hard threshold.\n     * @param threshold - Threshold value (default: 0.5)\n     * @param tolerance - Tolerance range (default: 0.04)\n     */\n    thresh(threshold?: SynthParameterValue, tolerance?: SynthParameterValue): this;\n    /**\n     * Colorize a grayscale source or multiply an existing color source.\n     *\n     * This is the recommended way to add color to grayscale sources like `osc()`,\n     * `noise()`, or `voronoi()`.\n     *\n     * @param r - Red channel multiplier (default: 1.0)\n     * @param g - Green channel multiplier (default: 1.0)\n     * @param b - Blue channel multiplier (default: 1.0)\n     * @param a - Alpha channel multiplier (default: 1.0)\n     *\n     * \n     */\n    color(r?: SynthParameterValue, g?: SynthParameterValue, b?: SynthParameterValue, a?: SynthParameterValue): this;\n    /**\n     * Extract the red channel as a grayscale value.\n     * @param scale - Scale multiplier (default: 1.0)\n     * @param offset - Offset amount (default: 0.0)\n     *\n     * \n     */\n    r(scale?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Extract the green channel as a grayscale value.\n     * @param scale - Scale multiplier (default: 1.0)\n     * @param offset - Offset amount (default: 0.0)\n     *\n     * \n     */\n    g(scale?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Extract the blue channel as a grayscale value.\n     * @param scale - Scale multiplier (default: 1.0)\n     * @param offset - Offset amount (default: 0.0)\n     *\n     * \n     */\n    b(scale?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Shift color channels by adding offset values.\n     * @param r - Red channel shift (default: 0.5)\n     * @param g - Green channel shift (default: 0.0)\n     * @param b - Blue channel shift (default: 0.0)\n     * @param a - Alpha channel shift (default: 0.0)\n     */\n    shift(r?: SynthParameterValue, g?: SynthParameterValue, b?: SynthParameterValue, a?: SynthParameterValue): this;\n    /**\n     * Apply gamma correction for nonlinear brightness control.\n     * @param amount - Gamma value (default: 1.0, < 1.0 brightens, > 1.0 darkens)\n     *\n     * \n     */\n    gamma(amount?: SynthParameterValue): this;\n    /**\n     * Adjust input/output levels and gamma for precise tonal control.\n     * @param inMin - Input minimum (default: 0.0)\n     * @param inMax - Input maximum (default: 1.0)\n     * @param outMin - Output minimum (default: 0.0)\n     * @param outMax - Output maximum (default: 1.0)\n     * @param gamma - Gamma correction (default: 1.0)\n     *\n     * \n     */\n    levels(inMin?: SynthParameterValue, inMax?: SynthParameterValue, outMin?: SynthParameterValue, outMax?: SynthParameterValue, gamma?: SynthParameterValue): this;\n    /**\n     * Clamp color values to a specified range for stability.\n     * @param min - Minimum value (default: 0.0)\n     * @param max - Maximum value (default: 1.0)\n     *\n     * \n     */\n    clamp(min?: SynthParameterValue, max?: SynthParameterValue): this;\n    /**\n     * Add another source.\n     * @param source - Source to add\n     * @param amount - Blend amount (default: 0.5)\n     *\n     * \n     */\n    add(source: ISynthSource, amount?: SynthParameterValue): this;\n    /**\n     * Subtract another source.\n     * @param source - Source to subtract\n     * @param amount - Blend amount (default: 0.5)\n     */\n    sub(source: ISynthSource, amount?: SynthParameterValue): this;\n    /**\n     * Multiply with another source.\n     * @param source - Source to multiply\n     * @param amount - Blend amount (default: 0.5)\n     */\n    mult(source: ISynthSource, amount?: SynthParameterValue): this;\n    /**\n     * Blend with another source.\n     * @param source - Source to blend\n     * @param amount - Blend amount (default: 0.5)\n     *\n     * \n     */\n    blend(source: ISynthSource, amount?: SynthParameterValue): this;\n    /**\n     * Difference with another source.\n     * @param source - Source to compare\n     *\n     * \n     */\n    diff(source: ISynthSource): this;\n    /**\n     * Layer another source on top.\n     * @param source - Source to layer\n     *\n     * \n     */\n    layer(source: ISynthSource): this;\n    /**\n     * Mask using another source.\n     * @param source - Source to use as mask\n     *\n     * \n     */\n    mask(source: ISynthSource): this;\n    /**\n     * Modulate coordinates using another source.\n     * @param source - Modulation source\n     * @param amount - Modulation amount (default: 0.1)\n     *\n     * \n     */\n    modulate(source: ISynthSource, amount?: SynthParameterValue): this;\n    /**\n     * Modulate scale using another source.\n     * @param source - Modulation source\n     * @param multiple - Scale multiplier (default: 1.0)\n     * @param offset - Offset amount (default: 1.0)\n     */\n    modulateScale(source: ISynthSource, multiple?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Modulate rotation using another source.\n     * @param source - Modulation source\n     * @param multiple - Rotation multiplier (default: 1.0)\n     * @param offset - Offset amount (default: 0.0)\n     */\n    modulateRotate(source: ISynthSource, multiple?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Modulate pixelation using another source.\n     * @param source - Modulation source\n     * @param multiple - Pixelation multiplier (default: 10.0)\n     * @param offset - Offset amount (default: 3.0)\n     *\n     * \n     */\n    modulatePixelate(source: ISynthSource, multiple?: SynthParameterValue, offset?: SynthParameterValue): this;\n    /**\n     * Modulate kaleidoscope using another source.\n     * @param source - Modulation source\n     * @param nSides - Number of sides (default: 4.0)\n     *\n     * \n     */\n    modulateKaleid(source: ISynthSource, nSides?: SynthParameterValue): this;\n    /**\n     * Modulate X scroll using another source.\n     * @param source - Modulation source\n     * @param scrollX - X scroll amount (default: 0.5)\n     * @param speed - Scroll speed (default: 0.0)\n     */\n    modulateScrollX(source: ISynthSource, scrollX?: SynthParameterValue, speed?: SynthParameterValue): this;\n    /**\n     * Modulate Y scroll using another source.\n     * @param source - Modulation source\n     * @param scrollY - Y scroll amount (default: 0.5)\n     * @param speed - Scroll speed (default: 0.0)\n     */\n    modulateScrollY(source: ISynthSource, scrollY?: SynthParameterValue, speed?: SynthParameterValue): this;\n    /**\n     * Add a transform to the chain.\n     * @ignore\n     */\n    addTransform(name: string, userArgs: SynthParameterValue[]): this;\n    /**\n     * Add a combine transform that references another source.\n     * @ignore\n     */\n    addCombineTransform(name: string, source: ISynthSource, userArgs: SynthParameterValue[]): this;\n    /**\n     * Add an external layer reference at the current transform index.\n     * @ignore\n     */\n    addExternalLayerRef(ref: unknown): this;\n}\n//# sourceMappingURL=ISynthSource.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/core/SynthChain.d.ts": "import type { SynthParameterValue } from './types';\n/**\n * A recorded transform in the synthesis chain.\n */\nexport interface TransformRecord {\n    /** Transform function name */\n    name: string;\n    /** User-provided arguments */\n    userArgs: SynthParameterValue[];\n}\n/**\n * A mutable chain of transform records for the fluent API.\n * While the internal implementation is mutable for compatibility with the\n * existing fluent API, the returned readonly arrays provide a consistent view.\n */\nexport declare class SynthChain {\n    /** The transforms in this chain */\n    private _transforms;\n    /**\n     * Create a new SynthChain with the given transforms.\n     */\n    private constructor();\n    /**\n     * Create an empty chain.\n     */\n    static empty(): SynthChain;\n    /**\n     * Create a chain from existing transforms.\n     */\n    static from(transforms: readonly TransformRecord[]): SynthChain;\n    /**\n     * Get all transforms in this chain (readonly view).\n     */\n    get transforms(): readonly TransformRecord[];\n    /**\n     * Push a transform to this chain (internal mutation).\n     */\n    push(record: TransformRecord): void;\n    /**\n     * Get the number of transforms in this chain.\n     */\n    get length(): number;\n    /**\n     * Check if the chain is empty.\n     */\n    get isEmpty(): boolean;\n    /**\n     * Append a transform to this chain, returning a new chain.\n     */\n    append(record: TransformRecord): SynthChain;\n    /**\n     * Get a transform at a specific index.\n     */\n    get(index: number): TransformRecord | undefined;\n    /**\n     * Create an iterator over the transforms.\n     */\n    [Symbol.iterator](): Iterator<TransformRecord>;\n}\n//# sourceMappingURL=SynthChain.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/core/SynthSource.d.ts": "import type { SynthParameterValue, CharacterMapping, ExternalLayerReference } from './types';\nimport { SynthChain, type TransformRecord } from './SynthChain';\nimport type { ISynthSource } from './ISynthSource';\nexport interface SynthSource extends ISynthSource {\n}\n/**\n * Options for creating a new SynthSource.\n */\ninterface SynthSourceCreateOptions {\n    chain?: SynthChain;\n    charMapping?: CharacterMapping;\n    colorSource?: SynthSource;\n    cellColorSource?: SynthSource;\n    charSource?: SynthSource;\n    nestedSources?: Map<number, SynthSource>;\n    externalLayerRefs?: Map<number, ExternalLayerReference>;\n}\n/**\n * A chainable synthesis source that accumulates transforms to be compiled into a shader.\n *\n * This is the core class that enables hydra-like method chaining for\n * generating procedural textmode visuals. Each method call adds a\n * transform to the chain, which is later compiled into a GLSL shader.\n *\n * \n */\nexport declare class SynthSource {\n    /** The immutable chain of transforms */\n    private readonly _chain;\n    /** Character mapping for charMap transform */\n    private _charMapping?;\n    /** Nested sources for combine operations (indexed by transform position) */\n    private readonly _nestedSources;\n    /** External layer references for cross-layer sampling (indexed by transform position) */\n    private readonly _externalLayerRefs;\n    /** Reference to the color source chain (if any) */\n    private _colorSource?;\n    /** Reference to the cell color source chain (if any) */\n    private _cellColorSource?;\n    /** Reference to the character source chain (if any) - used by char() function */\n    private _charSource?;\n    /**\n     * Create a new SynthSource.\n     * @param options Optional initialization options\n     * @ignore Use generator functions like `osc()`, `noise()` instead\n     */\n    constructor(options?: SynthSourceCreateOptions);\n    /**\n     * Add a transform to the chain.\n     * This method is called by dynamically injected transform methods.\n     * @ignore\n     */\n    addTransform(name: string, userArgs: SynthParameterValue[]): this;\n    /**\n     * Add a combine transform that references another source.\n     * @ignore\n     */\n    addCombineTransform(name: string, source: SynthSource, userArgs: SynthParameterValue[]): this;\n    /**\n     * Add an external layer reference at the current transform index.\n     * Used by src(layer) to track cross-layer sampling.\n     * @ignore\n     */\n    addExternalLayerRef(ref: ExternalLayerReference): this;\n    charMap(chars: string): this;\n    charColor(source: SynthSource): this;\n    char(source: SynthSource): this;\n    cellColor(source: SynthSource): this;\n    paint(source: SynthSource): this;\n    clone(): SynthSource;\n    /**\n     * Get the transform records.\n     * @ignore\n     */\n    get transforms(): readonly TransformRecord[];\n    /**\n     * Get the character mapping if defined.\n     * @ignore\n     */\n    get charMapping(): CharacterMapping | undefined;\n    /**\n     * Get the color source if defined.\n     * @ignore\n     */\n    get colorSource(): SynthSource | undefined;\n    /**\n     * Get the cell color source if defined.\n     * @ignore\n     */\n    get cellColorSource(): SynthSource | undefined;\n    /**\n     * Get the character source if defined (from char() function).\n     * @ignore\n     */\n    get charSource(): SynthSource | undefined;\n    /**\n     * Get all nested sources for combine operations.\n     * @ignore\n     */\n    get nestedSources(): Map<number, SynthSource>;\n    /**\n     * Get all external layer references for cross-layer sampling.\n     * @ignore\n     */\n    get externalLayerRefs(): Map<number, ExternalLayerReference>;\n}\nexport {};\n//# sourceMappingURL=SynthSource.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/core/types.d.ts": "/**\n * Core types for the textmode.js synthesis system.\n *\n * This module contains foundational type definitions used throughout\n * the synth engine, including transform types, parameter values,\n * context interfaces, and shader compilation types.\n */\nimport type { TextmodeFramebuffer, TextmodeShader } from 'textmode.js';\nimport type { TextmodeLayer } from 'textmode.js/layering';\nimport type { SynthSource } from './SynthSource';\nimport type { CompiledSynthShader } from '../compiler/types';\nimport type { CharacterResolver } from '../utils/CharacterResolver';\n/**\n * Transform type categories determining how functions compose in the shader pipeline.\n *\n * Each type has specific input/output signatures:\n * - `src`: Source generators that produce colors from UV coordinates\n * - `coord`: Coordinate transforms that modify UV before sampling\n * - `color`: Color transforms that modify existing color values\n * - `combine`: Blending operations that combine two color sources\n * - `combineCoord`: Modulation that uses one source to affect another's coordinates\n */\nexport type SynthTransformType = 'src' | 'coord' | 'color' | 'combine' | 'combineCoord';\n/**\n * GLSL type for transform inputs.\n */\nexport type GLSLType = 'float' | 'vec2' | 'vec3' | 'vec4' | 'int' | 'sampler2D';\n/**\n * Input parameter definition for a transform function.\n */\nexport interface TransformInput {\n    /** Parameter name used in GLSL and JS API */\n    name: string;\n    /** GLSL type */\n    type: GLSLType;\n    /** Default value if not provided */\n    default: number | number[] | null;\n}\n/**\n * Dynamic parameter value types supported by the synth system.\n *\n * - `number`: Static numeric value\n * - `number[]`: Array of numbers for vector types or modulated arrays (hydra-like)\n * - `string`: String value (rarely used)\n * - `function`: Evaluated each frame with context\n * - `SynthSource`: Nested synth chain for combine/modulate operations\n * - `null`: Use default value\n */\nexport type SynthParameterValue = number | number[] | string | ((ctx: SynthContext) => number) | ((ctx: SynthContext) => number[]) | SynthSource | null;\n/**\n * Context passed to dynamic parameter functions during rendering.\n *\n * \n */\nexport interface SynthContext {\n    /** Current time in seconds */\n    time: number;\n    /** Current frame count */\n    frameCount: number;\n    /** Grid width in pixels */\n    width: number;\n    /** Grid height in pixels */\n    height: number;\n    /** Grid columns */\n    cols: number;\n    /** Grid rows */\n    rows: number;\n    /** Current BPM (beats per minute) for array modulation timing */\n    bpm: number;\n}\n/**\n * Per-layer synth state stored via plugin state API.\n */\nexport interface LayerSynthState {\n    /** The original SynthSource */\n    source: SynthSource;\n    /** Compiled shader data */\n    compiled?: CompiledSynthShader;\n    /** The compiled GLShader instance */\n    shader?: TextmodeShader;\n    /** Character resolver for this layer's synth */\n    characterResolver: CharacterResolver;\n    /** Whether the shader needs to be recompiled */\n    needsCompile: boolean;\n    /**\n     * Ping-pong framebuffers for feedback loops.\n     * pingPongBuffers[0] = buffer A, pingPongBuffers[1] = buffer B\n     */\n    pingPongBuffers?: [TextmodeFramebuffer, TextmodeFramebuffer];\n    /**\n     * Current ping-pong index.\n     * READ from pingPongBuffers[pingPongIndex], WRITE to pingPongBuffers[1 - pingPongIndex].\n     */\n    pingPongIndex: number;\n    /**\n     * External layer references mapped to their layer objects.\n     * Populated during compilation from the source's external layer refs.\n     */\n    externalLayerMap?: Map<string, TextmodeLayer>;\n    /**\n     * Layer-specific BPM override.\n     * If set, this overrides the global BPM for this layer's array modulation.\n     */\n    bpm?: number;\n    /**\n     * Optional callback invoked when dynamic parameter evaluation fails.\n     * Live coding environments can use this to display errors without crashing.\n     *\n     * @param error - The error that was caught\n     * @param uniformName - Name of the uniform whose evaluation failed\n     */\n    onDynamicError?: (error: unknown, uniformName: string) => void;\n}\n/**\n * Character set mapping for charMap transform.\n */\nexport interface CharacterMapping {\n    /** The character string to use */\n    chars: string;\n    /** Pre-computed character code points */\n    indices: number[];\n}\n/**\n * Reference to an external layer for cross-layer sampling.\n * Used by src(layer) to enable hydra-style output references.\n */\nexport interface ExternalLayerReference {\n    /** Unique identifier for the layer (typically layer.id or generated) */\n    layerId: string;\n    /** The layer object reference (opaque to the compiler, used by plugin) */\n    layer: unknown;\n}\n/**\n * Uniform definition for compiled shaders.\n */\nexport interface SynthUniform {\n    /** Uniform name in GLSL */\n    name: string;\n    /** GLSL type */\n    type: GLSLType;\n    /** Current value */\n    value: number | number[];\n    /** Whether this uniform is dynamically updated each frame */\n    isDynamic: boolean;\n}\n/**\n * Return type signature lookup for each transform type.\n */\nexport declare const TRANSFORM_TYPE_INFO: Record<SynthTransformType, {\n    returnType: string;\n    args: Array<{\n        type: string;\n        name: string;\n    }>;\n}>;\n//# sourceMappingURL=types.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/extensions/index.d.ts": "/**\n * Extensions module exports.\n *\n * Provides all plugin extensions for TextmodeLayer and Textmodifier.\n *\n * @module\n */\nexport { extendLayerSynth, extendLayerClearSynth, extendLayerBpm } from './textmodelayer';\nexport { extendTextmodifierBpm } from './textmodifier';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/extensions/textmodelayer.d.ts": "/**\n * TextmodeLayer extensions.\n *\n * Provides synth-related methods on TextmodeLayer instances:\n * - `synth()` - Apply a synth source to the layer\n * - `clearSynth()` - Remove synth from the layer\n * - `bpm()` - Set layer-specific BPM override\n */\nimport type { TextmodePluginAPI } from 'textmode.js/plugins';\n/**\n * Extend layer with synth() method.\n */\nexport declare function extendLayerSynth(api: TextmodePluginAPI): void;\n/**\n * Extend layer with clearSynth() method.\n */\nexport declare function extendLayerClearSynth(api: TextmodePluginAPI): void;\n/**\n * Extend layer with bpm() method.\n */\nexport declare function extendLayerBpm(api: TextmodePluginAPI): void;\n//# sourceMappingURL=textmodelayer.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/extensions/textmodifier.d.ts": "/**\n * Textmodifier extensions.\n *\n * Provides synth-related methods on the main Textmodifier instance:\n * - `bpm()` - Set global BPM for array modulation\n */\n/**\n * Extend textmodifier with bpm() method.\n */\nexport declare function extendTextmodifierBpm(textmodifier: any): void;\n//# sourceMappingURL=textmodifier.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/index.d.ts": "/**\n *\n * A derivative work of [hydra-synth](https://github.com/hydra-synth/hydra-synth) by [Olivia Jack](https://github.com/ojack),\n * adapted for the [textmode.js](https://github.com/humanbydefinition/textmode.js) ecosystem, providing\n * a visual synthesis system for procedural generation of characters, colors,\n * and visual effects through method chaining.\n *\n * \n * @packageDocumentation\n */\nimport './bootstrap';\nimport './augmentations';\nexport { SynthPlugin } from './plugin';\nexport { SynthSource } from './core/SynthSource';\nexport type { SynthParameterValue, SynthContext } from './core/types';\nexport { cellColor, char, charColor, gradient, noise, osc, paint, shape, solid, src, voronoi, } from './api';\nexport type { ModulatedArray, EasingFunction } from './utils/ArrayUtils';\nexport { setGlobalErrorCallback } from './utils/SafeEvaluator';\nexport type { DynamicErrorCallback } from './utils/SafeEvaluator';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/lifecycle/index.d.ts": "/**\n * Lifecycle module exports.\n *\n * Provides lifecycle callbacks for plugin integration with textmode.js.\n *\n * @module\n */\nexport { synthRender } from './synthRender';\nexport { synthDispose } from './synthDispose';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/lifecycle/synthDispose.d.ts": "/**\n * Synth dispose lifecycle callback.\n *\n * Cleans up synth resources when a layer is disposed.\n */\nimport type { TextmodeLayer } from 'textmode.js/layering';\n/**\n * Clean up synth resources when a layer is disposed.\n */\nexport declare function synthDispose(layer: TextmodeLayer): void;\n//# sourceMappingURL=synthDispose.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/lifecycle/synthRender.d.ts": "/**\n * Synth render lifecycle callback.\n *\n * Handles rendering of synth sources with atomic parameter validation\n * to prevent WebGL errors from incomplete uniform state.\n */\nimport type { TextmodeLayer } from 'textmode.js/layering';\n/**\n * Render synth source to layer framebuffers.\n *\n * Uses an atomic render pattern: all dynamic parameters are validated\n * BEFORE any WebGL operations. If any parameter fails, the entire frame\n * is skipped and the error propagates for the environment to handle.\n */\nexport declare function synthRender(layer: TextmodeLayer, textmodifier: any): Promise<void>;\n//# sourceMappingURL=synthRender.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/plugin/constants.d.ts": "/**\n * Plugin constants.\n */\nexport declare const PLUGIN_NAME = \"textmode.synth.js\";\n//# sourceMappingURL=constants.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/plugin/index.d.ts": "/**\n * Plugin module exports.\n *\n * This module provides the main SynthPlugin and related constants.\n *\n * @module\n */\nexport { SynthPlugin } from './SynthPlugin';\nexport { PLUGIN_NAME } from './constants';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/plugin/SynthPlugin.d.ts": "import type { TextmodePlugin } from 'textmode.js/plugins';\n/**\n * The `textmode.synth.js` plugin to install.\n *\n * Install this plugin to enable `.synth()` on TextmodeLayer instances.\n *\n * \n */\nexport declare const SynthPlugin: TextmodePlugin;\n//# sourceMappingURL=SynthPlugin.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/categories/colors.d.ts": "/**\n * Color transform definitions.\n *\n * These transforms modify color output values, enabling effects like\n * brightness, contrast, saturation, hue shifting, and color manipulation.\n */\nimport { type TransformDefinition } from '../TransformDefinition';\nexport declare const brightness: TransformDefinition;\nexport declare const contrast: TransformDefinition;\nexport declare const invert: TransformDefinition;\nexport declare const saturate: TransformDefinition;\nexport declare const hue: TransformDefinition;\nexport declare const colorama: TransformDefinition;\nexport declare const posterize: TransformDefinition;\nexport declare const luma: TransformDefinition;\nexport declare const thresh: TransformDefinition;\nexport declare const color: TransformDefinition;\nexport declare const r: TransformDefinition;\nexport declare const g: TransformDefinition;\nexport declare const b: TransformDefinition;\nexport declare const shift: TransformDefinition;\nexport declare const gamma: TransformDefinition;\nexport declare const levels: TransformDefinition;\nexport declare const clamp: TransformDefinition;\n/**\n * All color transforms.\n */\nexport declare const COLOR_TRANSFORMS: TransformDefinition[];\n//# sourceMappingURL=colors.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/categories/combine.d.ts": "/**\n * Combine transform definitions.\n *\n * These transforms blend two sources together using various\n * blending modes like add, multiply, blend, difference, and layer.\n */\nimport { type TransformDefinition } from '../TransformDefinition';\nexport declare const add: TransformDefinition;\nexport declare const sub: TransformDefinition;\nexport declare const mult: TransformDefinition;\nexport declare const blend: TransformDefinition;\nexport declare const diff: TransformDefinition;\nexport declare const layer: TransformDefinition;\nexport declare const mask: TransformDefinition;\n/**\n * All combine transforms.\n */\nexport declare const COMBINE_TRANSFORMS: TransformDefinition[];\n//# sourceMappingURL=combine.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/categories/combineCoord.d.ts": "/**\n * Combine coordinate transform definitions (modulation).\n *\n * These transforms use one source to modulate the coordinates\n * of another, enabling effects like displacement and warping.\n */\nimport { type TransformDefinition } from '../TransformDefinition';\nexport declare const modulate: TransformDefinition;\nexport declare const modulateScale: TransformDefinition;\nexport declare const modulateRotate: TransformDefinition;\nexport declare const modulatePixelate: TransformDefinition;\nexport declare const modulateKaleid: TransformDefinition;\nexport declare const modulateScrollX: TransformDefinition;\nexport declare const modulateScrollY: TransformDefinition;\nexport declare const modulateRepeat: TransformDefinition;\nexport declare const modulateRepeatX: TransformDefinition;\nexport declare const modulateRepeatY: TransformDefinition;\nexport declare const modulateHue: TransformDefinition;\n/**\n * All combine coordinate transforms.\n */\nexport declare const COMBINE_COORD_TRANSFORMS: TransformDefinition[];\n//# sourceMappingURL=combineCoord.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/categories/coordinates.d.ts": "/**\n * Coordinate transform definitions.\n *\n * These transforms modify UV coordinates before sampling,\n * enabling effects like rotation, scaling, scrolling, and tiling.\n */\nimport { type TransformDefinition } from '../TransformDefinition';\nexport declare const rotate: TransformDefinition;\nexport declare const scale: TransformDefinition;\nexport declare const scroll: TransformDefinition;\nexport declare const scrollX: TransformDefinition;\nexport declare const scrollY: TransformDefinition;\nexport declare const pixelate: TransformDefinition;\nexport declare const repeat: TransformDefinition;\nexport declare const repeatX: TransformDefinition;\nexport declare const repeatY: TransformDefinition;\nexport declare const kaleid: TransformDefinition;\n/**\n * All coordinate transforms.\n */\nexport declare const COORD_TRANSFORMS: TransformDefinition[];\n//# sourceMappingURL=coordinates.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/categories/index.d.ts": "/**\n * Categories index - exports all transform categories.\n */\nexport { SOURCE_TRANSFORMS, osc, noise, voronoi, gradient, shape, solid, src } from './sources';\nexport { COORD_TRANSFORMS, rotate, scale, scroll, scrollX, scrollY, pixelate, repeat, repeatX, repeatY, kaleid, } from './coordinates';\nexport { COLOR_TRANSFORMS, brightness, contrast, invert, saturate, hue, colorama, posterize, luma, thresh, color, r, g, b, } from './colors';\nexport { COMBINE_TRANSFORMS, add, sub, mult, blend, diff, layer, mask } from './combine';\nexport { COMBINE_COORD_TRANSFORMS, modulate, modulateScale, modulateRotate, modulatePixelate, modulateKaleid, modulateScrollX, modulateScrollY, } from './combineCoord';\nimport type { TransformDefinition } from '../TransformDefinition';\n/**\n * All built-in transforms combined.\n */\nexport declare const ALL_TRANSFORMS: TransformDefinition[];\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/categories/sources.d.ts": "/**\n * Source generator transforms.\n *\n * These transforms create base visual patterns from UV coordinates.\n * They are the starting point of most synth chains.\n */\nimport { type TransformDefinition } from '../TransformDefinition';\nexport declare const osc: TransformDefinition;\nexport declare const noise: TransformDefinition;\nexport declare const voronoi: TransformDefinition;\nexport declare const gradient: TransformDefinition;\nexport declare const shape: TransformDefinition;\nexport declare const solid: TransformDefinition;\nexport declare const src: TransformDefinition;\n/**\n * All source generator transforms.\n */\nexport declare const SOURCE_TRANSFORMS: TransformDefinition[];\n//# sourceMappingURL=sources.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/index.d.ts": "/**\n * Transforms module - exports all transform-related functionality.\n */\nexport * from './TransformDefinition';\nexport * from './TransformRegistry';\nexport * from './TransformFactory';\nexport * from './categories';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/TransformDefinition.d.ts": "/**\n * Transform definition types and interfaces.\n *\n * This module provides the base types and helper functions for defining\n * synthesis transforms in a declarative way.\n */\nimport type { SynthTransformType, TransformInput } from '../core/types';\nexport type { TransformInput };\n/**\n * Definition of a synthesis transform function.\n */\nexport interface TransformDefinition {\n    /** Function name (used in JS API and GLSL) */\n    name: string;\n    /** Transform type determining composition behavior */\n    type: SynthTransformType;\n    /** Input parameters */\n    inputs: TransformInput[];\n    /** GLSL function body (without function signature) */\n    glsl: string;\n    /** Optional description for documentation */\n    description?: string;\n}\n/**\n * A processed transform with complete GLSL function.\n */\nexport interface ProcessedTransform extends TransformDefinition {\n    /** Complete GLSL function code */\n    glslFunction: string;\n}\n/**\n * Process a transform definition into a processed transform with complete GLSL function.\n */\nexport declare function processTransform(def: TransformDefinition): ProcessedTransform;\n/**\n * Helper to define a transform with type inference.\n * This makes transform definitions more concise and type-safe.\n */\nexport declare function defineTransform<T extends SynthTransformType>(definition: TransformDefinition & {\n    type: T;\n}): TransformDefinition;\n//# sourceMappingURL=TransformDefinition.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/TransformFactory.d.ts": "import type { TransformDefinition } from './TransformDefinition';\nimport type { SynthParameterValue } from '../core/types';\n/**\n * Interface for the SynthSource class that will have methods injected.\n * This is used to avoid circular dependencies.\n */\nexport interface SynthSourcePrototype {\n    addTransform(name: string, userArgs: SynthParameterValue[]): unknown;\n    addCombineTransform(name: string, source: unknown, userArgs: SynthParameterValue[]): unknown;\n}\n/**\n * Generated standalone functions for source transforms.\n */\nexport interface GeneratedFunctions {\n    [name: string]: (...args: SynthParameterValue[]) => unknown;\n}\n/**\n * Factory for generating dynamic transform methods.\n *\n * Handles the dynamic generation of chainable methods on\n * SynthSource based on registered transform definitions. It eliminates\n * the need to manually write boilerplate methods for each transform.\n */\ndeclare class TransformFactory {\n    private _generatedFunctions;\n    private _synthSourceClass;\n    /**\n     * Set the SynthSource class to inject methods into.\n     * This must be called before injectMethods.\n     */\n    setSynthSourceClass(cls: new () => SynthSourcePrototype): void;\n    /**\n     * Inject chainable methods into the SynthSource prototype.\n     * This dynamically adds all registered transforms as methods.\n     */\n    injectMethods(prototype: SynthSourcePrototype): void;\n    /**\n     * Inject a single method for a transform.\n     */\n    private _injectMethod;\n    /**\n     * Generate standalone functions for source-type transforms.\n     * These allow starting a chain without explicitly creating a SynthSource.\n     */\n    generateStandaloneFunctions(): GeneratedFunctions;\n    /**\n     * Get the generated standalone functions.\n     */\n    getGeneratedFunctions(): GeneratedFunctions;\n    /**\n     * Add a new transform and inject its method.\n     * This can be used to add custom transforms at runtime.\n     */\n    addTransform(transform: TransformDefinition, prototype?: SynthSourcePrototype): void;\n}\n/**\n * Singleton instance of the transform factory.\n */\nexport declare const transformFactory: TransformFactory;\nexport {};\n//# sourceMappingURL=TransformFactory.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/transforms/TransformRegistry.d.ts": "import type { TransformDefinition, ProcessedTransform } from './TransformDefinition';\nimport type { SynthTransformType } from '../core/types';\n/**\n * Centralized registry for synthesis transforms.\n *\n * This module provides a singleton registry for managing transform definitions.\n * Transforms can be registered at startup or dynamically added at runtime,\n * enabling extensibility through user-defined transforms.\n */\ndeclare class TransformRegistry {\n    /** Map of transform name to definition */\n    private readonly _transforms;\n    /** Cache of processed transforms */\n    private readonly _processedCache;\n    /**\n     * Register a transform definition.\n     */\n    register(transform: TransformDefinition): void;\n    /**\n     * Register multiple transform definitions.\n     */\n    registerMany(transforms: TransformDefinition[]): void;\n    /**\n     * Get a transform definition by name.\n     */\n    get(name: string): TransformDefinition | undefined;\n    /**\n     * Get a processed transform by name (cached).\n     */\n    getProcessed(name: string): ProcessedTransform | undefined;\n    /**\n     * Check if a transform is registered.\n     */\n    has(name: string): boolean;\n    /**\n     * Get all transforms of a specific type.\n     */\n    getByType(type: SynthTransformType): TransformDefinition[];\n    /**\n     * Get all registered transform names.\n     */\n    getNames(): string[];\n    /**\n     * Get all registered transforms.\n     */\n    getAll(): TransformDefinition[];\n    /**\n     * Get source-type transforms (those that can start a chain).\n     */\n    getSourceTransforms(): TransformDefinition[];\n    /**\n     * Remove a transform from the registry.\n     */\n    remove(name: string): boolean;\n    /**\n     * Clear all transforms (mainly for testing).\n     */\n    clear(): void;\n    /**\n     * Get the count of registered transforms.\n     */\n    get size(): number;\n}\n/**\n * Singleton instance of the transform registry.\n */\nexport declare const transformRegistry: TransformRegistry;\nexport {};\n//# sourceMappingURL=TransformRegistry.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/utils/ArrayUtils.d.ts": "/**\n * ArrayUtils - Hydra-style array modulation utilities.\n *\n * Provides methods for arrays to modulate values over time,\n * similar to Hydra's array functionality.\n */\nimport type { SynthContext } from '../core/types';\n/**\n * Easing functions from https://gist.github.com/gre/1650294\n */\nexport declare const EASING_FUNCTIONS: {\n    linear: (t: number) => number;\n    easeInQuad: (t: number) => number;\n    easeOutQuad: (t: number) => number;\n    easeInOutQuad: (t: number) => number;\n    easeInCubic: (t: number) => number;\n    easeOutCubic: (t: number) => number;\n    easeInOutCubic: (t: number) => number;\n    easeInQuart: (t: number) => number;\n    easeOutQuart: (t: number) => number;\n    easeInOutQuart: (t: number) => number;\n    easeInQuint: (t: number) => number;\n    easeOutQuint: (t: number) => number;\n    easeInOutQuint: (t: number) => number;\n    sin: (t: number) => number;\n};\n/**\n * Easing functions from https://gist.github.com/gre/1650294\n *\n * Available easing functions: `'linear'`, `'easeInQuad'`, `'easeOutQuad'`, `'easeInOutQuad'`,\n * `'easeInCubic'`, `'easeOutCubic'`, `'easeInOutCubic'`, `'easeInQuart'`, `'easeOutQuart'`,\n * `'easeInOutQuart'`, `'easeInQuint'`, `'easeOutQuint'`, `'easeInOutQuint'`, `'sin'`\n *\n * \n */\nexport type EasingFunction = keyof typeof EASING_FUNCTIONS | ((t: number) => number);\n/**\n * Extended array interface with modulation methods.\n *\n * Arrays in textmode.synth.js behave like hydra - they cycle through values over time,\n * creating dynamic, time-varying parameters. This enables complex animations without\n * manually tracking time or state.\n *\n * \n */\nexport interface ModulatedArray extends Array<number> {\n    /** Speed multiplier for array cycling @ignore */\n    _speed?: number;\n    /** Smoothing amount (0-1) for interpolation @ignore */\n    _smooth?: number;\n    /** Easing function for interpolation @ignore */\n    _ease?: (t: number) => number;\n    /** Time offset for array cycling @ignore */\n    _offset?: number;\n    /**\n     * Set speed multiplier for array cycling.\n     *\n     * Controls how fast the array cycles through its values over time.\n     * A speed of 1 is the default rate. Values > 1 cycle faster, values < 1 cycle slower.\n     *\n     * @param speed - Speed multiplier (default: 1)\n     * @returns The array for chaining\n     *\n     * \n     */\n    fast(speed: number): this;\n    /**\n     * Enable smooth interpolation between array values.\n     *\n     * Instead of jumping from one value to the next, smooth() creates gradual\n     * transitions. The amount parameter controls the smoothing duration.\n     * When amount is 1 (default), smoothing is applied across the full transition.\n     *\n     * @param amount - Smoothing amount 0-1 (default: 1)\n     * @returns The array for chaining\n     *\n     * \n     */\n    smooth(amount?: number): this;\n    /**\n     * Apply easing function to interpolation between array values.\n     *\n     * Easing controls the acceleration curve of transitions between values.\n     * Automatically enables smoothing when applied. Use built-in easing names\n     * or provide a custom function that takes a value 0-1 and returns 0-1.\n     *\n     * Available easing functions: `'linear'`, `'easeInQuad'`, `'easeOutQuad'`,\n     * `'easeInOutQuad'`, `'easeInCubic'`, `'easeOutCubic'`, `'easeInOutCubic'`,\n     * `'easeInQuart'`, `'easeOutQuart'`, `'easeInOutQuart'`, `'easeInQuint'`,\n     * `'easeOutQuint'`, `'easeInOutQuint'`, `'sin'`\n     *\n     * @param ease - Easing function name or custom function (default: 'linear')\n     * @returns The array for chaining\n     *\n     * \n     */\n    ease(ease: EasingFunction): this;\n    /**\n     * Set time offset for array cycling.\n     *\n     * Shifts when the array starts cycling through its values.\n     * Useful for creating phase-shifted animations where multiple arrays\n     * cycle with the same speed but at different times.\n     *\n     * The offset wraps around at 1.0, so offset(0.5) starts halfway through\n     * the cycle, and offset(1.5) is equivalent to offset(0.5).\n     *\n     * @param offset - Time offset 0-1, wraps at 1.0 (default: 0)\n     * @returns The array for chaining\n     *\n     * \n     */\n    offset(offset: number): this;\n    /**\n     * Fit (remap) array values to a new range.\n     *\n     * Takes the minimum and maximum values in the array and linearly maps them\n     * to the specified low and high values. All intermediate values are scaled\n     * proportionally. The original array is not modified.\n     *\n     * Preserves any modulation settings (speed, smooth, ease, offset) from the\n     * original array.\n     *\n     * @param low - New minimum value\n     * @param high - New maximum value\n     * @returns A new ModulatedArray with remapped values\n     *\n     * \n     */\n    fit(low: number, high: number): ModulatedArray;\n}\n/**\n * Initialize array utilities by extending Array prototype.\n * This adds Hydra-style methods to arrays.\n */\nexport declare function initArrayUtils(): void;\n/**\n * Get the current value from a modulated array based on context.\n */\nexport declare function getArrayValue(arr: ModulatedArray, ctx: SynthContext): number;\n/**\n * Check if a value is a modulated array.\n * In Hydra, ALL number arrays are treated as time-varying sequences,\n * even without explicit .fast() or .smooth() modulation.\n */\nexport declare function isModulatedArray(value: unknown): value is ModulatedArray;\n//# sourceMappingURL=ArrayUtils.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/utils/CharacterResolver.d.ts": "import type { TextmodeFont } from 'textmode.js/loadables';\n/**\n * Resolver for character indices using font data.\n * Caches resolved indices to avoid repeated lookups.\n */\nexport declare class CharacterResolver {\n    private _resolvedIndices?;\n    private _lastFontCharacterCount;\n    private _lastChars;\n    /**\n     * Resolve character indices using the font's character map.\n     * @param chars The character string to resolve\n     * @param font The font to use for resolution\n     * @returns Array of resolved font indices\n     */\n    resolve(chars: string, font: TextmodeFont): Int32Array;\n    invalidate(): void;\n}\n//# sourceMappingURL=CharacterResolver.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/utils/collectExternalLayerRefs.d.ts": "import type { TextmodeLayer } from 'textmode.js/layering';\nimport type { SynthSource } from '../core/SynthSource';\n/**\n * Collect all external layer references from a SynthSource and its nested chains.\n */\nexport declare function collectExternalLayerRefs(source: SynthSource): Map<string, TextmodeLayer>;\n//# sourceMappingURL=collectExternalLayerRefs.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/utils/index.d.ts": "/**\n * Utilities module exports.\n */\nexport { EASING_FUNCTIONS, initArrayUtils, getArrayValue, isModulatedArray, type EasingFunction, type ModulatedArray, } from './ArrayUtils';\nexport { CharacterResolver } from './CharacterResolver';\nexport { collectExternalLayerRefs } from './collectExternalLayerRefs';\nexport { evaluateDynamic, createDynamicUpdater, setGlobalErrorCallback, getGlobalErrorCallback, type DynamicErrorCallback, type EvalOptions, } from './SafeEvaluator';\n//# sourceMappingURL=index.d.ts.map",
  "file:///node_modules/textmode.synth.js/dist/types/utils/SafeEvaluator.d.ts": "/**\n * DynamicEvaluator - Dynamic parameter evaluation for live coding environments.\n *\n * Provides graceful error handling for user-provided dynamic parameter functions.\n * When evaluation fails, errors are reported via callback and a fallback value\n * is returned, allowing rendering to continue with safe defaults.\n */\nimport type { SynthContext } from '../core/types';\n/**\n * Callback signature for dynamic parameter evaluation errors.\n * Live coding environments can use this to display errors without interrupting rendering.\n */\nexport type DynamicErrorCallback = (error: unknown, uniformName: string) => void;\n/**\n * Options for dynamic parameter evaluation.\n */\nexport interface EvalOptions {\n    /** Callback invoked when an error occurs (overrides global callback) */\n    onError?: DynamicErrorCallback;\n}\n/**\n * Set a global error callback for dynamic parameter evaluation errors.\n *\n * Provides a centralized way for live coding environments to receive\n * notifications whenever a dynamic parameter fails to evaluate.\n *\n * \n */\nexport declare function setGlobalErrorCallback(callback: DynamicErrorCallback | null): void;\n/**\n * Get the current global error callback.\n */\nexport declare function getGlobalErrorCallback(): DynamicErrorCallback | null;\n/**\n * Evaluate a dynamic parameter with graceful error handling.\n *\n * When evaluation fails (exception or invalid value), the error is reported\n * via callback and the fallback value is returned. This allows rendering to\n * continue with safe defaults rather than aborting the frame.\n *\n * @param fn - The dynamic parameter function to evaluate\n * @param uniformName - Name of the uniform (for error reporting)\n * @param fallback - Value to return if evaluation fails\n * @param options - Evaluation options including error callback\n * @returns The evaluated value, or fallback on error\n */\nexport declare function evaluateDynamic(fn: () => number | number[], uniformName: string, fallback: number | number[], options?: EvalOptions): number | number[];\n/**\n * Create a wrapped updater function with graceful error handling.\n */\nexport declare function createDynamicUpdater(updater: (ctx: SynthContext) => number | number[], uniformName: string, fallback: number | number[], onError?: DynamicErrorCallback): (ctx: SynthContext) => number | number[];\n//# sourceMappingURL=SafeEvaluator.d.ts.map",
  "file:///src/live/globals.d.ts": "import { Textmodifier } from 'textmode.js';\nimport { SynthSource, SynthParameterValue, EasingFunction } from 'textmode.synth.js';\n\ndeclare global {\n  // Main Textmode Instance\n  const t: Textmodifier;\n\n  // Audio Analysis\n  interface AudioAnalysis {\n    /** Get raw FFT frequency data (0-255 per bin) */\n    fft(): Uint8Array;\n    /** Get raw time-domain waveform data (0-255, 128 = silence) */\n    waveform(): Uint8Array;\n    /** Get bass frequency level (0-1) */\n    bass(): number;\n    /** Get mid frequency level (0-1) */\n    mid(): number;\n    /** Get high frequency level (0-1) */\n    high(): number;\n    /** Get overall volume level (0-1) */\n    volume(): number;\n  }\n  const audio: AudioAnalysis;\n\n  // Cleanup\n  function onDispose(fn: () => void): void;\n  \n  // Tracked Timers (overridden from window for resource tracking)\n  function setTimeout(handler: TimerHandler, timeout?: number, ...args: unknown[]): number;\n  function clearTimeout(id?: number): void;\n  function setInterval(handler: TimerHandler, timeout?: number, ...args: unknown[]): number;\n  function clearInterval(id?: number): void;\n  function requestAnimationFrame(callback: FrameRequestCallback): number;\n  function cancelAnimationFrame(id: number): void;\n  function addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n\n  // Synth Source Functions (re-exported as globals)\n  function osc(frequency?: SynthParameterValue, sync?: SynthParameterValue, offset?: SynthParameterValue): SynthSource;\n  function noise(scale?: SynthParameterValue, offset?: SynthParameterValue): SynthSource;\n  function gradient(speed?: SynthParameterValue): SynthSource;\n  function solid(r?: SynthParameterValue, g?: SynthParameterValue, b?: SynthParameterValue, a?: SynthParameterValue): SynthSource;\n  function shape(sides?: SynthParameterValue, radius?: SynthParameterValue, smoothing?: SynthParameterValue): SynthSource;\n  function src(layer?: { id?: string }): SynthSource;\n  function char(source: SynthSource, charCount?: number): SynthSource;\n  function voronoi(scale?: SynthParameterValue, speed?: SynthParameterValue, blending?: SynthParameterValue): SynthSource;\n  function charColor(source: SynthSource, color: SynthSource): SynthSource;\n  function cellColor(source: SynthSource, color: SynthSource): SynthSource;\n  function paint(source: SynthSource): SynthSource;\n\n  \n  // Array Extensions for synth modulation\n  interface Array<T> {\n    fast(speed?: number): this;\n    smooth(speed?: number): this;\n    ease(ease: EasingFunction): this;\n    offset(offset: number): this;\n    fit(low: number, high: number): this;\n  }\n}\n"
};
