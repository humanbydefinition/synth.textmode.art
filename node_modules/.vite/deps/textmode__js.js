import "./chunk-E5EEIGMK.js";

// node_modules/textmode.js/dist/textmode.esm.js
var se = Object.defineProperty;
var re = (o, t, e) => t in o ? se(o, t, { enumerable: true, configurable: true, writable: true, value: e }) : o[t] = e;
var a = (o, t, e) => re(o, typeof t != "symbol" ? t + "" : t, e);
var S = class _S extends Error {
  constructor(t, e = {}) {
    super(_S.i(t, e)), this.name = "TextmodeError";
  }
  static i(t, e) {
    return `${t}${e && Object.keys(e).length > 0 ? `

ðŸ“‹ Context:` + Object.entries(e).map(([i, s]) => `
  - ${i}: ${_S.o(s)}`).join("") : ""}

${"â†“".repeat(24)}
`;
  }
  static o(t) {
    if (t === null) return "null";
    if (t === void 0) return "undefined";
    if (typeof t == "string") return `"${t}"`;
    if (typeof t == "number" || typeof t == "boolean") return t + "";
    if (Array.isArray(t)) return t.length === 0 ? "[]" : t.length <= 5 ? `[${t.map((e) => _S.o(e)).join(", ")}]` : `[${t.slice(0, 3).map((e) => _S.o(e)).join(", ")}, ... +${t.length - 3} more]`;
    if (typeof t == "object") {
      const e = Object.keys(t);
      return e.length === 0 ? "{}" : e.length <= 3 ? `{ ${e.map((i) => `${i}: ${_S.o(t[i])}`).join(", ")} }` : `{ ${e.slice(0, 2).map((i) => `${i}: ${_S.o(t[i])}`).join(", ")}, ... +${e.length - 2} more }`;
    }
    return t + "";
  }
};
var ne = ((o) => (o[o.SILENT = 0] = "SILENT", o[o.WARNING = 1] = "WARNING", o[o.ERROR = 2] = "ERROR", o[o.THROW = 3] = "THROW", o))(ne || {});
var _ = class _2 {
  constructor() {
    a(this, "l", { globalLevel: 3 });
  }
  static u() {
    return _2.h || (_2.h = new _2()), _2.h;
  }
  v(t, e) {
    const i = "%c[textmode.js] Oops! (â•¯Â°â–¡Â°)â•¯ï¸µ Something went wrong in your code.", s = "color: #f44336; font-weight: bold; background: #ffebee; padding: 2px 6px; border-radius: 3px;";
    switch (this.l.globalLevel) {
      case 0:
        return false;
      case 1:
        return console.group(i, s), console.warn(S.i(t, e)), console.groupEnd(), false;
      case 2:
        return console.group(i, s), console.error(S.i(t, e)), console.groupEnd(), false;
      default:
        throw new S(t, e);
    }
  }
  m(t, e, i) {
    return !!t || (this.v(e, i), false);
  }
  _(t) {
    this.l.globalLevel = t;
  }
};
a(_, "h", null);
var dt = _;
var At = dt.u();
var Q = class {
  constructor(t, e, i) {
    a(this, "A");
    a(this, "C");
    a(this, "M", /* @__PURE__ */ new Map());
    a(this, "U", /* @__PURE__ */ new Map());
    a(this, "F", 0);
    a(this, "$", /* @__PURE__ */ new Map());
    a(this, "P");
    this.A = t, this.P = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS) ?? 16, this.C = this.S(e, i), this.R();
  }
  R() {
    const t = this.A.getProgramParameter(this.C, this.A.ACTIVE_UNIFORMS);
    for (let e = 0; e < t; e++) {
      const i = this.A.getActiveUniform(this.C, e);
      if (i) {
        const s = i.name.replace(/\[0\]$/, ""), r = this.A.getUniformLocation(this.C, s);
        r && (this.M.set(s, r), this.U.set(s, { type: i.type, size: i.size }));
      }
    }
  }
  S(t, e) {
    const i = this.k(this.A.VERTEX_SHADER, t), s = this.k(this.A.FRAGMENT_SHADER, e), r = this.A.createProgram();
    if (this.A.attachShader(r, i), this.A.attachShader(r, s), this.A.linkProgram(r), !this.A.getProgramParameter(r, this.A.LINK_STATUS)) {
      const n = this.A.getProgramInfoLog(r);
      throw Error("Shader program link error: " + n);
    }
    return this.A.deleteShader(i), this.A.deleteShader(s), r;
  }
  k(t, e) {
    const i = this.A.createShader(t);
    if (this.A.shaderSource(i, e), this.A.compileShader(i), !this.A.getShaderParameter(i, this.A.COMPILE_STATUS)) {
      const s = this.A.getShaderInfoLog(i);
      throw this.A.deleteShader(i), Error("Shader compilation error: " + s);
    }
    return i;
  }
  D() {
    this.A.useProgram(this.C), this.L();
  }
  L() {
    this.F = 0, this.$.clear();
  }
  H(t) {
    for (const e in t) this.O(e, t[e]);
  }
  O(t, e) {
    var c, l;
    const i = this.M.get(t);
    if (!i) return;
    const s = this.U.get(t);
    if (!s) return;
    const { type: r, size: n } = s, h = this.A;
    if (e instanceof WebGLTexture) {
      const u = this.I(t);
      return h.uniform1i(i, u), h.activeTexture(h.TEXTURE0 + u), void h.bindTexture(h.TEXTURE_2D, e);
    }
    if (e instanceof Y) {
      const u = this.I(t);
      return h.uniform1i(i, u), h.activeTexture(h.TEXTURE0 + u), void h.bindTexture(h.TEXTURE_2D, e.textures[0]);
    }
    if (typeof e == "number") return void (r === h.INT || r === h.BOOL ? h.uniform1i(i, e) : h.uniform1f(i, e));
    if (typeof e == "boolean") return void h.uniform1i(i, e ? 1 : 0);
    if (Array.isArray(e[0])) {
      const u = e.flat(), f = { [h.FLOAT_VEC2]: () => h.uniform2fv(i, u), [h.FLOAT_VEC3]: () => h.uniform3fv(i, u), [h.FLOAT_VEC4]: () => h.uniform4fv(i, u) };
      (c = f[r]) == null || c.call(f);
    } else {
      const u = e, f = { [h.FLOAT]: () => n > 1 ? h.uniform1fv(i, u) : h.uniform1f(i, u[0]), [h.FLOAT_VEC2]: () => h.uniform2fv(i, u), [h.FLOAT_VEC3]: () => h.uniform3fv(i, u), [h.FLOAT_VEC4]: () => h.uniform4fv(i, u), [h.INT]: () => n > 1 ? h.uniform1iv(i, u) : h.uniform1i(i, u[0]), [h.INT_VEC2]: () => h.uniform2iv(i, u), [h.INT_VEC3]: () => h.uniform3iv(i, u), [h.INT_VEC4]: () => h.uniform4iv(i, u), [h.BOOL]: () => h.uniform1iv(i, u), [h.FLOAT_MAT2]: () => h.uniformMatrix2fv(i, false, u), [h.FLOAT_MAT3]: () => h.uniformMatrix3fv(i, false, u), [h.FLOAT_MAT4]: () => h.uniformMatrix4fv(i, false, u) };
      (l = f[r]) == null || l.call(f);
    }
  }
  I(t) {
    const e = this.$.get(t);
    if (e !== void 0) return e;
    if (this.F >= this.P) throw Error(`[textmode.js] Shader attempted to bind more than ${this.P} texture samplers. Uniform "${t}" cannot be assigned.`);
    const i = this.F++;
    return this.$.set(t, i), i;
  }
  get program() {
    return this.C;
  }
  dispose() {
    this.A.deleteProgram(this.C);
  }
};
function xt(o, t, e, i) {
  return 180 * Math.atan2(i - t, e - o) / Math.PI;
}
function H(o, t, e, i) {
  return Math.hypot(e - o, i - t);
}
function X(o, t, e) {
  return Math.min(Math.max(o, t), e);
}
function Mt(o) {
  return (o % 360 + 360) % 360 / 360;
}
function Ut(o, t, e) {
  o.bindTexture(o.TEXTURE_2D, t), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, 1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, o.RGBA, o.UNSIGNED_BYTE, e), o.bindTexture(o.TEXTURE_2D, null);
}
function pt(o, t, e, i, s) {
  o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, t), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, e), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, i), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, s);
}
function gt(o, t, e, i, s, r = 0, n = WebGL2RenderingContext.FLOAT, h = false) {
  o.enableVertexAttribArray(t), o.vertexAttribPointer(t, e, n, h, i, s), o.vertexAttribDivisor(t, r);
}
function Pt(o, t, e, i, s) {
  o.bindBuffer(t, e), o.bufferData(t, i, s), o.bindBuffer(t, null);
}
var rt = `#version 300 es
in vec2 A0;in vec2 A1;in vec2 A2;in vec2 A3;in vec3 A4;in vec4 A5;in vec4 A6;in vec4 A7;in vec3 A8;in vec3 A9;in vec4 Aa;in vec4 Ab;in vec3 Ac;uniform vec2 UG;uniform float UH;uniform float UI;out vec2 v_uv;out vec3 v_glyphIndex;out vec4 v_glyphColor;out vec4 v_cellColor;out vec4 v_glyphFlags;out vec3 v_worldPosition;out vec3 v_normal;out float v_geometryType;const float A=6.28318530718f;const int B=2;const int C=3;const int D=4;vec2 E(float F,vec2 G,vec2 H,vec2 I,vec2 J){float K=1.0f-F;float L=K*K;float M=L*K;float N=F*F;float O=N*F;return M*G+3.0f*L*F*H+3.0f*K*N*I+O*J;}vec2 P(float F,vec2 G,vec2 H,vec2 I,vec2 J){float K=1.0f-F;float L=K*K;float N=F*F;return-3.0f*L*G+3.0f*(L-2.0f*K*F)*H+3.0f*(2.0f*K*F-N)*I+3.0f*N*J;}vec3 Q(vec3 R,float S){float T=cos(S);float U=sin(S);return vec3(R.x,R.y*T-R.z*U,R.y*U+R.z*T);}vec3 V(vec3 R,float S){float T=cos(S);float U=sin(S);return vec3(R.x*T+R.z*U,R.y,-R.x*U+R.z*T);}vec3 W(vec3 R,float S){float T=cos(S);float U=sin(S);return vec3(R.x*T-R.y*U,R.x*U+R.y*T,R.z);}vec3 X(vec3 R,vec3 Y){vec3 Z=R;if(Y.z!=0.0f){Z=W(Z,Y.z);}if(Y.y!=0.0f){Z=V(Z,Y.y);}if(Y.x!=0.0f){Z=Q(Z,Y.x);}return Z;}void main(){v_uv=A1;v_glyphIndex=A4;v_glyphColor=A5;v_cellColor=A6;v_glyphFlags=A7;vec4 a=Aa;vec4 b=Ab;vec2 c=A3;vec2 d=A2;float e=Ac.x;float f=Ac.y;int g=int(Ac.z);vec2 h=d;vec2 i=h+c*0.5f;float j=f+e*0.5f;vec3 k=vec3(i,j);vec3 l;if(g==D){float F=clamp(A0.x,0.0f,1.0f);vec2 G=b.xy;vec2 H=a.xy;vec2 I=a.zw;vec2 J=b.zw;vec2 m=E(F,G,H,I,J);vec2 n=P(F,G,H,I,J);float o=length(n);vec2 p=o>0.0f?n/o:vec2(1.0f,0.0f);vec2 q=vec2(-p.y,p.x);vec2 r=m;vec2 s=r+q*A0.y*c.y;l=vec3(s,f);}else if(g==C){float t=mod(a.x,A);if(t<0.0f){t+=A;}float u=mod(a.y,A);if(u<0.0f){u+=A;}float v=t-u;if(v<=0.0f){v+=A;}float S=t-A0.x*v;vec2 w=vec2(cos(S),sin(S))*A0.y;vec2 s=w*c+h;l=vec3(s,f);}else if(g==B){vec2 s=A0.xy*c+h;l=vec3(s,f);}vec3 x=X(l,A9);vec3 y=x+A8;vec3 z=vec3(0.0f,0.0f,1.0f);v_worldPosition=y;v_normal=z;v_geometryType=float(g);vec2 AA=(y.xy/UG)*2.0f;AA.y=-AA.y;float AB=y.z/UG.y;float AC=clamp(-AB*UH,-0.99f,0.99f);if(UI>0.5f){gl_Position=vec4(AA,AC,1.0f);}else{float AD=0.5f;float AE=1.0f/(1.0f-AB*AD);AA*=AE;gl_Position=vec4(AA,AC,1.0f);}}`;
var K = class K2 {
  constructor(t, e, i = e, s = 1, r = {}, n) {
    a(this, "G");
    a(this, "j");
    a(this, "l");
    a(this, "A");
    a(this, "N");
    a(this, "Y", []);
    a(this, "X", null);
    a(this, "W");
    a(this, "K");
    a(this, "Z", null);
    a(this, "q", /* @__PURE__ */ new Map());
    this.G = e, this.j = i, this.A = t, this.W = X(s, 1, 8), this.K = n, this.l = { filter: "nearest", wrap: "clamp", format: "rgba", type: "unsigned_byte", depth: true, ...r }, K2.V || (K2.V = new Q(t, rt, `#version 300 es
precision highp float;in vec2 v_uv;uniform sampler2D U0;uniform sampler2D U1;uniform sampler2D U2;uniform sampler2D U3;uniform vec2 U4;uniform bool U5;uniform bool U6;uniform bool U7;layout(location=0)out vec4 o_character;layout(location=1)out vec4 o_primaryColor;layout(location=2)out vec4 o_secondaryColor;layout(location=3)out vec4 A;void main(){vec2 B=vec2(v_uv.x,1.-v_uv.y);vec2 C=B*U4;vec2 D=(floor(C)+0.5f)/U4;vec4 E=texture(U0,D);vec4 F=U5?texture(U1,D):vec4(0.);if(U5&&F.a==0.){discard;}vec4 G=U6?texture(U2,D):vec4(0.);vec4 H=U7?texture(U3,D):vec4(0.);o_character=E;o_primaryColor=F;o_secondaryColor=G;A=H;}`));
    const h = t.getParameter(t.MAX_DRAW_BUFFERS), c = t.getParameter(t.MAX_COLOR_ATTACHMENTS);
    this.W = Math.min(this.W, h, c), this.N = t.createFramebuffer(), this.J(), this.tt(), this.l.depth && this.st();
  }
  J() {
    const t = this.A, e = this.l.filter === "linear" ? t.LINEAR : t.NEAREST, i = this.l.wrap === "repeat" ? t.REPEAT : t.CLAMP_TO_EDGE, s = this.l.type === "float" ? t.FLOAT : t.UNSIGNED_BYTE, r = s === t.FLOAT ? t.RGBA32F : t.RGBA8, n = t.RGBA;
    for (let h = 0; h < this.W; h++) {
      const c = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, c), pt(t, e, e, i, i), t.texImage2D(t.TEXTURE_2D, 0, r, this.G, this.j, 0, n, s, null), this.Y.push(c);
    }
    t.bindTexture(t.TEXTURE_2D, null);
  }
  tt() {
    const t = this.A;
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.N), this.W === 1) t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.Y[0], 0);
    else {
      const e = [];
      for (let i = 0; i < this.W; i++) {
        const s = t.COLOR_ATTACHMENT0 + i;
        t.framebufferTexture2D(t.FRAMEBUFFER, s, t.TEXTURE_2D, this.Y[i], 0), e.push(s);
      }
      t.drawBuffers(e);
    }
    t.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  st() {
    const t = this.A;
    this.X = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.X), t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT24, this.G, this.j), t.bindFramebuffer(t.FRAMEBUFFER, this.N), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, this.X), t.bindFramebuffer(t.FRAMEBUFFER, null), t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  et(t) {
    Ut(this.A, this.Y[0], t);
  }
  resize(t, e) {
    this.G = t, this.j = e, this.q.clear();
    const i = this.A, s = this.l.type === "float" ? i.FLOAT : i.UNSIGNED_BYTE, r = s === i.FLOAT ? i.RGBA32F : i.RGBA8, n = i.RGBA;
    for (const h of this.Y) i.bindTexture(i.TEXTURE_2D, h), i.texImage2D(i.TEXTURE_2D, 0, r, this.G, this.j, 0, n, s, null);
    i.bindTexture(i.TEXTURE_2D, null), this.X && (i.bindRenderbuffer(i.RENDERBUFFER, this.X), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_COMPONENT24, this.G, this.j), i.bindRenderbuffer(i.RENDERBUFFER, null));
  }
  readPixels(t) {
    const e = this.q.get(t);
    if (e) return e;
    const i = this.A, s = this.G, r = this.j, n = new Uint8Array(s * r * 4), h = i.getParameter(i.READ_FRAMEBUFFER_BINDING);
    i.bindFramebuffer(i.READ_FRAMEBUFFER, this.N), i.readBuffer(i.COLOR_ATTACHMENT0 + t), i.readPixels(0, 0, s, r, i.RGBA, i.UNSIGNED_BYTE, n), i.bindFramebuffer(i.READ_FRAMEBUFFER, h);
    const c = 4 * s, l = new Uint8Array(n.length);
    for (let u = 0; u < r; u++) {
      const f = (r - 1 - u) * c, d = u * c;
      l.set(n.subarray(f, f + c), d);
    }
    return this.q.set(t, l), l;
  }
  begin() {
    const t = this.A;
    this.q.clear(), this.K.it(), this.K.rt(this.N, this.G, this.j, this.W), this.l.depth && t.clear(t.DEPTH_BUFFER_BIT), this.K.state.nt();
  }
  end() {
    this.K.state.ot(), this.K.ht(), this.K.ct();
  }
  lt() {
    return this.Z || this.ut(), this.Z;
  }
  ut() {
    if (!this.K) return;
    const t = this.W > 1, e = this.W > 2, i = this.W > 3, s = { U0: this.Y[0], U1: t ? this.Y[1] : this.Y[0], U2: e ? this.Y[2] : this.Y[0], U3: i ? this.Y[3] : this.Y[0], U4: [this.G, this.j], U5: t, U6: e, U7: i }, r = K2.V;
    this.Z = this.K.dt.ft(r, s, true);
  }
  dispose() {
    const t = this.A;
    t.deleteFramebuffer(this.N), this.Y.forEach((e) => {
      t.deleteTexture(e);
    }), this.X && t.deleteRenderbuffer(this.X);
  }
  get width() {
    return this.G;
  }
  get height() {
    return this.j;
  }
  get textures() {
    return this.Y;
  }
  get attachmentCount() {
    return this.W;
  }
};
a(K, "V", null);
var Y = K;
var Ct = /* @__PURE__ */ new WeakMap();
function at(o, t) {
  Ct.set(o, t);
}
function St(o) {
  return Ct.get(o);
}
function et(o, t, e, i, s = 255) {
  o[0] = t / 255, o[1] = (e ?? t) / 255, o[2] = (i ?? t) / 255, o[3] = s / 255;
}
var nt = class _nt {
  constructor() {
    a(this, "vt", 1);
    a(this, "gt", 0);
    a(this, "_t", 0);
    a(this, "yt", 0);
    a(this, "At", 0);
    a(this, "bt", 0);
    a(this, "wt", 0);
    a(this, "xt", [0, 0, 0]);
    a(this, "Ct", [1, 1, 1, 1]);
    a(this, "Mt", [0, 0, 0, 1]);
    a(this, "Ft", false);
    a(this, "$t", false);
    a(this, "Pt", false);
    a(this, "Tt", 0);
    a(this, "zt", [0, 0, 0, 1]);
    a(this, "St", false);
    a(this, "Rt", []);
    a(this, "Et", []);
  }
  static kt() {
    return { Dt: 1, Lt: 0, Ht: 0, Ot: 0, At: 0, bt: 0, wt: 0, Tt: 0, Bt: false, It: false, Pt: false, St: false, Gt: [0, 0, 0], jt: [1, 1, 1, 1], Nt: [0, 0, 0, 1] };
  }
  Qt(t) {
    t.Dt = this.vt, t.Lt = this.gt, t.Ht = this._t, t.Ot = this.yt, t.At = this.At, t.bt = this.bt, t.wt = this.wt, t.Bt = this.Ft, t.It = this.$t, t.Pt = this.Pt, t.Tt = this.Tt, t.St = this.St, t.Gt[0] = this.xt[0], t.Gt[1] = this.xt[1], t.Gt[2] = this.xt[2], t.jt[0] = this.Ct[0], t.jt[1] = this.Ct[1], t.jt[2] = this.Ct[2], t.jt[3] = this.Ct[3], t.Nt[0] = this.Mt[0], t.Nt[1] = this.Mt[1], t.Nt[2] = this.Mt[2], t.Nt[3] = this.Mt[3];
  }
  Yt(t) {
    this.vt = t.Dt, this.gt = t.Lt, this._t = t.Ht, this.yt = t.Ot, this.At = t.At, this.bt = t.bt, this.wt = t.wt, this.Ft = t.Bt, this.$t = t.It, this.Pt = t.Pt, this.Tt = t.Tt, this.St = t.St, this.xt[0] = t.Gt[0], this.xt[1] = t.Gt[1], this.xt[2] = t.Gt[2], this.Ct[0] = t.jt[0], this.Ct[1] = t.jt[1], this.Ct[2] = t.jt[2], this.Ct[3] = t.jt[3], this.Mt[0] = t.Nt[0], this.Mt[1] = t.Nt[1], this.Mt[2] = t.Nt[2], this.Mt[3] = t.Nt[3];
  }
  nt() {
    let t = this.Et.pop();
    t || (t = _nt.kt()), this.Qt(t), this.Rt.push(t);
  }
  ot() {
    const t = this.Rt.pop();
    t ? (this.Yt(t), this.Et.push(t)) : console.warn("pop() called without matching push()");
  }
  Xt(t) {
    this.Qt(t);
  }
  Wt(t) {
    this.vt = Math.abs(t);
  }
  Kt() {
    this.gt = 0, this._t = 0, this.yt = 0, this.At = 0, this.bt = 0, this.wt = 0, this.St = false;
  }
  Zt(t) {
    t !== 0 && (this.At += t * Math.PI / 180);
  }
  qt(t) {
    t !== 0 && (this.bt += t * Math.PI / 180);
  }
  Vt(t) {
    t !== 0 && (this.wt += t * Math.PI / 180);
  }
  Jt(t = 0, e = 0, i = 0) {
    t === 0 && e === 0 && i === 0 || (this.gt += t, this._t += e, this.yt += i);
  }
  ts(t) {
    this.Jt(t, 0, 0);
  }
  ss(t) {
    this.Jt(0, t, 0);
  }
  es(t) {
    this.Jt(0, 0, t);
  }
  rs(t) {
    this.xt[0] = t[0], this.xt[1] = t[1], this.xt[2] = t[2];
  }
  ns(t, e, i, s = 255) {
    et(this.Ct, t, e, i, s);
  }
  hs(t, e, i, s = 255) {
    et(this.Mt, t, e, i, s);
  }
  cs(t) {
    this.Ft = t;
  }
  ls(t) {
    this.$t = t;
  }
  us(t) {
    this.Pt = t;
  }
  fs(t) {
    this.Tt = Mt(t);
  }
  ds(t, e, i, s) {
    et(this.zt, t, e, i, s);
  }
  vs(t) {
    this.St = t;
  }
  get canvasBackgroundColor() {
    return this.zt;
  }
  get useOrtho() {
    return this.St;
  }
  get rotationX() {
    return this.At;
  }
  get rotationY() {
    return this.bt;
  }
  get rotationZ() {
    return this.wt;
  }
};
var vt = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, -0.5, 0.5, 0, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1]);
var G = { ps: 16, gs: WebGL2RenderingContext.TRIANGLES, _s: { As: { size: 2, offset: 0 }, bs: { size: 2, offset: 8 } } };
var he = class {
  constructor(t) {
    a(this, "A");
    a(this, "ws");
    a(this, "Cs");
    this.A = t, this.ws = t.createBuffer(), this.Cs = new Float32Array(vt.length);
  }
  Ms(t, e, i, s) {
    const r = this.A, n = St(this.A), h = n[2], c = n[3], l = t / h * 2 - 1, u = (t + i) / h * 2 - 1, f = 1 - (e + s) / c * 2, d = 1 - e / c * 2, g = vt, v = this.Cs;
    for (let m = 0; m < g.length; m += 4) {
      const A = g[m], p = g[m + 1], x = g[m + 2], y = g[m + 3], b = l + (A + 0.5) * (u - l), E = f + (p + 0.5) * (d - f);
      v[m] = b, v[m + 1] = E, v[m + 2] = x, v[m + 3] = y;
    }
    r.bindBuffer(r.ARRAY_BUFFER, this.ws), r.bufferData(r.ARRAY_BUFFER, v, r.DYNAMIC_DRAW), r.enableVertexAttribArray(0), r.vertexAttribPointer(0, 2, r.FLOAT, false, 16, 0), r.enableVertexAttribArray(1), r.vertexAttribPointer(1, 2, r.FLOAT, false, 16, 8), r.drawArrays(r.TRIANGLES, 0, 6), r.disableVertexAttribArray(1), r.disableVertexAttribArray(0), r.bindBuffer(r.ARRAY_BUFFER, null);
  }
  Fs() {
    this.A.deleteBuffer(this.ws);
  }
};
var F = ((o) => (o.RECTANGLE = "rectangle", o.LINE = "line", o.ELLIPSE = "ellipse", o.ARC = "arc", o.TRIANGLE = "triangle", o.BEZIER_CURVE = "bezier_curve", o))(F || {});
var oe = { rectangle: 2, line: 2, ellipse: 2, triangle: 2, arc: 3, bezier_curve: 4 };
var ae = class {
  constructor(t) {
    a(this, "A");
    a(this, "$s", /* @__PURE__ */ new Map());
    this.A = t;
  }
  Ps(t, e, i, s) {
    const r = this.A;
    let n = this.$s.get(t);
    n || (n = /* @__PURE__ */ new Map(), this.$s.set(t, n));
    let h = n.get(e) || null;
    if (!h) {
      h = r.createVertexArray(), n.set(e, h), r.bindVertexArray(h), r.bindBuffer(r.ARRAY_BUFFER, s);
      const c = r.getAttribLocation(t, "A0");
      c !== -1 && gt(r, c, i._s.As.size, i.ps, i._s.As.offset, 0, r.FLOAT, false);
      const l = r.getAttribLocation(t, "A1");
      l !== -1 && gt(r, l, i._s.bs.size, i.ps, i._s.bs.offset, 0, r.FLOAT, false);
    }
    r.bindVertexArray(h);
  }
  Ts() {
    this.A.bindVertexArray(null);
  }
  Fs() {
    for (const [, t] of this.$s) for (const [, e] of t) e && this.A.deleteVertexArray(e);
  }
};
var B = class B2 {
  static zs(t, e, i = 0) {
    const s = e || new Float32Array(B2.FLOATS_PER_INSTANCE);
    let r = i;
    s[r++] = t.As[0], s[r++] = t.As[1], s[r++] = t.Ss[0], s[r++] = t.Ss[1], s[r++] = t.Gt[0], s[r++] = t.Gt[1], s[r++] = t.Gt[2], s[r++] = t.jt[0], s[r++] = t.jt[1], s[r++] = t.jt[2], s[r++] = t.jt[3], s[r++] = t.Nt[0], s[r++] = t.Nt[1], s[r++] = t.Nt[2], s[r++] = t.Nt[3], s[r++] = t.Rs[0], s[r++] = t.Rs[1], s[r++] = t.Rs[2], s[r++] = t.Tt;
    const n = t.Es;
    s[r++] = (n == null ? void 0 : n[0]) ?? 0, s[r++] = (n == null ? void 0 : n[1]) ?? 0, s[r++] = (n == null ? void 0 : n[2]) ?? 0;
    const h = t.ks;
    s[r++] = (h == null ? void 0 : h[0]) ?? 0, s[r++] = (h == null ? void 0 : h[1]) ?? 0, s[r++] = (h == null ? void 0 : h[2]) ?? 0;
    const c = t.Ds, l = t.Ls, u = t.Hs, f = t.Os, d = t.Bs, g = !(!l || !u);
    return g ? (s[r++] = (f == null ? void 0 : f[0]) ?? 0, s[r++] = (f == null ? void 0 : f[1]) ?? 0, s[r++] = (d == null ? void 0 : d[0]) ?? 0, s[r++] = (d == null ? void 0 : d[1]) ?? 0, s[r++] = l[0], s[r++] = l[1], s[r++] = u[0], s[r++] = u[1]) : !g && !!c ? (s[r++] = c[0], s[r++] = c[1], s[r++] = 0, s[r++] = 0, s[r++] = 0, s[r++] = 0, s[r++] = 0, s[r++] = 0) : (s[r++] = 0, s[r++] = 0, s[r++] = 0, s[r++] = 0, s[r++] = 0, s[r++] = 0, s[r++] = 0, s[r++] = 0), s[r++] = t.Is ?? 0, s[r++] = t.Gs ?? 0, s[r++] = t.js ?? 0, s;
  }
  static Ns(t, e) {
    const i = t.length * B2.FLOATS_PER_INSTANCE, s = e || new Float32Array(i);
    for (let r = 0; r < t.length; r++) {
      const n = r * B2.FLOATS_PER_INSTANCE;
      B2.zs(t[r], s, n);
    }
    return s;
  }
};
a(B, "BYTES_PER_INSTANCE", 144), a(B, "FLOATS_PER_INSTANCE", 36);
var D = B;
var P = class P2 {
};
a(P, "STRIDE", D.BYTES_PER_INSTANCE), a(P, "ATTRIBUTES", { A2: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 0, divisor: 1 }, A3: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 8, divisor: 1 }, A4: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 16, divisor: 1 }, A5: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 28, divisor: 1 }, A6: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 44, divisor: 1 }, A7: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 60, divisor: 1 }, A8: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 76, divisor: 1 }, A9: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 88, divisor: 1 }, Aa: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 100, divisor: 1 }, Ab: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 116, divisor: 1 }, Ac: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: false, stride: P.STRIDE, offset: 132, divisor: 1 } });
var W = P;
var ce = class {
  constructor(t = 1e3, e = 1.5) {
    a(this, "Qs");
    a(this, "Ys");
    a(this, "Xs");
    a(this, "Ws", 0);
    a(this, "Ks", 0);
    this.Ys = t, this.Xs = e;
    const i = t * D.FLOATS_PER_INSTANCE;
    this.Qs = new Float32Array(i);
  }
  Zs(t) {
    if (t <= this.Ys) return;
    const e = Math.ceil(t * this.Xs), i = this.Ys;
    this.Ys = e;
    const s = e * D.FLOATS_PER_INSTANCE, r = new Float32Array(s), n = i * D.FLOATS_PER_INSTANCE;
    r.set(this.Qs.subarray(0, Math.min(n, this.Ws))), this.Qs = r;
  }
  qs() {
    return { buffer: this.Qs, offset: this.Ws };
  }
  Vs(t) {
    this.Ws += t, this.Ks++;
  }
  Js() {
    this.Ws = 0, this.Ks = 0;
  }
  te(t = 0, e) {
    return this.Qs.subarray(t, e ?? this.Ws);
  }
  get se() {
    return this.Ks;
  }
  get ee() {
    return this.Ys;
  }
  get ie() {
    return this.Ws;
  }
  get re() {
    return this.Ks === 0;
  }
};
var le = class {
  constructor(t) {
    a(this, "Qs");
    this.Qs = t;
  }
  ne(t) {
    this.Qs.Zs(this.Qs.se + 1);
    const { buffer: e, offset: i } = this.Qs.qs();
    e[i + 0] = t.x, e[i + 1] = t.y, e[i + 2] = t.width, e[i + 3] = t.height, e[i + 4] = t.char0, e[i + 5] = t.char1, e[i + 6] = t.char2, e[i + 7] = t.r1, e[i + 8] = t.g1, e[i + 9] = t.b1, e[i + 10] = t.a1, e[i + 11] = t.r2, e[i + 12] = t.g2, e[i + 13] = t.b2, e[i + 14] = t.a2, e[i + 15] = t.invert, e[i + 16] = t.flipX, e[i + 17] = t.flipY, e[i + 18] = t.charRot, e[i + 19] = t.translationX, e[i + 20] = t.translationY, e[i + 21] = t.translationZ, e[i + 22] = t.rotationX, e[i + 23] = t.rotationY, e[i + 24] = t.rotationZ;
    const s = t.curveParams0, r = t.curveParams1;
    return e[i + 25] = s[0], e[i + 26] = s[1], e[i + 27] = s[2], e[i + 28] = s[3], e[i + 29] = r[0], e[i + 30] = r[1], e[i + 31] = r[2], e[i + 32] = r[3], e[i + 33] = t.depth, e[i + 34] = t.baseZ, e[i + 35] = t.geometryType, this.Qs.Vs(D.FLOATS_PER_INSTANCE), this.Qs.se - 1;
  }
  get se() {
    return this.Qs.se;
  }
};
var ue = class {
  constructor(t, e = 1e3) {
    a(this, "A");
    a(this, "oe", null);
    a(this, "he", 0);
    a(this, "ae", /* @__PURE__ */ new Map());
    this.A = t, this.ce(e);
  }
  ce(t) {
    const e = this.A;
    this.oe && e.deleteBuffer(this.oe), this.oe = e.createBuffer();
    const i = t * D.BYTES_PER_INSTANCE;
    Pt(e, e.ARRAY_BUFFER, this.oe, i, e.DYNAMIC_DRAW), this.he = t;
  }
  le(t) {
    this.ce(t);
  }
  get ee() {
    return this.he;
  }
  ue(t, e) {
    if (e === 0) return;
    const i = this.A;
    i.bindBuffer(i.ARRAY_BUFFER, this.oe);
    const s = e * D.FLOATS_PER_INSTANCE;
    i.bufferSubData(i.ARRAY_BUFFER, 0, t, 0, s);
  }
  fe(t) {
    let e = this.ae.get(t);
    if (!e) {
      e = /* @__PURE__ */ new Map();
      const i = this.A;
      for (const s in W.ATTRIBUTES) {
        const r = i.getAttribLocation(t, s);
        r !== -1 && e.set(s, r);
      }
      this.ae.set(t, e);
    }
    return e;
  }
  de(t) {
    const e = this.A, i = t.program, s = this.fe(i);
    for (const [r, n] of s) {
      const h = W.ATTRIBUTES[r];
      h && gt(e, n, h.size, h.stride, h.offset, h.divisor, h.type, h.normalized);
    }
  }
  ve(t) {
    const e = this.A, i = this.fe(t.program);
    for (const [s, r] of i)
      W.ATTRIBUTES[s] && (e.disableVertexAttribArray(r), e.vertexAttribDivisor(r, 0));
  }
  Fs() {
    this.oe && (this.A.deleteBuffer(this.oe), this.oe = null), this.ae.clear();
  }
};
var fe = class {
  constructor(t, e = 1e3, i = 1.5) {
    a(this, "A");
    a(this, "Qs");
    a(this, "pe");
    a(this, "me");
    this.A = t, this.Qs = new ce(e, i), this.pe = new le(this.Qs), this.me = new ue(t, e);
  }
  ge(t) {
    var s, r, n, h, c, l, u, f, d, g;
    const e = [0, 0, 0, 0], i = [0, 0, 0, 0];
    return t.Ls && t.Hs ? (e[0] = ((s = t.Os) == null ? void 0 : s[0]) ?? 0, e[1] = ((r = t.Os) == null ? void 0 : r[1]) ?? 0, e[2] = ((n = t.Bs) == null ? void 0 : n[0]) ?? 0, e[3] = ((h = t.Bs) == null ? void 0 : h[1]) ?? 0, i[0] = t.Ls[0], i[1] = t.Ls[1], i[2] = t.Hs[0], i[3] = t.Hs[1]) : t.Ds && (e[0] = t.Ds[0], e[1] = t.Ds[1]), this.ne({ x: t.As[0], y: t.As[1], width: t.Ss[0], height: t.Ss[1], char0: t.Gt[0], char1: t.Gt[1], char2: t.Gt[2], r1: t.jt[0], g1: t.jt[1], b1: t.jt[2], a1: t.jt[3], r2: t.Nt[0], g2: t.Nt[1], b2: t.Nt[2], a2: t.Nt[3], invert: t.Rs[0], flipX: t.Rs[1], flipY: t.Rs[2], charRot: t.Tt, translationX: ((c = t.Es) == null ? void 0 : c[0]) ?? 0, translationY: ((l = t.Es) == null ? void 0 : l[1]) ?? 0, translationZ: ((u = t.Es) == null ? void 0 : u[2]) ?? 0, rotationX: ((f = t.ks) == null ? void 0 : f[0]) ?? 0, rotationY: ((d = t.ks) == null ? void 0 : d[1]) ?? 0, rotationZ: ((g = t.ks) == null ? void 0 : g[2]) ?? 0, curveParams0: e, curveParams1: i, depth: t.Is || 0, baseZ: t.Gs || 0, geometryType: t.js || 0 });
  }
  ne(t) {
    const e = this.pe.ne(t);
    return this.Qs.ee > this.me.ee && this.me.le(this.Qs.ee), e;
  }
  get _e() {
    return this.Qs.se;
  }
  get re() {
    return this.Qs.re;
  }
  ye() {
    this.Qs.Js();
  }
  de(t) {
    const e = this.Qs.se;
    if (e === 0) return;
    const i = this.Qs.te();
    this.me.ue(i, e), this.me.de(t);
  }
  ve(t) {
    this.me.ve(t);
  }
  Ms(t, e) {
    const i = this.Qs.se;
    i !== 0 && this.A.drawArraysInstanced(t, 0, e, i);
  }
  Fs() {
    this.me.Fs();
  }
};
var O = class {
  constructor(t, e, i, s) {
    a(this, "A");
    a(this, "Ae");
    a(this, "be");
    a(this, "we");
    a(this, "xe", null);
    this.A = t, this.Ae = e, this.be = i, this.we = s;
    const r = this.A.createBuffer();
    Pt(this.A, this.A.ARRAY_BUFFER, r, this.we.Ce, this.A.STATIC_DRAW), this.xe = r;
  }
  get type() {
    return this.be;
  }
  get unitGeometry() {
    return this.we;
  }
  get unitBuffer() {
    return this.xe;
  }
  get batch() {
    return this.Ae;
  }
  Me() {
    this.Ae.ye();
  }
  Fe() {
    return !this.Ae.re;
  }
  Fs() {
    this.Ae.Fs(), this.A.deleteBuffer(this.xe);
  }
  $e(t, e, i) {
    return this.Ae.ge(t);
  }
  Pe(t, e, i, s, r, n) {
    const h = r.Lt ?? 0, c = r.Ht ?? 0, l = r.Ot ?? 0, u = r.At ?? 0, f = r.bt ?? 0, d = r.wt ?? 0, g = [0, 0, 0, 0], v = [0, 0, 0, 0];
    n && (n.bezStartX !== void 0 && n.bezStartY !== void 0 && n.bezEndX !== void 0 && n.bezEndY !== void 0 ? (g[0] = n.cp1x ?? 0, g[1] = n.cp1y ?? 0, g[2] = n.cp2x ?? 0, g[3] = n.cp2y ?? 0, v[0] = n.bezStartX ?? 0, v[1] = n.bezStartY ?? 0, v[2] = n.bezEndX ?? 0, v[3] = n.bezEndY ?? 0) : n.arcStart === void 0 && n.arcStop === void 0 || (g[0] = n.arcStart ?? 0, g[1] = n.arcStop ?? 0));
    const m = { x: t, y: e, width: i, height: s, char0: r.Gt[0], char1: r.Gt[1], char2: r.Gt[2], r1: r.jt[0], g1: r.jt[1], b1: r.jt[2], a1: r.jt[3], r2: r.Nt[0], g2: r.Nt[1], b2: r.Nt[2], a2: r.Nt[3], invert: r.Pt ? 1 : 0, flipX: r.Bt ? 1 : 0, flipY: r.It ? 1 : 0, charRot: r.Tt, translationX: h, translationY: c, translationZ: l, rotationX: u, rotationY: f, rotationZ: d, curveParams0: g, curveParams1: v, depth: (n == null ? void 0 : n.depth) ?? 0, baseZ: (n == null ? void 0 : n.baseZ) ?? 0, geometryType: oe[this.be] ?? 0 };
    return this.Ae.ne(m);
  }
};
var de = { Ce: vt, Te: 6, ...G };
var ge = { Ce: new Float32Array([0, -0.5, 0, 0, 1, -0.5, 1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 1, 1, -0.5, 1, 0, 1, 0.5, 1, 1]), Te: 6, ...G };
var ve = { Ce: (function(o = 32) {
  const t = [], e = 2 * Math.PI / o;
  for (let i = 0; i < o; i++) {
    const s = i * e, r = (i + 1) % o * e, n = Math.cos(s), h = Math.sin(s), c = 0.5 * (n + 1), l = 0.5 * (h + 1), u = Math.cos(r), f = Math.sin(r), d = 0.5 * (u + 1), g = 0.5 * (f + 1);
    t.push(0, 0, 0.5, 0.5, n, h, c, l, u, f, d, g);
  }
  return new Float32Array(t);
})(32), Te: 96, ...G };
var me = { Ce: (function(o) {
  const t = [];
  for (let e = 0; e < o; e++) {
    const i = e / o, s = (e + 1) / o;
    t.push(i, 0, i, 0, i, 1, i, 1, s, 1, s, 1);
  }
  return new Float32Array(t);
})(32), Te: 96, ...G };
var Ae = { Ce: new Float32Array([0, 0, 0, 0, 1, 0, 1, 0, 0.5, 1, 0.5, 1]), Te: 3, ...G };
var pe = { Ce: (function(o = 16) {
  const t = [];
  for (let e = 0; e < o; e++) {
    const i = e / o, s = (e + 1) / o;
    t.push(i, -0.5, i, 0, s, -0.5, s, 0, i, 0.5, i, 1, i, 0.5, i, 1, s, -0.5, s, 0, s, 0.5, s, 1);
  }
  return new Float32Array(t);
})(16), Te: 96, ...G };
var ye = { [F.RECTANGLE]: class extends O {
  constructor(o, t) {
    super(o, t, F.RECTANGLE, de);
  }
  ge(o, t) {
    return this.Pe(0, 0, o.width, o.height, t);
  }
}, [F.LINE]: class extends O {
  constructor(o, t) {
    super(o, t, F.LINE, ge);
  }
  ge(o, t) {
    const e = o.x2 - o.x1, i = o.y2 - o.y1, s = Math.hypot(e, i), r = Math.atan2(i, e), n = t.Dt || 1, h = o.x1 + e / 2 - s / 2, c = o.y1 + i / 2, l = { ...t, wt: (t.wt || 0) + r };
    return this.Pe(h, c, s, n, l);
  }
}, [F.ELLIPSE]: class extends O {
  constructor(o, t) {
    super(o, t, F.ELLIPSE, ve);
  }
  ge(o, t) {
    return this.Pe(0, 0, o.width, o.height, t);
  }
}, [F.ARC]: class extends O {
  constructor(o, t) {
    super(o, t, F.ARC, me);
  }
  ge(o, t) {
    const e = o.start * Math.PI / 180, i = o.stop * Math.PI / 180;
    return this.Pe(0, 0, o.width, o.height, t, { arcStart: e, arcStop: i });
  }
}, [F.TRIANGLE]: class extends O {
  constructor(o, t) {
    super(o, t, F.TRIANGLE, Ae);
  }
  ge(o, t) {
    const e = Math.min(o.x1, o.x2, o.x3), i = Math.max(o.x1, o.x2, o.x3), s = Math.min(o.y1, o.y2, o.y3), r = i - e, n = Math.max(o.y1, o.y2, o.y3) - s;
    return this.Pe(e, s, r, n, t);
  }
}, [F.BEZIER_CURVE]: class extends O {
  constructor(o, t) {
    super(o, t, F.BEZIER_CURVE, pe);
  }
  ge(o, t) {
    return this.Pe(0, 0, 1, t.Dt || 1, t, { cp1x: o.cp1x, cp1y: o.cp1y, cp2x: o.cp2x, cp2y: o.cp2y, bezStartX: o.x1, bezStartY: o.y1, bezEndX: o.x2, bezEndY: o.y2 });
  }
} };
var Ee = class {
  constructor(t) {
    a(this, "A");
    a(this, "ze");
    a(this, "Se");
    this.A = t, this.Se = new ae(t), this.ze = /* @__PURE__ */ new Map();
    for (const e of Object.values(F)) {
      const i = new fe(t), s = new ye[e](t, i);
      this.ze.set(e, s);
    }
  }
  Re(t) {
    this.Ee(t).forEach((e) => {
      this.ke(e);
    });
  }
  Ee(t) {
    const e = [];
    let i = null, s = null, r = null;
    for (const n of t) s !== n.material || r !== n.type ? (i && i.length > 0 && e.push({ material: s, type: r, commands: i }), i = [n], s = n.material, r = n.type) : i.push(n);
    return i && i.length > 0 && e.push({ material: s, type: r, commands: i }), e;
  }
  ke(t) {
    const { material: e, type: i, commands: s } = t, r = this.ze.get(i);
    e.shader.D(), e.shader.H(e.uniforms);
    const n = St(this.A), h = s.length > 0 && s[0].state.St;
    if (e.shader.H({ UJ: n[2] / n[3], UG: [n[2], n[3]], UH: 1, UI: h ? 1 : 0 }), r.Me(), s.forEach((c) => {
      r.ge(c.params, c.state);
    }), r.Fe()) {
      const c = r.unitGeometry, l = r.unitBuffer;
      try {
        this.Se.Ps(e.shader.program, i + "", c, l), r.batch.de(e.shader), r.batch.Ms(c.gs, c.Te);
      } finally {
        r.batch.ve(e.shader), this.Se.Ts(), r.Me();
      }
    }
  }
  Fs() {
    for (const t of this.ze.values()) t.Fs();
    this.ze.clear(), this.Se.Fs();
  }
};
function Lt(o) {
  let t = 0;
  for (let e = 0; e < o.length; e++)
    t = (t << 5) - t + o.charCodeAt(e), t &= t;
  return t;
}
var bt = /* @__PURE__ */ new WeakMap();
var xe = 1;
function wt(o) {
  if (o == null) return 0;
  if (typeof o != "object" && typeof o != "function") return Lt(o + "");
  let t = bt.get(o);
  return t || (t = xe++, bt.set(o, t)), t;
}
function j(o, t) {
  return (o << 5) - o + t;
}
var be = class {
  constructor(t) {
    a(this, "De", 0);
    a(this, "Le");
    a(this, "He");
    a(this, "Oe", /* @__PURE__ */ new Map());
    this.Le = new Q(t, rt, `#version 300 es
precision highp float;in vec3 v_glyphIndex;in vec4 v_glyphColor;in vec4 v_cellColor;in vec4 v_glyphFlags;layout(location=0)out vec4 o_character;layout(location=1)out vec4 o_primaryColor;layout(location=2)out vec4 o_secondaryColor;layout(location=3)out vec4 A;void main(){int B=int(v_glyphFlags.r>0.5?1:0);int C=int(v_glyphFlags.g>0.5?1:0);int D=int(v_glyphFlags.b>0.5?1:0);float E=float(B|(C<<1)|(D<<2))/255.;o_character=vec4(v_glyphIndex.xy,E,clamp(v_glyphFlags.a,0.,1.));o_primaryColor=vec4(v_glyphColor.rgb,v_glyphColor.a);o_secondaryColor=vec4(v_cellColor.rgb,v_cellColor.a);A=vec4(0.);}`), this.He = { id: this.De++, shader: this.Le, uniforms: Object.freeze({}), hash: this.Be(this.Le, {}), isBuiltIn: true };
  }
  get Ie() {
    return this.He;
  }
  ft(t, e = {}, i = false) {
    const s = this.Be(t, e), r = this.Oe.get(s);
    if (r) return r;
    const n = { id: this.De++, shader: t, uniforms: Object.freeze({ ...e }), hash: s, isBuiltIn: i };
    return this.Oe.set(s, n), n;
  }
  Ge(t, e = {}) {
    return { id: this.De++, shader: t, uniforms: Object.freeze({ ...e }), hash: 0, isBuiltIn: false };
  }
  Be(t, e) {
    const i = wt(t.program), s = (function(r, n) {
      let h = 0;
      const c = Object.keys(r).sort();
      for (const l of c) h = j(h, Lt(l)), h = j(h, n(r[l]));
      return h;
    })(e, this.je.bind(this));
    return j(i, s);
  }
  je(t) {
    return typeof t == "number" || typeof t == "boolean" ? (function(e) {
      return typeof e == "boolean" ? e ? 1 : 0 : Math.floor(e);
    })(t) : Array.isArray(t) ? (function(e) {
      let i = 0;
      const s = Array.isArray(e[0]) ? e.flat() : e;
      for (const r of s) i = j(i, typeof r == "number" ? r : 0);
      return i;
    })(t) : t instanceof Float32Array || t instanceof Int32Array ? (function(e) {
      let i = 0;
      const s = Math.min(e.length, 16);
      for (let r = 0; r < s; r++) i = j(i, e[r]);
      return i;
    })(t) : t instanceof WebGLTexture ? wt(t) : 0;
  }
  Fs() {
    this.Le != this.Le && this.Le.dispose(), this.Le.dispose(), this.Oe.clear();
  }
};
var we = class {
  constructor() {
    a(this, "Ne", []);
    a(this, "Qe", 1);
    a(this, "Ss", 0);
  }
  Ye(t, e) {
    if (this.Ss >= this.Ne.length) {
      const s = { id: this.Qe++, type: t, params: {}, state: nt.kt(), material: e };
      this.Ne.push(s);
    }
    const i = this.Ne[this.Ss];
    return i.id = this.Qe++, i.type = t, i.material = e, this.Ss++, i;
  }
  Xe(t, e, i) {
    const s = this.Ye(F.RECTANGLE, i), r = s.params;
    return r.width = t.width, r.height = t.height, e.Xt(s.state), s.id;
  }
  We(t, e, i) {
    const s = this.Ye(F.LINE, i), r = s.params;
    return r.x1 = t.x1, r.y1 = t.y1, r.x2 = t.x2, r.y2 = t.y2, r.thickness = t.thickness, e.Xt(s.state), s.id;
  }
  Ke(t, e, i) {
    const s = this.Ye(F.ELLIPSE, i), r = s.params;
    return r.width = t.width, r.height = t.height, r.startAngle = t.startAngle, r.endAngle = t.endAngle, r.segments = t.segments, e.Xt(s.state), s.id;
  }
  Ze(t, e, i) {
    const s = this.Ye(F.ARC, i), r = s.params;
    return r.width = t.width, r.height = t.height, r.start = t.start, r.stop = t.stop, e.Xt(s.state), s.id;
  }
  qe(t, e, i) {
    const s = this.Ye(F.TRIANGLE, i), r = s.params;
    return r.x1 = t.x1, r.y1 = t.y1, r.x2 = t.x2, r.y2 = t.y2, r.x3 = t.x3, r.y3 = t.y3, e.Xt(s.state), s.id;
  }
  Ve(t, e, i) {
    const s = this.Ye(F.BEZIER_CURVE, i), r = s.params;
    return r.x1 = t.x1, r.y1 = t.y1, r.cp1x = t.cp1x, r.cp1y = t.cp1y, r.cp2x = t.cp2x, r.cp2y = t.cp2y, r.x2 = t.x2, r.y2 = t.y2, r.thickness = t.thickness, r.segments = t.segments, e.Xt(s.state), s.id;
  }
  ye() {
    this.Ss = 0;
  }
  [Symbol.iterator]() {
    let t = 0;
    const e = this.Ss, i = this.Ne;
    return { next: () => t < e ? { value: i[t++], done: false } : { value: void 0, done: true } };
  }
};
var Te = class {
  constructor(t) {
    a(this, "A");
    a(this, "Je", null);
    a(this, "ti");
    a(this, "dt");
    a(this, "si");
    a(this, "ei");
    a(this, "ii");
    a(this, "ri", null);
    a(this, "ni", {});
    a(this, "oi", []);
    a(this, "hi", []);
    a(this, "ai", []);
    a(this, "ci", null);
    a(this, "li", [0, 0, 0, 0]);
    a(this, "ui", 1);
    this.A = t, t.enable(t.DEPTH_TEST), t.depthFunc(t.LEQUAL), t.clearDepth(1), t.depthMask(true), t.disable(t.CULL_FACE), this.si = new nt(), this.dt = new be(t), this.ei = new we(), this.ti = new Ee(t), this.ii = new he(t);
    const e = [0, 0, t.canvas.width, t.canvas.height];
    at(t, e), this.oi.push(null), this.hi.push(e), this.ai.push(1), this.ci = null, this.li = e, this.ui = 1;
  }
  it() {
    this.oi.push(this.ci), this.hi.push([...this.li]), this.ai.push(this.ui);
  }
  ct() {
    const t = this.oi.pop() ?? null, e = this.hi.pop() ?? [0, 0, this.A.canvas.width, this.A.canvas.height], i = this.ai.pop() ?? 1;
    this.rt(t, e[2], e[3], i);
  }
  rt(t, e, i, s = 1) {
    const r = this.A;
    this.ci !== t && (r.bindFramebuffer(r.FRAMEBUFFER, t), this.ci = t), this.ui = s;
    const n = [0, 0, e, i];
    this.li[0] === n[0] && this.li[1] === n[1] && this.li[2] === n[2] && this.li[3] === n[3] || (r.viewport(...n), at(r, n), this.li = n);
  }
  fi(t) {
    this.Je !== t && (this.Je = t, t.D());
  }
  di(t, e) {
    return new Q(this.A, t, e);
  }
  pi(t) {
    this.ri = t, t && (this.ni = {});
  }
  O(t, e) {
    this.ni[t] = e;
  }
  mi(t) {
    Object.assign(this.ni, t);
  }
  gi(t) {
    return new Q(this.A, rt, t);
  }
  _i(t, e, i, s) {
    t instanceof Y || !s || t.yi(s), this.ei.Xe({ width: e ?? t.width, height: i ?? t.height }, this.si, t.lt());
  }
  Ai(t, e, i, s) {
    this.ii.Ms(t, e, i, s);
  }
  bi(t, e) {
    if (this.ri) {
      const i = this.dt.Ge(this.ri, this.ni);
      this.ei.Xe({ width: t, height: e }, this.si, i), this.ri = null, this.ni = {};
    } else this.ei.Xe({ width: t, height: e }, this.si, this.dt.Ie);
  }
  wi(t, e, i, s) {
    this.ei.We({ x1: t, y1: e, x2: i, y2: s }, this.si, this.dt.Ie);
  }
  xi(t, e) {
    this.ei.Ke({ width: t, height: e }, this.si, this.dt.Ie);
  }
  Ci(t, e, i, s, r, n) {
    this.ei.qe({ x1: t, y1: e, x2: i, y2: s, x3: r, y3: n }, this.si, this.dt.Ie);
  }
  Mi(t, e, i, s, r, n, h, c) {
    this.ei.Ve({ x1: t, y1: e, cp1x: i, cp1y: s, cp2x: r, cp2y: n, x2: h, y2: c }, this.si, this.dt.Ie);
  }
  Fi(t, e, i, s) {
    this.ei.Ze({ width: t, height: e, start: i, stop: s }, this.si, this.dt.Ie);
  }
  $i(t, e, i = 1, s = {}) {
    return new Y(this.A, t, e, i, s, this);
  }
  Pi(t, e = t, i = t, s = 255) {
    this.si.ds(t, e ?? t, i ?? t, s);
    const [r, n, h, c] = this.si.canvasBackgroundColor;
    this.Ti(r, n, h, c, false);
  }
  ye(t = 0, e = 0, i = 0, s = 0) {
    this.Ti(t, e, i, s, true);
  }
  Ti(t, e, i, s, r) {
    const n = this.A;
    if (this.ui > 1) {
      const h = r ? [1, 1, 0, 0] : [0, 0, 0, 0];
      n.clearBufferfv(n.COLOR, 0, new Float32Array(h)), n.clearBufferfv(n.COLOR, 1, new Float32Array([0, 0, 0, 0])), this.ui >= 3 && n.clearBufferfv(n.COLOR, 2, new Float32Array([t, e, i, s]));
      for (let c = 3; c < this.ui; c++) n.clearBufferfv(n.COLOR, c, new Float32Array([0, 0, 0, 0]));
    } else n.clearColor(t, e, i, s), n.clear(n.COLOR_BUFFER_BIT);
  }
  zi() {
    const t = [0, 0, this.A.canvas.width, this.A.canvas.height];
    this.A.viewport(...t), at(this.A, t), this.li = t, this.hi.length > 0 && (this.hi[0] = t);
  }
  ht() {
    const t = this.ei;
    this.ti.Re(t), t.ye(), this.Je = null;
  }
  Fs() {
    this.dt.Fs(), this.ti.Fs(), this.ii.Fs();
  }
  get context() {
    return this.A;
  }
  get state() {
    return this.si;
  }
  get materialManager() {
    return this.dt;
  }
};
var M = { readShort: (o, t) => (M.t.uint16[0] = o[t] << 8 | o[t + 1], M.t.int16[0]), readUshort: (o, t) => o[t] << 8 | o[t + 1], readUshorts(o, t, e) {
  const i = [];
  for (let s = 0; s < e; s++) i.push(M.readUshort(o, t + 2 * s));
  return i;
}, readUint(o, t) {
  const e = M.t.uint8;
  return e[3] = o[t], e[2] = o[t + 1], e[1] = o[t + 2], e[0] = o[t + 3], M.t.uint32[0];
}, readASCII(o, t, e) {
  let i = "";
  for (let s = 0; s < e; s++) i += String.fromCharCode(o[t + s]);
  return i;
}, t: (() => {
  const o = new ArrayBuffer(8);
  return { uint8: new Uint8Array(o), int16: new Int16Array(o), uint16: new Uint16Array(o), uint32: new Uint32Array(o) };
})() };
function J(o) {
  return o + 3 & -4;
}
function $(o, t, e) {
  o[t] = e >>> 8 & 255, o[t + 1] = 255 & e;
}
function N(o, t, e) {
  o[t] = e >>> 24 & 255, o[t + 1] = e >>> 16 & 255, o[t + 2] = e >>> 8 & 255, o[t + 3] = 255 & e;
}
function Fe(o, t, e) {
  for (let i = 0; i < e.length; i++) o[t + i] = 255 & e.charCodeAt(i);
}
function ct(o, t, e) {
  const i = t + e;
  let s = 0;
  const r = M.t;
  for (let n = t; n < i; n += 4) r.uint8[3] = o[n] || 0, r.uint8[2] = o[n + 1] || 0, r.uint8[1] = o[n + 2] || 0, r.uint8[0] = o[n + 3] || 0, s = s + (r.uint32[0] >>> 0) >>> 0;
  return s >>> 0;
}
var Re = class {
  constructor(t) {
    a(this, "b");
    a(this, "p", 0);
    a(this, "bitbuf", 0);
    a(this, "bitcnt", 0);
    this.b = t;
  }
  readBits(t) {
    for (; this.bitcnt < t; ) {
      const i = this.b[this.p++] || 0;
      this.bitbuf |= i << this.bitcnt, this.bitcnt += 8;
    }
    const e = this.bitbuf & (1 << t) - 1;
    return this.bitbuf >>>= t, this.bitcnt -= t, e;
  }
  alignToByte() {
    this.bitbuf = 0, this.bitcnt = 0;
  }
  get offset() {
    return this.p;
  }
};
function k(o) {
  let t = 32, e = 0;
  for (const h of o) h && (h < t && (t = h), h > e && (e = h));
  if (e === 0) return { min: 0, max: 0, table: /* @__PURE__ */ new Map() };
  const i = new Uint32Array(e + 1);
  for (const h of o) h && i[h]++;
  const s = new Uint32Array(e + 1);
  let r = 0;
  i[0] = 0;
  for (let h = 1; h <= e; h++) r = r + i[h - 1] << 1, s[h] = r;
  const n = /* @__PURE__ */ new Map();
  for (let h = 0; h < o.length; h++) {
    const c = o[h];
    if (!c) continue;
    const l = s[c]++;
    let u = n.get(c);
    u || (u = [], n.set(c, u)), u[Me(l, c)] = h;
  }
  return { min: t, max: e, table: n };
}
function lt(o, t) {
  let e = 0;
  for (let i = 1; i <= t.max; i++) {
    e |= o.readBits(1) << i - 1;
    const s = t.table.get(i);
    if (s && e < s.length) {
      const r = s[e];
      if (r !== void 0) return r;
    }
  }
  throw Error("Invalid Huffman code");
}
function Me(o, t) {
  let e = 0;
  for (let i = 0; i < t; i++) e = e << 1 | 1 & o, o >>>= 1;
  return e >>> 0;
}
function Ue(o) {
  if (o.length < 2) throw Error("ZLIB data too short");
  const t = o[0], e = o[1];
  if ((15 & t) != 8) throw Error("Unsupported ZLIB compression method");
  if (((t << 8) + e) % 31 != 0) throw Error("Bad ZLIB header check");
  let i = 2;
  32 & e && (i += 4);
  const s = [];
  return (function(r, n) {
    const h = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], c = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], u = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    let f = 0;
    for (; !f; ) {
      f = r.readBits(1);
      const d = r.readBits(2);
      if (d === 0) {
        r.alignToByte();
        const g = r.readBits(16);
        if ((65535 & (65535 ^ g)) !== r.readBits(16)) throw Error("DEFLATE uncompressed LEN/NLEN mismatch");
        for (let v = 0; v < g; v++) n.push(r.readBits(8));
      } else {
        if (d !== 1 && d !== 2) throw Error("Unsupported DEFLATE type");
        {
          let g, v;
          if (d === 1) {
            const m = Array(288).fill(0);
            for (let A = 0; A <= 143; A++) m[A] = 8;
            for (let A = 144; A <= 255; A++) m[A] = 9;
            for (let A = 256; A <= 279; A++) m[A] = 7;
            for (let A = 280; A <= 287; A++) m[A] = 8;
            g = k(m), v = k(Array(32).fill(5));
          } else {
            const m = r.readBits(5) + 257, A = r.readBits(5) + 1, p = r.readBits(4) + 4, x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], y = Array(19).fill(0);
            for (let R = 0; R < p; R++) y[x[R]] = r.readBits(3);
            const b = k(y), E = [];
            for (; E.length < m + A; ) {
              const R = lt(r, b);
              if (R <= 15) E.push(R);
              else if (R === 16) {
                const L = r.readBits(2) + 3, U = E[E.length - 1] || 0;
                for (let q = 0; q < L; q++) E.push(U);
              } else if (R === 17) {
                const L = r.readBits(3) + 3;
                for (let U = 0; U < L; U++) E.push(0);
              } else {
                if (R !== 18) throw Error("Invalid code length symbol");
                {
                  const L = r.readBits(7) + 11;
                  for (let U = 0; U < L; U++) E.push(0);
                }
              }
            }
            const w = E.slice(0, m), T = E.slice(m, m + A);
            g = k(w), v = k(T);
          }
          for (; ; ) {
            const m = lt(r, g);
            if (m < 256) n.push(m);
            else {
              if (m === 256) break;
              if (m > 256 && m < 286) {
                const A = m - 257;
                let p = h[A];
                const x = c[A];
                x && (p += r.readBits(x));
                const y = lt(r, v);
                if (y >= 30) throw Error("Invalid distance symbol");
                let b = l[y];
                const E = u[y];
                E && (b += r.readBits(E));
                const w = n.length - b;
                if (w < 0) throw Error("Invalid distance");
                for (let T = 0; T < p; T++) n.push(n[w + T] || 0);
              } else if (m === 286 || m === 287) throw Error("Reserved length symbol");
            }
          }
        }
      }
    }
  })(new Re(o.subarray(i)), s), new Uint8Array(s);
}
function Pe(o) {
  const t = M, e = new Uint8Array(o);
  if (t.readASCII(e, 0, 4) !== "wOFF") throw Error("Invalid WOFF signature");
  const i = t.readUint(e, 4), s = t.readUshort(e, 12), r = t.readUint(e, 16), n = [];
  let h = 44;
  for (let p = 0; p < s; p++) {
    const x = t.readASCII(e, h, 4), y = t.readUint(e, h + 4), b = t.readUint(e, h + 8), E = t.readUint(e, h + 12), w = t.readUint(e, h + 16);
    n.push({ tag: x, offset: y, compLength: b, origLength: E, checksum: w }), h += 20;
  }
  for (const p of n) {
    const x = new Uint8Array(e.buffer, p.offset, p.compLength);
    if (p.compLength === p.origLength) p.data = new Uint8Array(x);
    else if (p.data = Ue(x), p.data.length !== p.origLength) if (p.data.length < p.origLength) {
      const y = new Uint8Array(p.origLength);
      y.set(p.data), p.data = y;
    } else p.data = p.data.subarray(0, p.origLength);
  }
  const c = s;
  let l = 1, u = 0;
  for (; l << 1 <= c; ) l <<= 1, u++;
  const f = 16 * l, d = 16 * c - f;
  let g = 12 + 16 * c;
  const v = {};
  for (const p of n) v[p.tag] = g, g = J(g + p.data.length);
  const m = new Uint8Array(Math.max(r || 0, g));
  N(m, 0, i), $(m, 4, c), $(m, 6, f), $(m, 8, u), $(m, 10, d);
  let A = 12;
  for (const p of n) {
    Fe(m, A, p.tag), A += 4;
    let x = p.data;
    if (p.tag === "head" && x.length >= 12) {
      const y = new Uint8Array(x);
      N(y, 8, 0), N(m, A, ct(y, 0, J(y.length))), A += 4;
    } else
      N(m, A, ct(x, 0, J(x.length))), A += 4;
    N(m, A, v[p.tag]), A += 4, N(m, A, p.data.length), A += 4;
  }
  for (const p of n) {
    const x = v[p.tag];
    m.set(p.data, x);
  }
  if (n.find((p) => p.tag === "head")) {
    const p = v.head, x = (function(y, b) {
      const E = b + 8, w = [y[E], y[E + 1], y[E + 2], y[E + 3]];
      N(y, E, 0);
      const T = 2981146554 - (ct(y, 0, J(y.length)) >>> 0) >>> 0;
      return y[E] = w[0], y[E + 1] = w[1], y[E + 2] = w[2], y[E + 3] = w[3], T >>> 0;
    })(m, p);
    N(m, p + 8, x);
  }
  return m.buffer;
}
var Ce = { parseTab(o, t, e) {
  const i = { tables: [], ids: {}, off: t };
  o = new Uint8Array(o.buffer, t, e), t = 0;
  const s = M, r = s.readUshort;
  r(o, t);
  const n = r(o, t += 2);
  t += 2;
  const h = [];
  for (let c = 0; c < n; c++) {
    const l = r(o, t), u = r(o, t += 2);
    t += 2;
    const f = s.readUint(o, t);
    t += 4;
    const d = `p${l}e${u}`;
    let g = h.indexOf(f);
    if (g === -1) {
      let v;
      g = i.tables.length, h.push(f);
      const m = r(o, f);
      v = m === 4 ? this.parse4(o, f) : m === 12 ? this.parse12(o, f) : { format: m }, i.tables.push(v);
    }
    i.ids[d] = g;
  }
  return i;
}, parse4(o, t) {
  const e = M, i = e.readUshort, s = e.readUshorts, r = t, n = i(o, t += 2);
  i(o, t += 2);
  const h = i(o, t += 2) >>> 1, c = { format: 4, searchRange: i(o, t += 2), entrySelector: 0, rangeShift: 0, endCount: [], startCount: [], idDelta: [], idRangeOffset: [], glyphIdArray: [] };
  t += 2, c.entrySelector = i(o, t), t += 2, c.rangeShift = i(o, t), t += 2, c.endCount = s(o, t, h), t += 2 * h, t += 2, c.startCount = s(o, t, h), t += 2 * h;
  for (let l = 0; l < h; l++) c.idDelta.push(e.readShort(o, t)), t += 2;
  return c.idRangeOffset = s(o, t, h), t += 2 * h, c.glyphIdArray = s(o, t, r + n - t >> 1), c;
}, parse12(o, t) {
  const e = M.readUint;
  e(o, t += 4), e(o, t += 4);
  const i = e(o, t += 4);
  t += 4;
  const s = new Uint32Array(3 * i);
  for (let r = 0; r < 3 * i; r += 3) s[r] = e(o, t + (r << 2)), s[r + 1] = e(o, t + (r << 2) + 4), s[r + 2] = e(o, t + (r << 2) + 8);
  return { format: 12, groups: s };
} };
var Se = { parseTab(o, t, e) {
  const i = M;
  t += 18;
  const s = i.readUshort(o, t);
  t += 2, t += 16;
  const r = i.readShort(o, t);
  t += 2;
  const n = i.readShort(o, t);
  t += 2;
  const h = i.readShort(o, t);
  t += 2;
  const c = i.readShort(o, t);
  return t += 2, t += 6, { unitsPerEm: s, xMin: r, yMin: n, xMax: h, yMax: c, indexToLocFormat: i.readShort(o, t) };
} };
var Le = { parseTab(o, t, e) {
  const i = M;
  t += 4;
  const s = ["ascender", "descender", "lineGap", "advanceWidthMax", "minLeftSideBearing", "minRightSideBearing", "xMaxExtent", "caretSlopeRise", "caretSlopeRun", "caretOffset", "res0", "res1", "res2", "res3", "metricDataFormat", "numberOfHMetrics"], r = {};
  for (let n = 0; n < s.length; n++) {
    const h = s[n], c = h === "advanceWidthMax" || h === "numberOfHMetrics" ? i.readUshort : i.readShort;
    r[h] = c(o, t + 2 * n);
  }
  return r;
} };
var De = { parseTab(o, t, e, i) {
  const s = M, r = [], n = [], h = i.maxp.numGlyphs, c = i.hhea.numberOfHMetrics;
  let l = 0, u = 0, f = 0;
  for (; f < c; ) l = s.readUshort(o, t + (f << 2)), u = s.readShort(o, t + (f << 2) + 2), r.push(l), n.push(u), f++;
  for (; f < h; ) r.push(l), n.push(u), f++;
  return { aWidth: r, lsBearing: n };
} };
var Tt = { cmap: Ce, head: Se, hhea: Le, maxp: { parseTab(o, t, e) {
  const i = M;
  return i.readUint(o, t), t += 4, { numGlyphs: i.readUshort(o, t) };
} }, hmtx: De, loca: { parseTab(o, t, e, i) {
  const s = M, r = [], n = i.head.indexToLocFormat, h = i.maxp.numGlyphs + 1;
  if (n === 0) for (let c = 0; c < h; c++) r.push(s.readUshort(o, t + (c << 1)) << 1);
  else if (n === 1) for (let c = 0; c < h; c++) r.push(s.readUint(o, t + (c << 2)));
  return r;
} }, glyf: { parseTab(o, t, e, i) {
  const s = [], r = i.maxp.numGlyphs;
  for (let n = 0; n < r; n++) s.push(null);
  return s;
}, Si(o, t) {
  const e = M, i = o.Ri, s = o.loca;
  if (s[t] === s[t + 1]) return null;
  const r = V.findTable(i, "glyf", o.Ei);
  if (!r) return null;
  let n = r[0] + s[t];
  const h = {};
  if (h.noc = e.readShort(i, n), n += 2, h.xMin = e.readShort(i, n), n += 2, h.yMin = e.readShort(i, n), n += 2, h.xMax = e.readShort(i, n), n += 2, h.yMax = e.readShort(i, n), n += 2, h.xMin >= h.xMax || h.yMin >= h.yMax) return null;
  if (h.noc > 0) {
    h.endPts = [];
    for (let d = 0; d < h.noc; d++) h.endPts.push(e.readUshort(i, n)), n += 2;
    const c = e.readUshort(i, n);
    if (n += 2, i.length - n < c) return null;
    n += c;
    const l = h.endPts[h.noc - 1] + 1;
    h.flags = [];
    for (let d = 0; d < l; d++) {
      const g = i[n];
      if (n++, h.flags.push(g), 8 & g) {
        const v = i[n];
        n++;
        for (let m = 0; m < v; m++) h.flags.push(g), d++;
      }
    }
    h.xs = [];
    for (let d = 0; d < l; d++) {
      const g = h.flags[d], v = !!(16 & g);
      2 & g ? (h.xs.push(v ? i[n] : -i[n]), n++) : v ? h.xs.push(0) : (h.xs.push(e.readShort(i, n)), n += 2);
    }
    h.ys = [];
    for (let d = 0; d < l; d++) {
      const g = h.flags[d], v = !!(32 & g);
      4 & g ? (h.ys.push(v ? i[n] : -i[n]), n++) : v ? h.ys.push(0) : (h.ys.push(e.readShort(i, n)), n += 2);
    }
    let u = 0, f = 0;
    for (let d = 0; d < l; d++) u += h.xs[d], f += h.ys[d], h.xs[d] = u, h.ys[d] = f;
  } else h.parts = [], h.endPts = [], h.flags = [], h.xs = [], h.ys = [];
  return h;
} } };
var V = { parse(o) {
  const t = new Uint8Array(o);
  M.readASCII(t, 0, 4) === "wOFF" && (o = Pe(o));
  const e = new Uint8Array(o), i = Tt, s = {}, r = { Ri: e, ki: 0, Ei: 0 };
  for (const n in i) {
    const h = n, c = V.findTable(e, h, 0);
    if (c) {
      const [l, u] = c;
      let f = s[l];
      f == null && (f = i[h].parseTab(e, l, u, r), s[l] = f), r[h] = f;
    }
  }
  return [r];
}, findTable(o, t, e) {
  const i = M, s = i.readUshort(o, e + 4);
  let r = e + 12;
  for (let n = 0; n < s; n++) {
    const h = i.readASCII(o, r, 4);
    i.readUint(o, r + 4);
    const c = i.readUint(o, r + 8), l = i.readUint(o, r + 12);
    if (h === t) return [c, l];
    r += 16;
  }
  return null;
}, T: Tt, B: M };
var ze = class {
  Di(t) {
    var i;
    const e = [];
    return (i = t.cmap) != null && i.tables ? (t.cmap.tables.forEach((s) => {
      if (s.format === 4) {
        const r = this.Li(s);
        e.push(...r);
      } else if (s.format === 12) {
        const r = this.Hi(s);
        e.push(...r);
      }
    }), [...new Set(e)]) : [];
  }
  Li(t) {
    const e = [];
    if (!(t.startCount && t.endCount && t.idRangeOffset && t.idDelta)) return e;
    for (let i = 0; i < t.startCount.length; i++) {
      const s = t.startCount[i], r = t.endCount[i];
      if (s !== 65535 || r !== 65535) {
        for (let n = s; n <= r; n++)
          if (this.Oi(t, n, i) > 0) try {
            const h = String.fromCodePoint(n);
            e.push(h);
          } catch {
          }
      }
    }
    return e;
  }
  Hi(t) {
    const e = [];
    if (!t.groups) return e;
    for (let i = 0; i < t.groups.length; i += 3) {
      const s = t.groups[i], r = t.groups[i + 1], n = t.groups[i + 2];
      for (let h = s; h <= r; h++)
        if (n + (h - s) > 0) try {
          const c = String.fromCodePoint(h);
          e.push(c);
        } catch {
        }
    }
    return e;
  }
  Oi(t, e, i) {
    if (t.idRangeOffset[i] === 0) return e + t.idDelta[i] & 65535;
    {
      const s = t.idRangeOffset[i] / 2 + (e - t.startCount[i]) - (t.startCount.length - i);
      if (s >= 0 && t.glyphIdArray && s < t.glyphIdArray.length) {
        const r = t.glyphIdArray[s];
        if (r !== 0) return r + t.idDelta[i] & 65535;
      }
    }
    return 0;
  }
};
var Ne = class {
  constructor(t) {
    a(this, "Bi");
    a(this, "Ii");
    a(this, "K");
    this.K = t, this.Bi = document.createElement("canvas"), this.Ii = this.Bi.getContext("2d", { willReadFrequently: true, alpha: true });
  }
  Gi(t, e, i, s) {
    const r = t.length, n = Math.ceil(Math.sqrt(r)), h = Math.ceil(r / n), c = e.width * n, l = e.height * h;
    this.ji(c, l), this.Ni(t, e, n, i, s);
    const u = this.K.$i(c, l, 1, { filter: "nearest" });
    return u.et(this.Bi), { framebuffer: u, columns: n, rows: h };
  }
  ji(t, e) {
    this.Bi.width = t, this.Bi.height = e, this.Bi.style.width = t + "px", this.Bi.style.height = e + "px", this.Ii.imageSmoothingEnabled = false, this.Bi.style.imageRendering = "pixelated", this.Ii.clearRect(0, 0, t, e), this.Ii.textBaseline = "top", this.Ii.textAlign = "left", this.Ii.fillStyle = "white";
  }
  Ni(t, e, i, s, r) {
    const n = s / r.head.unitsPerEm;
    for (let h = 0; h < t.length; h++) {
      const c = h % i, l = Math.floor(h / i), u = t[h].glyphData;
      if (!u) continue;
      const f = u.advanceWidth * n, d = c * e.width, g = l * e.height, v = d + 0.5 * e.width, m = g + 0.5 * e.height, A = Math.round(v - 0.5 * e.width), p = Math.round(m - 0.5 * s), x = A + 0.5 * (e.width - f), y = p + r.hhea.ascender * n;
      this.Qi(u, x, y, n);
    }
  }
  Qi(t, e, i, s) {
    if (!t || !t.xs || t.noc === 0) return;
    let { xs: r, ys: n, endPts: h, flags: c } = t;
    if (!(r && n && h && c)) return;
    this.Ii.beginPath();
    let l = 0;
    for (let u = 0; u < h.length; u++) {
      const f = h[u];
      if (!(f < l)) {
        if (f >= l) {
          const d = e + r[l] * s, g = i - n[l] * s;
          this.Ii.moveTo(d, g);
          let v = l + 1;
          for (; v <= f; )
            if (1 & c[v]) {
              const m = e + r[v] * s, A = i - n[v] * s;
              this.Ii.lineTo(m, A), v++;
            } else {
              const m = e + r[v] * s, A = i - n[v] * s;
              if (v + 1 > f) {
                const x = e + r[l] * s, y = i - n[l] * s;
                if (1 & c[l]) this.Ii.quadraticCurveTo(m, A, x, y);
                else {
                  const b = (m + x) / 2, E = (A + y) / 2;
                  this.Ii.quadraticCurveTo(m, A, b, E);
                }
                break;
              }
              const p = v + 1;
              if (1 & c[p]) {
                const x = e + r[p] * s, y = i - n[p] * s;
                this.Ii.quadraticCurveTo(m, A, x, y), v = p + 1;
              } else {
                const x = (m + (e + r[p] * s)) / 2, y = (A + (i - n[p] * s)) / 2;
                this.Ii.quadraticCurveTo(m, A, x, y), v = p;
              }
            }
          this.Ii.closePath();
        }
        l = f + 1;
      }
    }
    this.Ii.fill();
  }
};
var Dt = class {
  Yi(t, e) {
    const i = t.cmap;
    if (!i || !i.tables) return 0;
    let s = 0;
    for (const r of i.tables) if (r.format === 4 ? s = this.Xi(e, r) : r.format === 12 && (s = this.Wi(e, r)), s > 0) break;
    return s;
  }
  Ki(t, e) {
    const i = e.codePointAt(0);
    return i === void 0 ? 0 : this.Yi(t, i);
  }
  Zi(t, e) {
    const i = t.hmtx;
    return i && i.aWidth && i.aWidth.length !== 0 ? e < i.aWidth.length ? i.aWidth[e] : i.aWidth[i.aWidth.length - 1] : 0;
  }
  qi(t, e) {
    const i = e / t.head.unitsPerEm, s = t.hhea.ascender * i, r = t.hhea.descender * i, n = t.hhea.lineGap * i;
    return { ascender: s, descender: r, lineGap: n, lineHeight: s - r + n, unitsPerEm: t.head.unitsPerEm, scale: i };
  }
  Xi(t, e) {
    const i = e.endCount.length;
    let s = -1;
    for (let r = 0; r < i; r++) if (t <= e.endCount[r]) {
      s = r;
      break;
    }
    if (s === -1 || t < e.startCount[s]) return 0;
    if (e.idRangeOffset[s] === 0) return t + e.idDelta[s] & 65535;
    {
      const r = e.idRangeOffset[s] / 2 + (t - e.startCount[s]) - (i - s);
      if (r >= 0 && r < e.glyphIdArray.length) {
        const n = e.glyphIdArray[r];
        return n === 0 ? 0 : n + e.idDelta[s] & 65535;
      }
    }
    return 0;
  }
  Wi(t, e) {
    const i = e.groups.length / 3;
    for (let s = 0; s < i; s++) {
      const r = e.groups[3 * s], n = e.groups[3 * s + 1], h = e.groups[3 * s + 2];
      if (t >= r && t <= n) return h + (t - r);
    }
    return 0;
  }
};
var Be = class {
  constructor() {
    a(this, "Vi");
    this.Vi = new Dt();
  }
  Ji(t, e, i) {
    let s = 0;
    const r = this.Vi.qi(i, e), n = r.lineHeight;
    for (const h of t) {
      const c = this.Vi.Ki(i, h);
      if (c === 0) continue;
      const l = this.Vi.Zi(i, c) * r.scale;
      s = Math.max(s, l);
    }
    return { width: Math.ceil(s), height: Math.ceil(n) };
  }
};
var _e = class {
  constructor() {
    a(this, "tr");
    this.tr = new Dt();
  }
  sr(t, e) {
    const i = [], s = /* @__PURE__ */ new Map();
    return t.forEach((r, n) => {
      const h = r.codePointAt(0) || 0, c = { character: r, unicode: h, color: this.er(n), glyphData: this.ir(e, r) };
      i.push(c), s.set(r, c);
    }), { array: i, map: s };
  }
  er(t) {
    return [t % 256 / 255, Math.floor(t / 256) % 256 / 255, 0];
  }
  ir(t, e) {
    const i = e.codePointAt(0) || 0, s = this.tr.Yi(t, i);
    if (s === 0) return null;
    let r = 0;
    t.hmtx && t.hmtx.aWidth && s > 0 && t.hmtx.aWidth[s] !== void 0 && (r = t.hmtx.aWidth[s]);
    const n = V.T.glyf.Si(t, s);
    return n ? { ...n, advanceWidth: r } : null;
  }
};
var it = class {
  constructor(t, e = 16) {
    a(this, "rr");
    a(this, "nr", []);
    a(this, "hr", /* @__PURE__ */ new Map());
    a(this, "ar");
    a(this, "cr", 16);
    a(this, "lr", 0);
    a(this, "ur", 0);
    a(this, "dr", { width: 0, height: 0 });
    a(this, "vr");
    a(this, "pr");
    a(this, "mr");
    a(this, "gr");
    a(this, "_r");
    a(this, "yr", false);
    this.cr = e, this.pr = new ze(), this.mr = new Ne(t), this.gr = new Be(), this._r = new _e();
  }
  async Ar(t) {
    if (this.yr) return;
    let e;
    if (t) {
      const i = await fetch(t);
      if (!i.ok) throw new S(`Failed to load font file: ${i.status} ${i.statusText}`);
      e = await i.arrayBuffer();
    } else
      e = await (await fetch("data:font/woff;base64,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")).arrayBuffer();
    await this.br(e), this.rr = V.parse(e)[0], await this.wr();
  }
  Cr(t) {
    if (t === void 0) return this.cr;
    this.cr = t, this.dr = this.gr.Ji(this.nr.map((i) => i.character), this.cr, this.rr);
    const e = this.mr.Gi(this.nr, this.dr, this.cr, this.rr);
    this.ar = e.framebuffer, this.lr = e.columns, this.ur = e.rows;
  }
  async Mr(t) {
    try {
      const e = await fetch(t);
      if (!e.ok) throw new S(`Failed to load font file: ${e.status} ${e.statusText}`);
      const i = await e.arrayBuffer();
      await this.br(i);
      const s = V.parse(i);
      if (!s || s.length === 0) throw Error("Failed to parse font file");
      this.rr = s[0], await this.wr();
    } catch (e) {
      throw new S("Failed to load font: " + (e instanceof Error ? e.message : "Unknown error"), e);
    }
  }
  async br(t) {
    const e = Date.now();
    this.vr = new FontFace("CustomFont_" + e, t), await this.vr.load(), document.fonts.add(this.vr);
  }
  async wr() {
    const t = this.pr.Di(this.rr), { array: e, map: i } = this._r.sr(t, this.rr);
    this.nr = e, this.hr = i, this.dr = this.gr.Ji(t, this.cr, this.rr);
    const s = this.mr.Gi(this.nr, this.dr, this.cr, this.rr);
    this.ar = s.framebuffer, this.lr = s.columns, this.ur = s.rows, this.yr = true;
  }
  Fr(t) {
    const e = this.hr.get(t);
    return e ? e.color : [0, 0, 0];
  }
  $r(t) {
    return Array.from(t).map((e) => {
      const i = this.hr.get(e);
      return i ? i.color : [0, 0, 0];
    });
  }
  Fs() {
    this.ar.dispose(), document.fonts.delete(this.vr);
  }
  get Pr() {
    return this.yr;
  }
  get fontFramebuffer() {
    return this.ar;
  }
  get characterMap() {
    return this.hr;
  }
  get characters() {
    return this.nr;
  }
  get textureColumns() {
    return this.lr;
  }
  get textureRows() {
    return this.ur;
  }
  get maxGlyphDimensions() {
    return this.dr;
  }
  get fontSize() {
    return this.cr;
  }
  get font() {
    return this.rr;
  }
};
var Oe = class {
  constructor(t, e, i) {
    a(this, "Tr");
    a(this, "zr");
    a(this, "G");
    a(this, "j");
    a(this, "Sr");
    a(this, "Rr");
    a(this, "Er");
    a(this, "kr");
    a(this, "Dr");
    a(this, "Lr", false);
    a(this, "Hr", /* @__PURE__ */ new Set());
    this.Er = t, this.kr = e, this.Dr = i, this.Js();
  }
  Or() {
    if (this.G = this.Tr * this.kr, this.j = this.zr * this.Dr, this.Sr = Math.floor((this.Er.width - this.G) / 2), this.Rr = Math.floor((this.Er.height - this.j) / 2), this.Hr.size > 0) for (const t of this.Hr) t();
  }
  Br(t) {
    this.Hr.add(t);
  }
  Ir(t) {
    this.Hr.delete(t);
  }
  Js() {
    this.Lr || (this.Tr = Math.floor(this.Er.width / this.kr), this.zr = Math.floor(this.Er.height / this.Dr)), this.Or();
  }
  Gr(t, e) {
    this.kr = t, this.Dr = e, this.Js();
  }
  get cellWidth() {
    return this.kr;
  }
  get cellHeight() {
    return this.Dr;
  }
  get cols() {
    return this.Tr;
  }
  set cols(t) {
    this.Lr = true, this.Tr = Math.max(1, Math.floor(t)), typeof this.zr != "number" && (this.zr = Math.max(1, Math.floor(this.Er.height / this.Dr))), this.Or();
  }
  get rows() {
    return this.zr;
  }
  set rows(t) {
    this.Lr = true, this.zr = Math.max(1, Math.floor(t)), typeof this.Tr != "number" && (this.Tr = Math.max(1, Math.floor(this.Er.width / this.kr))), this.Or();
  }
  get width() {
    return this.G;
  }
  get height() {
    return this.j;
  }
  get offsetX() {
    return this.Sr;
  }
  get offsetY() {
    return this.Rr;
  }
  responsive() {
    this.Lr = false;
  }
  Fs() {
    this.Hr.clear();
  }
};
var Ie = /^rgba?\(([^)]+)\)$/i;
function ut(o) {
  return Number.isNaN(o) ? 0 : Math.max(0, Math.min(255, o));
}
function Xe(o) {
  if (!o) return null;
  const t = o.trim().toLowerCase();
  if (!t) return null;
  let e = null;
  return t.startsWith("rgb") && (e = (function(i) {
    const s = Ie.exec(i.trim());
    if (!s) return null;
    const r = s[1].split(",").map((u) => u.trim());
    if (r.length < 3) return null;
    const n = ut(parseFloat(r[0])), h = ut(parseFloat(r[1])), c = ut(parseFloat(r[2])), l = r[3] !== void 0 ? 255 * Math.max(0, Math.min(1, parseFloat(r[3]))) : 255;
    return [n, h, c, Math.round(l)];
  })(t)), e ? e[3] === 0 ? null : e : null;
}
var Ke = class {
  constructor(t = {}) {
    a(this, "Er");
    a(this, "jr", null);
    a(this, "Nr", false);
    a(this, "Qr");
    this.Nr = t.overlay ?? false, this.Nr && t.canvas ? (this.jr = t.canvas, this.Er = this.Yr(), this.Qr = true, this.Xr()) : t.canvas ? (this.Er = t.canvas, this.Qr = false) : (this.Er = this.Wr(t.width, t.height), this.Qr = true), this.Er.style.imageRendering = "pixelated";
  }
  Wr(t, e) {
    const i = document.createElement("canvas");
    return i.className = "textmodeCanvas", i.style.imageRendering = "pixelated", i.width = t || 800, i.height = e || 600, document.body.appendChild(i), i;
  }
  Yr() {
    const t = document.createElement("canvas");
    t.className = "textmodeCanvas", t.style.imageRendering = "pixelated";
    const e = this.jr.getBoundingClientRect();
    let i = Math.round(e.width), s = Math.round(e.height);
    if (this.jr instanceof HTMLVideoElement) {
      const h = this.jr;
      (i === 0 || s === 0) && h.videoWidth > 0 && h.videoHeight > 0 && (i = h.videoWidth, s = h.videoHeight);
    }
    t.width = i, t.height = s, t.style.position = "absolute", t.style.pointerEvents = "none";
    const r = window.getComputedStyle(this.jr);
    let n = parseInt(r.zIndex || "0", 10);
    return isNaN(n) && (n = 0), t.style.zIndex = "" + (n + 1), t;
  }
  Xr() {
    var t;
    this.Kr(), (t = this.jr.parentNode) == null || t.insertBefore(this.Er, this.jr.nextSibling);
  }
  Zr() {
    const t = [];
    return this.Nr && this.jr instanceof HTMLElement && (t.push(this.jr), this.jr.parentElement && t.push(this.jr.parentElement)), this.Er.parentElement && t.push(this.Er.parentElement), t.push(this.Er), t.push(document.body), t.push(document.documentElement), t;
  }
  qr() {
    const t = this.Zr();
    for (const e of t) {
      if (!e) continue;
      const i = Xe(window.getComputedStyle(e).backgroundColor);
      if (i) return i;
    }
    return [255, 255, 255, 255];
  }
  Kr() {
    if (!this.jr) return;
    const t = this.jr.getBoundingClientRect();
    let e = this.jr.offsetParent;
    if (e && e !== document.body) {
      const i = e.getBoundingClientRect();
      this.Er.style.top = t.top - i.top + "px", this.Er.style.left = t.left - i.left + "px";
    } else this.Er.style.top = t.top + window.scrollY + "px", this.Er.style.left = t.left + window.scrollX + "px";
  }
  Vr(t, e) {
    if (this.Nr) {
      const i = this.jr.getBoundingClientRect();
      this.Er.width = Math.round(i.width), this.Er.height = Math.round(i.height), this.Kr();
    } else this.Er.width = t ?? this.Er.width, this.Er.height = e ?? this.Er.height;
  }
  Jr() {
    const t = this.Er.getContext("webgl2", { alpha: true, premultipliedAlpha: false, preserveDrawingBuffer: true, antialias: false, depth: true, stencil: false, powerPreference: "high-performance" });
    if (!t) throw new S("`textmode.js` requires WebGL2 support.");
    return t;
  }
  Fs() {
    const t = this.Er.getContext("webgl") || this.Er.getContext("webgl2");
    if (t) {
      const e = t.getExtension("WEBGL_lose_context");
      e == null || e.loseContext();
    }
    this.Qr && this.Er.parentNode && this.Er.parentNode.removeChild(this.Er);
  }
  get canvas() {
    return this.Er;
  }
  get targetCanvas() {
    return this.jr;
  }
  get width() {
    return this.Er.width;
  }
  get height() {
    return this.Er.height;
  }
};
function tt(o) {
  return X(parseInt(o, 16), 0, 255);
}
var C = class _C {
  constructor(t, e, i, s) {
    a(this, "tn");
    a(this, "sn");
    a(this, "r");
    a(this, "g");
    a(this, "b");
    a(this, "a");
    this.r = X(t, 0, 255), this.g = X(e, 0, 255), this.b = X(i, 0, 255), this.a = X(s, 0, 255), this.tn = [this.r, this.g, this.b, this.a], this.sn = [this.r / 255, this.g / 255, this.b / 255, this.a / 255];
  }
  static en(t, e, i, s) {
    if (_C.rn(t)) return t;
    if (Array.isArray(t)) {
      if (t.length < 3) throw Error("Component tuples must include at least RGB values.");
      const [r, n, h] = t, c = t.length === 4 ? t[3] : 255;
      return _C.nn(r, n, h, c);
    }
    if (typeof t == "string") {
      const r = t.trim();
      if (r.length === 0) throw Error("Color strings cannot be empty.");
      return _C.hn(r);
    }
    if (typeof t == "number") return typeof e == "number" && typeof i == "number" ? _C.nn(t, e, i, s ?? 255) : _C.an(t);
    throw Error("Unsupported color input passed to TextmodeColor.$from.");
  }
  static nn(t, e, i, s = 255) {
    return new _C(t, e, i, s);
  }
  static an(t, e = 255) {
    return new _C(t, t, t, e);
  }
  static hn(t) {
    return new _C(...(function(e) {
      const i = e.replace(/^#|0x/gi, ""), s = (r = i).length === 3 || r.length === 4 ? r.split("").map((n) => n + n).join("") : r;
      var r;
      if (s.length !== 6 && s.length !== 8) throw Error("Invalid hex color: " + e);
      return [tt(s.slice(0, 2)), tt(s.slice(2, 4)), tt(s.slice(4, 6)), s.length === 8 ? tt(s.slice(6, 8)) : 255];
    })(t));
  }
  get rgb() {
    return [this.r, this.g, this.b];
  }
  get rgba() {
    return [...this.tn];
  }
  get normalized() {
    return [...this.sn];
  }
  withAlpha(t) {
    return new _C(this.r, this.g, this.b, t);
  }
  static rn(t) {
    return t instanceof _C;
  }
};
var zt = class {
  constructor(t, e, i, s, r, n, h, c) {
    a(this, "A");
    a(this, "K");
    a(this, "cn");
    a(this, "ln");
    a(this, "un");
    a(this, "G");
    a(this, "j");
    a(this, "Z", null);
    a(this, "fn", null);
    a(this, "dn", "brightness");
    a(this, "vn", null);
    a(this, "pn");
    a(this, "Pt", 0);
    a(this, "Bt", 0);
    a(this, "It", 0);
    a(this, "Tt", 0);
    a(this, "mn", "sampled");
    a(this, "gn", "fixed");
    a(this, "jt", [1, 1, 1, 1]);
    a(this, "Nt", [0, 0, 0, 1]);
    a(this, "_n", [0, 0, 0, 1]);
    a(this, "yn", [[0.1, 0, 0]]);
    a(this, "An", null);
    this.A = t, this.K = e, this.cn = i, this.pn = s, this.ln = r, this.un = n, this.G = h, this.j = c;
  }
  conversionMode(t) {
    return this.dn = t, this.vn = null, this.Z = null, this;
  }
  Fs() {
    this.A.deleteTexture(this.cn);
  }
  invert(t = true) {
    return this.Pt = t ? 1 : 0, this.Z = null, this;
  }
  flipX(t = true) {
    return this.Bt = t ? 1 : 0, this.Z = null, this;
  }
  flipY(t = true) {
    return this.It = t ? 1 : 0, this.Z = null, this;
  }
  charRotation(t) {
    return this.Tt = Mt(t), this.Z = null, this;
  }
  charColorMode(t) {
    return this.mn = t, this.Z = null, this;
  }
  cellColorMode(t) {
    return this.gn = t, this.Z = null, this;
  }
  charColor(t, e, i, s) {
    return this.bn(this.jt, t, e, i, s), this.Z = null, this;
  }
  cellColor(t, e, i, s) {
    return this.bn(this.Nt, t, e, i, s), this.Z = null, this;
  }
  background(t, e, i, s) {
    return this.bn(this._n, t, e, i, s), this.Z = null, this;
  }
  characters(t) {
    return this.An = t, this.wn(t), this.Z = null, this;
  }
  yi(t) {
    this.fn !== t && (this.fn = t, this.An && this.wn(this.An), this.Z = null);
  }
  get texture() {
    return this.cn;
  }
  get width() {
    return this.G;
  }
  get height() {
    return this.j;
  }
  get originalWidth() {
    return this.ln;
  }
  get originalHeight() {
    return this.un;
  }
  lt() {
    return this.Z || this.ut(), this.Z;
  }
  xn() {
  }
  ut() {
    this.xn();
    const t = this.Cn(), e = this.Mn(), i = t.createShader(e), s = t.createUniforms(e);
    this.Z = this.K.materialManager.Ge(i, s);
  }
  bn(t, e, i, s, r) {
    const n = C.en(e, i, s, r);
    et(t, n.r, n.g, n.b, n.a);
  }
  wn(t) {
    if (!this.fn) return;
    const e = this.fn.$r(t).filter((i) => Array.isArray(i)).slice(0, 255);
    this.yn = e.length > 0 ? e : this.yn;
  }
  createBaseConversionUniforms() {
    return { u_image: this.Fn(), u_invert: !!this.Pt, u_flipX: !!this.Bt, u_flipY: !!this.It, u_charRotation: this.Tt, u_charColorFixed: this.mn === "fixed", u_charColor: this.jt, u_cellColorFixed: this.gn === "fixed", u_cellColor: this.Nt, u_backgroundColor: this._n, u_charCount: this.yn.length, u_charList: this.yn };
  }
  Cn() {
    if (this.vn && this.vn.id === this.dn) return this.vn;
    const t = this.pn.$n(this.dn);
    if (!t) throw Error(`[textmode.js] Conversion mode "${this.dn}" is not registered. If this mode is provided by an add-on, make sure its plugin is installed before loading sources.`);
    return this.vn = t, t;
  }
  Mn() {
    if (!this.fn) throw Error("[textmode.js] Cannot create conversion context: no active font set. Ensure $setActiveFont() is called before rendering.");
    return { renderer: this.K, gl: this.A, font: this.fn, source: this, gridWidth: this.G, gridHeight: this.j };
  }
};
var Z = class _Z extends zt {
  constructor(t, e, i, s, r, n, h, c) {
    const l = Math.min(h / r, c / n);
    super(t, e, i, s, r, n, Math.max(1, Math.floor(r * l)), Math.max(1, Math.floor(n * l)));
  }
  static Pn(t, e, i, s, r) {
    const n = t.context, h = n.createTexture();
    n.bindTexture(n.TEXTURE_2D, h), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, 1), pt(n, n.NEAREST, n.NEAREST, n.CLAMP_TO_EDGE, n.CLAMP_TO_EDGE), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, i), n.bindTexture(n.TEXTURE_2D, null);
    const c = i.naturalWidth ?? i.width ?? i.videoWidth ?? 0, l = i.naturalHeight ?? i.height ?? i.videoHeight ?? 0;
    return new _Z(n, t, h, e, c, l, s, r);
  }
  Fn() {
    return this.cn;
  }
};
var Nt = class {
  constructor(t = 60) {
    a(this, "Tn");
    a(this, "zn", null);
    a(this, "Sn", 0);
    a(this, "Rn", true);
    a(this, "En", 0);
    a(this, "kn", 0);
    a(this, "Dn", []);
    a(this, "Ln", 10);
    a(this, "Hn", 0);
    a(this, "On", 0);
    a(this, "Bn", -1);
    this.Tn = 1e3 / t;
  }
  In(t) {
    if (!this.Rn) return;
    this.Bn === -1 && (this.Bn = performance.now()), this.Sn = performance.now();
    const e = (i) => {
      if (!this.Rn) return void (this.zn = null);
      const s = i - this.Sn;
      s >= this.Tn && (t(), this.Sn = i - s % this.Tn), this.Rn && (this.zn = requestAnimationFrame(e));
    };
    this.zn = requestAnimationFrame(e);
  }
  Gn() {
    this.zn && (cancelAnimationFrame(this.zn), this.zn = null);
  }
  jn() {
    this.Rn && (this.Rn = false, this.Gn());
  }
  Nn(t) {
    this.Rn || (this.Rn = true, this.In(t));
  }
  Qn(t, e) {
    if (t === void 0) return this.En;
    this.Tn = 1e3 / t, this.Rn && e && (this.Gn(), this.In(e));
  }
  Yn() {
    const t = performance.now();
    if (this.kn > 0) {
      const e = t - this.kn;
      this.Hn = e, this.Dn.push(e), this.Dn.length > this.Ln && this.Dn.shift();
      const i = this.Dn.reduce((s, r) => s + r, 0) / this.Dn.length;
      this.En = 1e3 / i;
    }
    this.kn = t;
  }
  get Xn() {
    return this.Rn;
  }
  get Wn() {
    return this.En;
  }
  get Kn() {
    return this.On;
  }
  set Kn(t) {
    this.On = t;
  }
  Zn() {
    this.On++;
  }
  qn() {
    return this.Bn === -1 ? 0 : performance.now() - this.Bn;
  }
  Vn() {
    return this.qn() / 1e3;
  }
  get Jn() {
    return this.Hn;
  }
};
var Bt = class {
  constructor(t, e) {
    a(this, "Er");
    a(this, "so");
    a(this, "eo", { x: -1 / 0, y: -1 / 0 });
    a(this, "io", { x: -1 / 0, y: -1 / 0 });
    a(this, "ro", null);
    a(this, "no", 0);
    a(this, "oo");
    a(this, "ho");
    a(this, "ao");
    a(this, "co");
    a(this, "lo");
    a(this, "uo");
    a(this, "fo", false);
    a(this, "do");
    a(this, "vo");
    a(this, "po");
    a(this, "mo");
    a(this, "_o");
    this.Er = t, this.so = e;
  }
  yo(t) {
    const e = performance.now() + Math.max(0, t);
    e > this.no && (this.no = e);
  }
  Ao() {
    return performance.now() < this.no;
  }
  bo(t) {
    const e = this.Er.canvas;
    e.style.cursor = t == null || t === "" ? "" : t;
  }
  wo() {
    if (this.fo) return;
    const t = this.Er.canvas;
    this.oo = (e) => {
      this.xo(e), this.Co(e);
    }, this.ho = () => {
      this.io = { ...this.eo }, this.eo.x = -1 / 0, this.eo.y = -1 / 0, this.ro = null;
    }, this.ao = (e) => {
      this.xo(e), this.Mo(e);
    }, this.co = (e) => {
      this.xo(e), this.Fo(e);
    }, this.lo = (e) => {
      this.xo(e), this.$o(e);
    }, this.uo = (e) => {
      this.xo(e), this.Po(e);
    }, t.addEventListener("mousemove", this.oo, { passive: true }), t.addEventListener("mouseleave", this.ho, { passive: true }), t.addEventListener("mousedown", this.ao, { passive: true }), t.addEventListener("mouseup", this.co, { passive: true }), t.addEventListener("click", this.lo, { passive: true }), t.addEventListener("wheel", this.uo, { passive: false }), this.fo = true;
  }
  To() {
    if (!this.fo) return;
    const t = this.Er.canvas;
    t.removeEventListener("mousemove", this.oo), t.removeEventListener("mouseleave", this.ho), t.removeEventListener("mousedown", this.ao), t.removeEventListener("mouseup", this.co), t.removeEventListener("click", this.lo), t.removeEventListener("wheel", this.uo), this.fo = false;
  }
  zo() {
    if (!this.fo) return;
    const t = this.so();
    if (t) try {
      if (this.ro) {
        const e = new MouseEvent("mousemove", { clientX: this.ro.x, clientY: this.ro.y, bubbles: false, cancelable: false });
        this.xo(e);
      } else {
        const e = Math.floor((t.cols - 1) / 2), i = Math.floor(t.rows / 2);
        if (this.eo.x !== -1 / 0 && this.eo.y !== -1 / 0) {
          const s = -e, r = t.cols - e - 1, n = -i, h = t.rows - i - 1;
          (this.eo.x < s || this.eo.x > r || this.eo.y < n || this.eo.y > h) && (this.eo.x = -1 / 0, this.eo.y = -1 / 0);
        }
      }
    } catch {
      this.eo.x = -1 / 0, this.eo.y = -1 / 0;
    }
  }
  So(t) {
    this.do = t;
  }
  Ro(t) {
    this.vo = t;
  }
  Eo(t) {
    this.po = t;
  }
  ko(t) {
    this.mo = t;
  }
  Do(t) {
    this._o = t;
  }
  Lo() {
    return { x: this.eo.x, y: this.eo.y };
  }
  Co(t) {
    if (this.mo && !this.Ao()) {
      const e = { position: { ...this.eo }, previousPosition: { ...this.io }, originalEvent: t };
      this.mo(e);
    }
  }
  Mo(t) {
    if (this.vo && !this.Ao()) {
      const e = { position: { ...this.eo }, previousPosition: { ...this.io }, button: t.button, originalEvent: t };
      this.vo(e);
    }
  }
  Fo(t) {
    if (this.po && !this.Ao()) {
      const e = { position: { ...this.eo }, previousPosition: { ...this.io }, button: t.button, originalEvent: t };
      this.po(e);
    }
  }
  $o(t) {
    if (this.do && !this.Ao()) {
      const e = { position: { ...this.eo }, previousPosition: { ...this.io }, button: t.button, originalEvent: t };
      this.do(e);
    }
  }
  Po(t) {
    if (this._o && !this.Ao()) {
      const e = { position: { ...this.eo }, previousPosition: { ...this.io }, delta: { x: t.deltaX, y: t.deltaY }, originalEvent: t };
      this._o(e);
    }
  }
  xo(t) {
    const e = this.Er.canvas, i = this.so();
    if (this.io = { ...this.eo }, this.ro = { x: t.clientX, y: t.clientY }, !i) return this.eo.x = -1 / 0, void (this.eo.y = -1 / 0);
    const s = e.getBoundingClientRect(), r = t.clientX - s.left, n = t.clientY - s.top, h = e.width / s.width, c = n * (e.height / s.height), l = r * h - i.offsetX, u = c - i.offsetY, f = Math.floor(l / i.cellWidth), d = Math.floor(u / i.cellHeight);
    if (f >= 0 && f < i.cols && d >= 0 && d < i.rows) {
      const g = Math.floor((i.cols - 1) / 2);
      this.eo.x = f - g, this.eo.y = d - Math.floor(i.rows / 2);
    } else this.eo.x = -1 / 0, this.eo.y = -1 / 0;
  }
};
var Ye = Object.freeze(Object.defineProperty({ __proto__: null, MouseManager: Bt }, Symbol.toStringTag, { value: "Module" }));
var _t = class {
  constructor() {
    a(this, "Ho", /* @__PURE__ */ new Map());
    a(this, "Oo", null);
    a(this, "Bo", null);
    a(this, "Io");
    a(this, "Go");
    a(this, "fo", false);
    a(this, "jo");
    a(this, "No");
    a(this, "Qo", { ArrowUp: "UP_ARROW", ArrowDown: "DOWN_ARROW", ArrowLeft: "LEFT_ARROW", ArrowRight: "RIGHT_ARROW", F1: "F1", F2: "F2", F3: "F3", F4: "F4", F5: "F5", F6: "F6", F7: "F7", F8: "F8", F9: "F9", F10: "F10", F11: "F11", F12: "F12", Enter: "ENTER", Return: "RETURN", Tab: "TAB", Escape: "ESCAPE", Backspace: "BACKSPACE", Delete: "DELETE", Insert: "INSERT", Home: "HOME", End: "END", PageUp: "PAGE_UP", PageDown: "PAGE_DOWN", Shift: "SHIFT", Control: "CONTROL", Alt: "ALT", Meta: "META", " ": "SPACE" });
  }
  wo() {
    this.fo || (this.Io = (t) => {
      this.Yo(t);
    }, this.Go = (t) => {
      this.Xo(t);
    }, window.addEventListener("keydown", this.Io, { passive: false }), window.addEventListener("keyup", this.Go, { passive: false }), this.fo = true);
  }
  To() {
    this.fo && (window.removeEventListener("keydown", this.Io), window.removeEventListener("keyup", this.Go), this.fo = false, this.Ho.clear(), this.Oo = null, this.Bo = null);
  }
  Ro(t) {
    this.jo = t;
  }
  Eo(t) {
    this.No = t;
  }
  Wo(t) {
    const e = this.Ko(t), i = this.Ho.get(t) || this.Ho.get(e);
    return (i == null ? void 0 : i.isPressed) || false;
  }
  Zo() {
    return this.Oo;
  }
  qo() {
    return this.Bo;
  }
  Vo() {
    const t = [];
    for (const [e, i] of this.Ho) i.isPressed && t.push(e);
    return t;
  }
  Jo() {
    return { ctrl: this.Wo("Control"), shift: this.Wo("Shift"), alt: this.Wo("Alt"), meta: this.Wo("Meta") };
  }
  th() {
    this.Ho.clear(), this.Oo = null, this.Bo = null;
  }
  Yo(t) {
    const e = t.key, i = Date.now();
    this.Ho.has(e) || this.Ho.set(e, { isPressed: false, lastPressTime: 0, lastReleaseTime: 0 });
    const s = this.Ho.get(e);
    if (!s.isPressed && (s.isPressed = true, s.lastPressTime = i, this.Oo = e, this.jo)) {
      const r = { key: e, keyCode: t.keyCode, ctrlKey: t.ctrlKey, shiftKey: t.shiftKey, altKey: t.altKey, metaKey: t.metaKey, isPressed: true, originalEvent: t };
      this.jo(r);
    }
  }
  Xo(t) {
    const e = t.key, i = Date.now();
    this.Ho.has(e) || this.Ho.set(e, { isPressed: false, lastPressTime: 0, lastReleaseTime: 0 });
    const s = this.Ho.get(e);
    if (s.isPressed = false, s.lastReleaseTime = i, this.Bo = e, this.No) {
      const r = { key: e, keyCode: t.keyCode, ctrlKey: t.ctrlKey, shiftKey: t.shiftKey, altKey: t.altKey, metaKey: t.metaKey, isPressed: false, originalEvent: t };
      this.No(r);
    }
  }
  Ko(t) {
    return this.Qo[t] || t.toLowerCase();
  }
};
var Ge = Object.freeze(Object.defineProperty({ __proto__: null, KeyboardManager: _t }, Symbol.toStringTag, { value: "Module" }));
var Ot = class {
  constructor(t, e, i) {
    a(this, "Er");
    a(this, "sh");
    a(this, "so");
    a(this, "eh", /* @__PURE__ */ new Map());
    a(this, "ih", /* @__PURE__ */ new Map());
    a(this, "rh", /* @__PURE__ */ new Map());
    a(this, "nh", null);
    a(this, "oh");
    a(this, "hh");
    a(this, "ah");
    a(this, "uh");
    a(this, "fh");
    a(this, "dh");
    a(this, "fo", false);
    a(this, "ph");
    a(this, "mh");
    a(this, "gh");
    a(this, "_h");
    a(this, "yh");
    a(this, "Ah");
    a(this, "bh");
    a(this, "wh");
    a(this, "xh");
    a(this, "Ch");
    a(this, "Mh", 320);
    a(this, "Fh", 350);
    a(this, "$h", 10);
    a(this, "Ph", 550);
    a(this, "Th", 14);
    a(this, "zh", 48);
    a(this, "Sh", 650);
    a(this, "Rh", 0.02);
    a(this, "Eh", 2);
    a(this, "kh", 600);
    a(this, "Dh", 0);
    a(this, "Lh", null);
    this.Er = t, this.so = e, this.sh = i;
    const s = this.Er.canvas;
    this.oh = s.style.touchAction, this.hh = s.style.userSelect, s.style.touchAction || (s.style.touchAction = "none"), s.style.userSelect || (s.style.userSelect = "none");
  }
  wo() {
    if (this.fo) return;
    const t = this.Er.canvas;
    this.ah = (e) => {
      this.Hh(e);
    }, this.uh = (e) => {
      this.Oh(e);
    }, this.fh = (e) => {
      this.Bh(e);
    }, this.dh = (e) => {
      this.Ih(e);
    }, t.addEventListener("touchstart", this.ah, { passive: false }), t.addEventListener("touchmove", this.uh, { passive: false }), t.addEventListener("touchend", this.fh, { passive: false }), t.addEventListener("touchcancel", this.dh, { passive: false }), this.fo = true;
  }
  To() {
    if (!this.fo) return;
    const t = this.Er.canvas;
    t.removeEventListener("touchstart", this.ah), t.removeEventListener("touchmove", this.uh), t.removeEventListener("touchend", this.fh), t.removeEventListener("touchcancel", this.dh), this.fo = false, this.nh = null, this.eh.clear(), this.ih.clear(), this.rh.forEach((e) => {
      e.longPressTimer !== null && window.clearTimeout(e.longPressTimer);
    }), this.rh.clear(), this.Lh = null, this.Dh = 0, t.style.touchAction = this.oh, t.style.userSelect = this.hh;
  }
  zo() {
    if (!this.so() || this.eh.size === 0) return;
    const t = /* @__PURE__ */ new Map();
    for (const e of this.eh.values()) {
      const i = this.Gh(e.clientX, e.clientY, e.id, e);
      t.set(e.id, i);
    }
    this.eh = t;
  }
  jh() {
    return Array.from(this.eh.values()).map((t) => ({ ...t }));
  }
  Nh(t) {
    this.ph = t;
  }
  ko(t) {
    this.mh = t;
  }
  Qh(t) {
    this.gh = t;
  }
  Yh(t) {
    this._h = t;
  }
  Xh(t) {
    this.yh = t;
  }
  Wh(t) {
    this.Ah = t;
  }
  Kh(t) {
    this.bh = t;
  }
  Zh(t) {
    this.wh = t;
  }
  qh(t) {
    this.xh = t;
  }
  Vh(t) {
    this.Ch = t;
  }
  Hh(t) {
    var s;
    if (!this.so()) return;
    t.preventDefault(), (s = this.sh) == null || s.yo(this.kh);
    const e = performance.now(), i = this.Jh(t.changedTouches);
    for (const r of i) {
      const n = this.eh.get(r.id);
      n && this.ih.set(r.id, this.ta(n)), this.eh.set(r.id, r);
      const h = { id: r.id, startPosition: r, lastPosition: r, startTime: e, lastTime: e, longPressTimer: null, longPressFired: false };
      this.bh && (h.longPressTimer = window.setTimeout(() => {
        const c = this.eh.get(r.id);
        c && (h.longPressFired = true, this.bh({ touch: this.ta(c), duration: performance.now() - h.startTime, originalEvent: t }));
      }, this.Ph)), this.rh.set(r.id, h), this.ph && this.ph(this.sa(r, t, void 0, e));
    }
    this.eh.size === 2 && this.ea();
  }
  Oh(t) {
    var s;
    if (!this.so()) return;
    t.preventDefault(), (s = this.sh) == null || s.yo(this.kh);
    const e = performance.now(), i = this.Jh(t.changedTouches);
    for (const r of i) {
      const n = this.eh.get(r.id), h = n ? this.ta(n) : void 0;
      h && this.ih.set(r.id, h), this.eh.set(r.id, r);
      const c = this.rh.get(r.id);
      c && (c.lastPosition = r, c.lastTime = e, h) && H(h.clientX, h.clientY, r.clientX, r.clientY) > this.Th && c.longPressTimer !== null && (window.clearTimeout(c.longPressTimer), c.longPressTimer = null), this.mh && this.mh(this.sa(r, t, h, e));
    }
    this.eh.size === 2 ? this.ia(t) : this.nh = null;
  }
  Bh(t) {
    if (!this.so()) return;
    t.preventDefault();
    const e = performance.now(), i = this.Jh(t.changedTouches);
    for (const s of i) {
      const r = this.eh.get(s.id), n = r ? this.ta(r) : void 0, h = this.rh.get(s.id);
      h && h.longPressTimer !== null && (window.clearTimeout(h.longPressTimer), h.longPressTimer = null), this.gh && this.gh(this.sa(s, t, n, e)), h && this.ra(h, t), this.rh.delete(s.id), this.ih.delete(s.id), this.eh.delete(s.id);
    }
    this.eh.size < 2 && (this.nh = null);
  }
  Ih(t) {
    if (!this.so()) return;
    t.preventDefault();
    const e = performance.now(), i = this.Jh(t.changedTouches);
    for (const s of i) {
      const r = this.eh.get(s.id), n = r ? this.ta(r) : void 0, h = this.rh.get(s.id);
      h && h.longPressTimer !== null && (window.clearTimeout(h.longPressTimer), h.longPressTimer = null), this._h && this._h(this.sa(s, t, n, e)), this.rh.delete(s.id), this.ih.delete(s.id), this.eh.delete(s.id);
    }
    this.eh.size < 2 && (this.nh = null);
  }
  Jh(t) {
    const e = [];
    for (let i = 0; i < t.length; i += 1) {
      const s = t.item(i);
      s && e.push(this.na(s));
    }
    return e;
  }
  na(t) {
    return this.Gh(t.clientX, t.clientY, t.identifier, { id: t.identifier, x: -1, y: -1, clientX: t.clientX, clientY: t.clientY, pressure: t.force, radiusX: t.radiusX, radiusY: t.radiusY, rotationAngle: t.rotationAngle });
  }
  Gh(t, e, i, s) {
    const r = this.Er.canvas, n = this.so(), h = r.getBoundingClientRect(), c = t - h.left, l = e - h.top, u = c * (r.width / h.width), f = l * (r.height / h.height);
    if (!n) return { id: i, x: -1 / 0, y: -1 / 0, clientX: t, clientY: e, pressure: s.pressure, radiusX: s.radiusX, radiusY: s.radiusY, rotationAngle: s.rotationAngle };
    const d = u - n.offsetX, g = f - n.offsetY, v = Math.floor(d / n.cellWidth), m = Math.floor(g / n.cellHeight);
    return v >= 0 && v < n.cols && m >= 0 && m < n.rows ? { id: i, x: v - Math.floor((n.cols - 1) / 2), y: m - Math.floor(n.rows / 2), clientX: t, clientY: e, pressure: s.pressure, radiusX: s.radiusX, radiusY: s.radiusY, rotationAngle: s.rotationAngle } : { id: i, x: -1 / 0, y: -1 / 0, clientX: t, clientY: e, pressure: s.pressure, radiusX: s.radiusX, radiusY: s.radiusY, rotationAngle: s.rotationAngle };
  }
  sa(t, e, i, s) {
    const r = this.rh.get(t.id), n = Array.from(this.ih.values()).map((l) => this.ta(l)), h = Array.from(this.eh.values()).map((l) => this.ta(l)), c = this.Jh(e.changedTouches);
    return { touch: this.ta(t), previousTouch: i ? this.ta(i) : void 0, touches: h, previousTouches: n, changedTouches: c, deltaTime: r ? s - r.lastTime : 0, originalEvent: e };
  }
  ea() {
    if (this.eh.size !== 2) return void (this.nh = null);
    const t = Array.from(this.eh.values()), [e, i] = t, s = H(e.x, e.y, i.x, i.y), r = xt(e.clientX, e.clientY, i.clientX, i.clientY);
    this.nh = { ids: [e.id, i.id], initialDistance: Math.max(s, 1e-4), initialAngle: r, lastScale: 1, lastRotation: 0 };
  }
  ia(t) {
    if (this.nh || this.ea(), !this.nh) return;
    const [e, i] = this.nh.ids, s = this.eh.get(e), r = this.eh.get(i);
    if (!s || !r) return;
    const n = H(s.x, s.y, r.x, r.y) / this.nh.initialDistance, h = n - this.nh.lastScale;
    this.xh && Math.abs(h) > this.Rh && (this.xh({ touches: [this.ta(s), this.ta(r)], scale: n, deltaScale: h, center: this.oa(s, r), originalEvent: t }), this.nh.lastScale = n);
    let c = xt(s.clientX, s.clientY, r.clientX, r.clientY) - this.nh.initialAngle;
    c = (c + 180) % 360 - 180;
    const l = c - this.nh.lastRotation;
    this.Ch && Math.abs(l) > this.Eh && (this.Ch({ touches: [this.ta(s), this.ta(r)], rotation: c, deltaRotation: l, center: this.oa(s, r), originalEvent: t }), this.nh.lastRotation = c);
  }
  oa(t, e) {
    const i = (t.clientX + e.clientX) / 2, s = (t.clientY + e.clientY) / 2, r = this.Gh(i, s, -1, { id: -1, x: -1, y: -1, clientX: i, clientY: s });
    return { x: r.x, y: r.y };
  }
  ra(t, e) {
    const i = performance.now(), s = i - t.startTime, r = H(t.startPosition.clientX, t.startPosition.clientY, t.lastPosition.clientX, t.lastPosition.clientY);
    if (!t.longPressFired && s <= this.Mh && r <= this.$h)
      this.ha(t.lastPosition, i) && this.Ah ? this.Ah({ touch: this.ta(t.lastPosition), taps: 2, originalEvent: e }) : this.yh && this.yh({ touch: this.ta(t.lastPosition), taps: 1, originalEvent: e });
    else if (!t.longPressFired && s <= this.Sh && r >= this.zh) {
      const n = { x: t.lastPosition.clientX - t.startPosition.clientX, y: t.lastPosition.clientY - t.startPosition.clientY }, h = Math.max(Math.hypot(n.x, n.y), 1e-4), c = { x: n.x / h, y: n.y / h }, l = { x: n.x / s, y: n.y / s };
      this.wh && this.wh({ touch: this.ta(t.lastPosition), direction: c, distance: h, velocity: l, originalEvent: e });
    }
    this.Dh = i, this.Lh = this.ta(t.lastPosition);
  }
  ha(t, e) {
    return !this.Lh || e - this.Dh > this.Fh ? false : H(t.clientX, t.clientY, this.Lh.clientX, this.Lh.clientY) <= this.$h;
  }
  ta(t) {
    return { ...t };
  }
};
var He = Object.freeze(Object.defineProperty({ __proto__: null, TouchManager: Ot }, Symbol.toStringTag, { value: "Module" }));
var ht = class _ht extends zt {
  constructor(e, i, s, r, n, h, c, l, u) {
    const f = h / c;
    let d, g;
    f > 1 ? (d = l, g = Math.round(l / f)) : (g = u, d = Math.round(u * f));
    super(e, i, s, r, h, c, d, g);
    a(this, "aa");
    this.aa = n;
  }
  Fs() {
    super.Fs(), this.aa.pause(), this.aa.src = "", this.aa.load();
  }
  ca() {
    if (this.aa.readyState >= this.aa.HAVE_CURRENT_DATA) {
      const e = this.A;
      e.bindTexture(e.TEXTURE_2D, this.cn), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this.aa), e.bindTexture(e.TEXTURE_2D, null);
    }
  }
  Fn() {
    return this.cn;
  }
  lt() {
    return this.Z = null, super.lt();
  }
  xn() {
    this.ca();
  }
  static async Pn(e, i, s, r, n) {
    const h = e.context;
    let c;
    c = document.createElement("video"), c.crossOrigin = "anonymous", c.loop = true, c.muted = true, c.playsInline = true, await new Promise((d, g) => {
      c.addEventListener("loadedmetadata", () => d(), { once: true }), c.addEventListener("error", (v) => {
        var A;
        const m = v.target;
        g(Error("Failed to load video: " + (((A = m.error) == null ? void 0 : A.message) || "Unknown error")));
      }, { once: true }), c.src = s;
    });
    const l = h.createTexture();
    h.bindTexture(h.TEXTURE_2D, l), h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, 1), pt(h, h.LINEAR, h.LINEAR, h.CLAMP_TO_EDGE, h.CLAMP_TO_EDGE), h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, c), h.bindTexture(h.TEXTURE_2D, null);
    const u = c.videoWidth, f = c.videoHeight;
    return new _ht(h, e, l, i, c, u, f, r, n);
  }
  async play() {
    await this.aa.play();
  }
  pause() {
    this.aa.pause();
  }
  stop() {
    this.aa.pause(), this.aa.currentTime = 0;
  }
  speed(e) {
    return this.aa.playbackRate = e, this;
  }
  loop(e = true) {
    return this.aa.loop = e, this;
  }
  time(e) {
    return this.aa.currentTime = e, this;
  }
  volume(e) {
    return this.aa.volume = Math.max(0, Math.min(1, e)), this;
  }
  get videoElement() {
    return this.aa;
  }
  get currentTime() {
    return this.aa.currentTime;
  }
  get duration() {
    return this.aa.duration;
  }
  get isPlaying() {
    return !this.aa.paused && !this.aa.ended;
  }
};
var je = (o) => class extends o {
  la(t, e, i, s) {
    if (C.rn(t)) return t;
    if (typeof t == "number" || typeof t == "string") return this.color(t, e, i, s);
    throw Error("Unsupported color input passed to color-capable method.");
  }
  rotate(t = 0, e = 0, i = 0) {
    this.K.state.Zt(t), this.K.state.qt(e), this.K.state.Vt(i);
  }
  rotateX(t) {
    this.K.state.Zt(t);
  }
  rotateY(t) {
    this.K.state.qt(t);
  }
  rotateZ(t) {
    this.K.state.Vt(t);
  }
  translate(t = 0, e = 0, i = 0) {
    this.K.state.Jt(t, e, i);
  }
  translateX(t) {
    this.K.state.Jt(t, 0, 0);
  }
  translateY(t) {
    this.K.state.Jt(0, t, 0);
  }
  translateZ(t) {
    this.K.state.Jt(0, 0, t);
  }
  push() {
    this.K.state.nt();
  }
  pop() {
    this.K.state.ot();
  }
  color(t, e, i, s) {
    return C.en(t, e, i, s);
  }
  rect(t = 1, e = 1) {
    this.K.bi(t, e);
  }
  point() {
    this.K.bi(1, 1);
  }
  line(t, e, i, s) {
    this.K.wi(t, e, i, s);
  }
  lineWeight(t) {
    this.K.state.Wt(t);
  }
  background(t, e, i, s = 255) {
    const r = this.la(t, e, i, s);
    this.K.Pi(r.r, r.g, r.b, r.a);
  }
  char(t) {
    const e = Array.from(t);
    if (e.length === 0) throw Error("char() requires at least one character.");
    this.K.state.rs(this.ua.font.Fr(e[0]));
  }
  charColor(t, e, i, s) {
    const r = this.la(t, e, i, s);
    this.K.state.ns(r.r, r.g, r.b, r.a);
  }
  cellColor(t, e, i, s) {
    const r = this.la(t, e, i, s);
    this.K.state.hs(r.r, r.g, r.b, r.a);
  }
  flipX(t) {
    this.K.state.cs(t);
  }
  flipY(t) {
    this.K.state.ls(t);
  }
  charRotation(t) {
    this.K.state.fs(t);
  }
  invert(t) {
    this.K.state.us(t);
  }
  clear() {
    this.K.ye(0, 0, 0, 0);
  }
  ellipse(t, e) {
    this.K.xi(t / 2, e / 2);
  }
  triangle(t, e, i, s, r, n) {
    this.K.Ci(t, e, i, s, r, n);
  }
  bezierCurve(t, e, i, s, r, n, h, c) {
    this.K.Mi(t, e, i, s, r, n, h, c);
  }
  arc(t, e, i, s) {
    this.K.Fi(t / 2, e / 2, i, s);
  }
  shader(t) {
    this.K.pi(t);
  }
  setUniform(t, e) {
    this.K.O(t, e);
  }
  setUniforms(t) {
    this.K.mi(t);
  }
  async createFilterShader(t) {
    if (typeof t == "string" && (t.startsWith("./") || t.startsWith("../") || t.endsWith(".frag") || t.endsWith(".glsl"))) {
      const e = await fetch(t);
      if (!e.ok) throw Error(`Failed to load shader from ${t}: ${e.statusText}`);
      const i = await e.text();
      return this.K.gi(i);
    }
    return this.K.gi(t);
  }
  async createShader(t, e) {
    let i, s;
    if (typeof t == "string" && (t.startsWith("./") || t.startsWith("../") || t.endsWith(".vert") || t.endsWith(".glsl"))) {
      const r = await fetch(t);
      if (!r.ok) throw Error(`Failed to load vertex shader from ${t}: ${r.statusText}`);
      i = await r.text();
    } else i = t;
    if (typeof e == "string" && (e.startsWith("./") || e.startsWith("../") || e.endsWith(".frag") || e.endsWith(".glsl"))) {
      const r = await fetch(e);
      if (!r.ok) throw Error(`Failed to load fragment shader from ${e}: ${r.statusText}`);
      s = await r.text();
    } else s = e;
    return this.K.di(i, s);
  }
  createFramebuffer(t) {
    return this.K.$i(t.width ?? this.grid.cols, t.height ?? this.grid.rows, t.attachments ?? 3);
  }
  image(t, e, i) {
    var s;
    this.K._i(t, e, i, ((s = this.ua) == null ? void 0 : s.font) ?? this.fa.base.font), t instanceof Y && this.K.ht();
  }
  async loadImage(t) {
    const e = t, i = await new Promise((s, r) => {
      const n = new Image();
      n.crossOrigin = "anonymous", n.onload = () => s(n), n.onerror = (h) => r(h), n.src = e;
    });
    return Z.Pn(this.K, this.pn, i, this.grid.cols, this.grid.rows);
  }
  async loadVideo(t) {
    return await ht.Pn(this.K, this.pn, t, this.grid.cols, this.grid.rows);
  }
};
var ke = (o) => class extends o {
  get frameCount() {
    return this.da.Kn;
  }
  set frameCount(t) {
    this.da.Kn = t;
  }
  frameRate(t) {
    return t === void 0 ? this.da.Wn : this.da.Qn(t, () => this.va());
  }
  noLoop() {
    this.da.jn();
  }
  loop() {
    this.da.Nn(() => this.va());
  }
  redraw(t = 1) {
    if (At.m(typeof t == "number" && t > 0 && Number.isInteger(t), "Redraw count must be a positive integer.", { method: "redraw", providedValue: t })) for (let e = 0; e < t; e++) this.va();
  }
  isLooping() {
    return this.da.Xn;
  }
  millis() {
    return this.da.qn();
  }
  secs() {
    return this.da.Vn();
  }
  deltaTime() {
    return this.da.Jn;
  }
};
var We = (o) => class extends o {
  constructor(...t) {
    super(...t);
  }
  mouseClicked(t) {
    this.sh.So(t);
  }
  mousePressed(t) {
    this.sh.Ro(t);
  }
  mouseReleased(t) {
    this.sh.Eo(t);
  }
  mouseMoved(t) {
    this.sh.ko(t);
  }
  mouseScrolled(t) {
    this.sh.Do(t);
  }
  get mouse() {
    return this.sh.Lo();
  }
  cursor(t) {
    this.sh.bo(t);
  }
};
var Qe = (o) => class extends o {
  constructor(...t) {
    super(...t);
  }
  touchStarted(t) {
    this.pa.Nh(t);
  }
  touchMoved(t) {
    this.pa.ko(t);
  }
  touchEnded(t) {
    this.pa.Qh(t);
  }
  touchCancelled(t) {
    this.pa.Yh(t);
  }
  tap(t) {
    this.pa.Xh(t);
  }
  doubleTap(t) {
    this.pa.Wh(t);
  }
  longPress(t) {
    this.pa.Kh(t);
  }
  swipe(t) {
    this.pa.Zh(t);
  }
  pinch(t) {
    this.pa.qh(t);
  }
  rotateGesture(t) {
    this.pa.Vh(t);
  }
  get touches() {
    return this.pa.jh();
  }
};
var Ve = (o) => class extends o {
  constructor(...t) {
    super(...t);
  }
  keyPressed(t) {
    this.ma.Ro(t);
  }
  keyReleased(t) {
    this.ma.Eo(t);
  }
  isKeyPressed(t) {
    return this.ma.Wo(t);
  }
  get lastKeyPressed() {
    return this.ma.Zo();
  }
  get lastKeyReleased() {
    return this.ma.qo();
  }
  get pressedKeys() {
    return this.ma.Vo();
  }
  get modifierState() {
    return this.ma.Jo();
  }
};
var It = class {
  constructor(t) {
    a(this, "ga");
    a(this, "_a", /* @__PURE__ */ new Map());
    a(this, "ya", []);
    a(this, "ba", /* @__PURE__ */ new Map());
    a(this, "wa", /* @__PURE__ */ new Map());
    a(this, "xa", /* @__PURE__ */ new Map());
    a(this, "Ca", /* @__PURE__ */ new Map());
    a(this, "Ma", /* @__PURE__ */ new Map());
    a(this, "Ua", /* @__PURE__ */ new Map());
    a(this, "Fa", /* @__PURE__ */ new Map());
    a(this, "$a", /* @__PURE__ */ new Map());
    this.ga = t;
  }
  Pa(t) {
    for (const e of t) {
      if (this._a.has(e.name)) return void console.warn(`[textmode.js] Plugin "${e.name}" is already installed.`);
      const i = this.Ta(e.name);
      try {
        const s = e.install(this.ga, i);
        s instanceof Promise && s.catch((r) => {
          console.error(`[textmode.js] Async plugin "${e.name}" installation error:`, r), this.za(e.name);
        });
      } catch (s) {
        throw this.za(e.name), s;
      }
      this._a.set(e.name, e), this.ya.push(e.name);
    }
  }
  async Sa(t) {
    for (const e of t) {
      if (this._a.has(e.name)) return void console.warn(`[textmode.js] Plugin "${e.name}" is already installed.`);
      const i = this.Ta(e.name);
      try {
        await e.install(this.ga, i);
      } catch (s) {
        throw this.za(e.name), s;
      }
      this._a.set(e.name, e), this.ya.push(e.name);
    }
  }
  async Ra(t) {
    const e = this._a.get(t);
    if (!e) return;
    const i = this.Ta(t);
    e.uninstall && await e.uninstall(this.ga, i), this._a.delete(t), this.ya.splice(this.ya.indexOf(t), 1), this.za(t);
  }
  Ea() {
    this.ka(this.ba);
  }
  Da() {
    this.ka(this.wa);
  }
  La(t) {
    this.Ha(this.xa, t);
  }
  Oa(t) {
    this.Ba(this.Ca, t);
  }
  Ia(t) {
    this.Ba(this.Ma, t);
  }
  async Ga() {
    await this.ja(this.Ua);
  }
  async Na() {
    await this.ja(this.Fa);
  }
  async Qa() {
    const t = [...this._a.keys()];
    for (const e of t) await this.Ra(e);
  }
  Ta(t) {
    const e = this.ga, i = this;
    return { get renderer() {
      return e.K;
    }, get canvas() {
      return e.Er;
    }, get layerManager() {
      return e.layers;
    }, get font() {
      return e.layers.base.font;
    }, get grid() {
      return e.layers.base.grid;
    }, get drawFramebuffer() {
      return e.layers.base.drawFramebuffer;
    }, get asciiFramebuffer() {
      return e.layers.base.asciiFramebuffer;
    }, registerPreDrawHook: (s) => i.Ya(i.ba, t, s), registerPostDrawHook: (s) => i.Ya(i.wa, t, s), registerLayerDisposedHook: (s) => i.Ya(i.xa, t, s), registerLayerPreRenderHook: (s) => i.Ya(i.Ca, t, s), registerLayerPostRenderHook: (s) => i.Ya(i.Ma, t, s), registerPreSetupHook: (s) => i.Ya(i.Ua, t, s), registerPostSetupHook: (s) => i.Ya(i.Fa, t, s), extendLayer: (s, r) => {
      i.Xa(t, s, r);
    }, removeLayerExtension: (s) => {
      i.Wa(t, s);
    } };
  }
  Ya(t, e, i) {
    const s = t.get(e) ?? /* @__PURE__ */ new Set();
    return s.add(i), t.set(e, s), () => {
      const r = t.get(e);
      r && (r.delete(i), r.size === 0 && t.delete(e));
    };
  }
  za(t) {
    this.ba.delete(t), this.wa.delete(t), this.xa.delete(t), this.Ca.delete(t), this.Ma.delete(t), this.Ua.delete(t), this.Fa.delete(t);
    const e = this.$a.get(t);
    if (e) {
      for (const i of e.keys()) this.Ka(i);
      this.$a.delete(t);
    }
  }
  ka(t) {
    for (const e of this.ya) {
      const i = t.get(e);
      i && i.forEach((s) => s());
    }
  }
  Ha(t, e) {
    for (const i of this.ya) {
      const s = t.get(i);
      s && s.forEach((r) => r(e));
    }
  }
  Ba(t, e) {
    for (const i of this.ya) {
      const s = t.get(i);
      s && s.forEach((r) => r(e));
    }
  }
  async ja(t) {
    for (const e of this.ya) {
      const i = t.get(e);
      if (i) for (const s of i) await s();
    }
  }
  Xa(t, e, i) {
    let s = this.$a.get(t);
    s || (s = /* @__PURE__ */ new Map(), this.$a.set(t, s));
    for (const [r, n] of this.$a) r !== t && n.has(e) && console.warn(`[textmode.js] Plugin "${t}" is overwriting layer method "${e}" previously added by plugin "${r}".`);
    s.set(e, i), this.Za(e, i);
  }
  Wa(t, e) {
    const i = this.$a.get(t);
    if (!i) return;
    i.delete(e);
    let s = false;
    for (const [r, n] of this.$a) if (r !== t && n.has(e)) {
      s = true;
      const h = n.get(e);
      this.Za(e, h);
      break;
    }
    s || this.Ka(e);
  }
  Za(t, e) {
    const i = Object.getPrototypeOf(this.ga.layers.base);
    Object.defineProperty(i, t, { value: e, writable: true, configurable: true, enumerable: false });
  }
  Ka(t) {
    const e = Object.getPrototypeOf(this.ga.layers.base), i = Object.getOwnPropertyDescriptor(e, t);
    i && i.configurable && delete e[t];
  }
};
var si = Object.freeze(Object.defineProperty({ __proto__: null, TextmodePluginManager: It }, Symbol.toStringTag, { value: "Module" }));
var Xt = class {
  constructor() {
    a(this, "qa", /* @__PURE__ */ new Map());
    a(this, "Va", []);
    a(this, "Ja", 0);
    a(this, "tc", 0);
    a(this, "sc");
  }
  get ec() {
    return this.Ja;
  }
  get rc() {
    if (this.Ja === 0) return 0;
    let t = 0;
    for (const e of this.Va) {
      const i = this.qa.get(e);
      i && (t += Math.min(1, Math.max(0, i.progress)) * i.weight);
    }
    return Math.min(1, t / this.Ja);
  }
  nc(t) {
    this.sc = t;
  }
  oc(t, e = 1) {
    const i = `phase-${this.Va.length + 1}-${Date.now()}`, s = { id: i, label: t, weight: Math.max(1e-3, e), progress: 0, status: "running" };
    return this.qa.set(i, s), this.Va.push(i), this.Ja += s.weight, i;
  }
  hc(t, e) {
    const i = this.qa.get(t);
    if (!i) return;
    i.progress = Math.max(0, Math.min(1, e)), i.status = i.progress >= 1 ? "complete" : "running";
    const s = this.rc;
    Math.abs(s - this.tc) > 1e-3 && (this.tc = s, this.sc && this.sc(s));
  }
  ac(t) {
    const e = this.qa.get(t);
    e && (e.progress = 1, e.status = "complete", this.hc(t, 1));
  }
  cc(t) {
    const e = this.qa.get(t);
    e && (e.status = "failed");
  }
  lc() {
    return this.Va.map((t) => {
      const e = this.qa.get(t);
      return e ? { id: e.id, label: e.label, weight: e.weight, progress: e.progress, status: e.status } : { id: t, label: t, weight: 1, progress: 0, status: "pending" };
    });
  }
};
var Kt = class {
  constructor(t = "active") {
    a(this, "uc");
    a(this, "fc", "");
    a(this, "dc", "");
    this.uc = t;
  }
  get vc() {
    return this.uc;
  }
  get mc() {
    return this.uc !== "disabled";
  }
  get gc() {
    return this.uc === "active" || this.uc === "transitioning" || this.uc === "error";
  }
  get _c() {
    return this.fc;
  }
  get yc() {
    return this.dc;
  }
  bc() {
    this.uc !== "done" && this.uc !== "transitioning" || (this.uc = "active");
  }
  wc() {
    this.uc !== "disabled" && (this.uc = "done");
  }
  xc() {
    this.uc !== "disabled" && (this.uc = "transitioning");
  }
  Cc() {
    this.uc === "transitioning" && (this.uc = "done");
  }
  Mc(t) {
    this.uc !== "disabled" && (this.uc = "error", t instanceof Error ? (this.fc = t.message, this.dc = t.stack || "") : (this.fc = t, this.dc = ""));
  }
  Uc() {
    this.uc = "disabled";
  }
};
var Yt = class {
  constructor(t, e) {
    a(this, "Fc", 0);
    a(this, "$c", 1);
    a(this, "Pc");
    a(this, "Tc");
    this.Pc = t, this.Tc = e;
  }
  get zc() {
    return this.$c;
  }
  get Sc() {
    return this.$c < 1;
  }
  In() {
    this.Pc !== "none" && this.Tc > 0 && (this.Fc = performance.now());
  }
  et() {
    if (this.Pc === "none" || this.Tc === 0) return this.$c = 1, false;
    const t = performance.now() - this.Fc, e = Math.min(1, t / this.Tc);
    return e >= 1 ? (this.$c = 0, true) : (this.$c = 1 - e, false);
  }
  Js() {
    this.$c = 1, this.Fc = 0;
  }
};
function mt(o, t) {
  const e = o.tone ?? "auto";
  let i = "dark";
  return e === "light" || e === "dark" ? i = e : t && (i = (function(s) {
    if (!s) return 0;
    const [r, n, h] = s.map((l) => l / 255), c = (l) => l <= 0.04045 ? l / 12.92 : Math.pow((l + 0.055) / 1.055, 2.4);
    return 0.2126 * c(r) + 0.7152 * c(n) + 0.0722 * c(h);
  })(t) > 0.5 ? "light" : "dark"), { mode: i, background: t, textColor: i === "light" ? "#1A1A1A" : "#F8F8F8", subtleColor: i === "light" ? "#4A4A4A" : "#C0C0C0" };
}
function Gt(o) {
  return o.mode === "light" ? ["#E91E63", "#9C27B0", "#FF6F00"] : ["#8EF9F3", "#F15BB5", "#FF9B71"];
}
function Ht(o, t) {
  return o.length ? o.map((e) => t.color(e)) : [t.color("#FFFFFF")];
}
var jt = class {
  constructor(t, e, i, s) {
    this.Rc = t, this.id = e, this.label = i, this.Ec = s;
  }
  report(t) {
    this.Rc.hc(this.id, t);
  }
  complete() {
    this.Rc.ac(this.id);
  }
  fail(t) {
    this.Rc.cc(this.id), this.Ec && this.Ec(t ?? Error(`Loading phase "${this.label}" failed`));
  }
  async track(t) {
    try {
      const e = typeof t == "function" ? await t() : await t;
      return this.complete(), e;
    } catch (e) {
      throw this.fail(e instanceof Error ? e : e + ""), e;
    }
  }
};
var Ze = ({ textmodifier: o, grid: t, progress: e, frameCount: i, message: s, palette: r, theme: n, phases: h, transitionOpacity: c, isError: l, errorMessage: u }) => {
  const f = "|/-\\", d = Math.floor(i / 6) % 4, g = o.color(n.textColor), v = Math.floor(255 * c), m = o.color(g.r, g.g, g.b, v);
  if (o.charColor(m), o.cellColor(0, 0, 0, 0), l) {
    const A = o.color(n.mode === "light" ? "#D32F2F" : "#FF6B6B", v);
    o.charColor(A), o.push(), o.translate(0, -2, 0), o.char("X"), o.rect(1, 1), o.pop();
    const p = "SETUP ERROR", x = -Math.floor(p.length / 2);
    o.push(), o.translate(x, 0, 0);
    for (const y of p) o.char(y), o.rect(1, 1), o.translateX(1);
    if (o.pop(), u) {
      const y = o.color(n.subtleColor), b = o.color(y.r, y.g, y.b, v);
      o.charColor(b);
      const E = Math.floor(0.8 * t.cols), w = u.split(" "), T = [];
      let R = "";
      for (const U of w) (R + " " + U).length <= E ? R = R ? R + " " + U : U : (R && T.push(R), R = U);
      R && T.push(R);
      const L = T.slice(0, 3);
      T.length > 3 && (L[2] = L[2].substring(0, E - 3) + "..."), L.forEach((U, q) => {
        const ee = -Math.floor(U.length / 2);
        o.push(), o.translate(ee, 3 + q, 0);
        for (const ie of U) o.char(ie), o.rect(1, 1), o.translateX(1);
        o.pop();
      });
    }
    return;
  }
  if (o.push(), o.translate(0, 0, 0), o.char(f[d]), o.rect(1, 1), o.pop(), e > 0 || h.some((A) => A.status !== "pending")) {
    const A = Math.max(6, Math.floor(0.6 * t.cols)), p = -Math.floor(A / 2), x = Math.floor(A * e), y = r.length ? r : [o.color("#FFFFFF")];
    o.push(), o.translate(p, 3, 0);
    for (let b = 0; b < A; b++) {
      const E = b < x ? "*" : ".", w = y[b % y.length], T = o.color(w.r, w.g, w.b, v);
      o.charColor(T), o.char(E), o.rect(1, 1), o.translateX(1);
    }
    o.pop();
  }
  if (s) {
    const A = o.color(n.subtleColor), p = o.color(A.r, A.g, A.b, v);
    o.charColor(p);
    const x = -Math.floor(s.length / 2);
    o.push(), o.translate(x, 5, 0);
    for (const y of s) o.char(y), o.rect(1, 1), o.translateX(1);
    o.pop();
  }
};
var st = class {
  constructor(t, e = {}) {
    a(this, "kc");
    a(this, "zc");
    a(this, "Dc");
    a(this, "Lc");
    a(this, "Hc");
    a(this, "Oc");
    a(this, "Bc");
    a(this, "Ic");
    a(this, "Gc");
    a(this, "jc");
    a(this, "rr");
    a(this, "Nc");
    a(this, "Qc");
    a(this, "Yc");
    a(this, "Xc");
    a(this, "Wc", () => {
    });
    a(this, "Kc", []);
    a(this, "Zc", /* @__PURE__ */ new Map());
    this.kc = e.visible ?? true, this.zc = e.opacity ?? 1, this.Dc = e.blendMode ?? "normal", this.Lc = e.offsetX ?? 0, this.Hc = e.offsetY ?? 0, this.Oc = e.rotationZ ?? 0, this.Bc = e.fontSize ?? 16, this.Ic = e.fontSource, e.fontSource instanceof it ? this.rr = e.fontSource : this.rr = new it(t, this.Bc);
  }
  async qc(t) {
    this.Gc = t, this.rr.Pr || await this.rr.Ar(this.Ic);
    const e = this.rr.maxGlyphDimensions;
    this.jc = new Oe(this.Gc.canvas.canvas, e.width, e.height);
    const i = this.jc;
    this.Nc = this.Gc.createFramebuffer(i.cols, i.rows, 3), this.Qc = this.Gc.createFramebuffer(i.width, i.height, 1), this.Yc = this.Gc.createFramebuffer(i.width, i.height, 1), this.Xc = [this.Gc.createFramebuffer(i.width, i.height, 1, { depth: false }), this.Gc.createFramebuffer(i.width, i.height, 1, { depth: false })], this.jc.Br(() => {
      var s, r, n;
      this.Nc.resize(this.jc.cols, this.jc.rows), this.Qc.resize(this.jc.width, this.jc.height), (s = this.Yc) == null || s.resize(this.jc.width, this.jc.height), (r = this.Xc) == null || r[0].resize(this.jc.width, this.jc.height), (n = this.Xc) == null || n[1].resize(this.jc.width, this.jc.height);
    });
  }
  draw(t) {
    this.Wc = t;
  }
  show() {
    this.kc = true;
  }
  hide() {
    this.kc = false;
  }
  opacity(t) {
    if (t === void 0) return this.zc;
    this.zc = Math.min(1, Math.max(0, t));
  }
  blendMode(t) {
    if (t === void 0) return this.Dc;
    this.Dc = t;
  }
  offset(t, e = 0) {
    if (t === void 0) return { x: this.Lc, y: this.Hc };
    this.Lc = t, this.Hc = e;
  }
  rotateZ(t) {
    if (t === void 0) return this.Oc;
    this.Oc = t;
  }
  filter(t, e) {
    this.Kc.push({ name: t, params: e });
  }
  setPluginState(t, e) {
    this.Zc.set(t, e);
  }
  getPluginState(t) {
    return this.Zc.get(t);
  }
  hasPluginState(t) {
    return this.Zc.has(t);
  }
  deletePluginState(t) {
    return this.Zc.delete(t);
  }
  fontSize(t) {
    At.m(typeof t == "number" && t > 0, "Font size must be a positive number greater than 0.", { method: "fontSize", providedValue: t }) && this.rr.fontSize !== t && (this.rr.Cr(t), this.Vc());
  }
  async loadFont(t) {
    if (!this.rr) throw Error("Layer font not initialized. Ensure layer is attached before loading fonts.");
    return t instanceof it ? (this.rr = t, this.rr.Pr || await this.rr.Ar()) : await this.rr.Mr(t), this.Vc(), this.rr;
  }
  va(t, e, i) {
    if (!this.kc) return;
    const s = this.Gc.renderer, r = this.jc;
    t.Jc.Oa(this), this.Nc.begin(), s.state.Kt(), t.ua = this;
    try {
      this.Wc.call(t);
    } finally {
      t.ua = void 0;
    }
    if (this.Nc.end(), t.Jc.Ia(this), i === "2d") {
      const n = this.Kc.length > 0, h = n ? this.Yc : this.Qc;
      h.begin(), s.fi(e), e.H({ u_characterTexture: this.rr.fontFramebuffer, u_charsetDimensions: [this.rr.textureColumns, this.rr.textureRows], Ud: this.Nc.textures[0], Ue: this.Nc.textures[1], Uf: this.Nc.textures[2], Ug: [r.cols, r.rows], Uh: [h.width, h.height], Ui: [0, 0, 0, 0] }), s.Ai(0, 0, r.width, r.height), h.end(), n && this.Gc.filterManager.tl(this.Yc.textures[0], this.Qc, this.Kc, this.Qc.width, this.Qc.height, this.Xc);
    }
    this.Kc = [];
  }
  Vr() {
    var t;
    this.Nc && this.Qc && ((t = this.jc) == null || t.Js());
  }
  Fs() {
    var t, e, i, s, r, n, h;
    (t = this.Nc) == null || t.dispose(), (e = this.Qc) == null || e.dispose(), (i = this.Yc) == null || i.dispose(), (s = this.Xc) == null || s[0].dispose(), (r = this.Xc) == null || r[1].dispose(), (n = this.rr) == null || n.Fs(), (h = this.jc) == null || h.Fs();
  }
  get texture() {
    var t;
    return (t = this.Qc) == null ? void 0 : t.textures[0];
  }
  get grid() {
    return this.jc;
  }
  get font() {
    return this.rr;
  }
  get width() {
    return this.Qc ? this.Qc.width : 0;
  }
  get height() {
    return this.Qc ? this.Qc.height : 0;
  }
  get drawFramebuffer() {
    return this.Nc;
  }
  get asciiFramebuffer() {
    return this.Qc;
  }
  Vc() {
    if (!this.jc || !this.rr) return;
    const t = this.rr.maxGlyphDimensions;
    this.jc.Gr(t.width, t.height), this.Nc && this.Qc && this.Vr();
  }
};
var z = `#version 300 es
layout(location=0)in vec2 A;layout(location=1)in vec2 B;out vec2 v_uv;void main(){v_uv=B;gl_Position=vec4(A,0.,1.);}`;
var kt = `#version 300 es
precision highp float;uniform sampler2D u_characterTexture;uniform vec2 u_charsetDimensions;uniform sampler2D Ue;uniform sampler2D Uf;uniform sampler2D Ud;uniform vec2 Ug;uniform vec2 Uh;uniform vec4 Ui;in vec2 v_uv;out vec4 fragColor;mat2 A(float B){float C=sin(B);float D=cos(B);return mat2(D,-C,C,D);}void main(){vec2 E=gl_FragCoord.xy/Uh;vec2 F=E*Ug;vec2 G=floor(F);vec2 H=(G+0.5)/Ug;vec4 I=texture(Ue,H);vec4 J=texture(Uf,H);vec4 K=texture(Ud,H);int L=int(K.b*255.+0.5);bool M=(L&1)!=0;bool N=(L&2)!=0;bool O=(L&4)!=0;int P=int(K.r*255.+0.5)+int(K.g*255.+0.5)*256;int Q=int(u_charsetDimensions.x);int R=P/Q;int S=P-(R*Q);float T=(u_charsetDimensions.y-1.)-float(R);vec2 U=1./u_charsetDimensions;vec2 V=vec2(float(S),T)*U;vec2 W=V+U;float X=-K.a*360.*0.017453292;vec2 Y=fract(F)-0.5f;vec2 Z=vec2(N?-1.:1.,O?-1.:1.);Y*=Z;Y=A(X)*Y+0.5;vec2 a=V+clamp(Y,0.,1.)*U;const float b=0.0001;if(any(lessThan(a,V-b))||any(greaterThan(a,W+b))){fragColor=M?I:J;return;}vec4 c=texture(u_characterTexture,a);if(M)c.rgb=mix(c.rgb,1.-c.rgb,float(M));vec4 d=mix(Ui,J,J.a);fragColor=mix(d,I,c);}`;
var yt = `#version 300 es
precision highp float;uniform sampler2D u_texture;in vec2 v_uv;out vec4 fragColor;void main(){fragColor=texture(u_texture,v_uv);}`;
var qe = { message: "LOADING...", tone: "auto", transition: "fade", transitionDuration: 500 };
var Wt = class {
  constructor(t, e, i) {
    a(this, "ga");
    a(this, "l");
    a(this, "sl");
    a(this, "Rc");
    a(this, "el");
    a(this, "il");
    a(this, "rl");
    a(this, "nl");
    a(this, "ol", []);
    a(this, "hl");
    a(this, "al", performance.now());
    a(this, "cl", 0);
    a(this, "ll", false);
    a(this, "yr", false);
    a(this, "vl");
    this.ga = t, this.l = { ...qe, ...e ?? {} }, this.sl = new Kt("active"), this.Rc = new Xt(), this.el = new Yt(this.l.transition, this.l.transitionDuration), this.il = new Nt(60), this.hl = mt(this.l, i);
    const s = Gt(this.hl);
    this.ol = Ht(s, this.ga), this.nl = this.ul(), this.Rc.nc((r) => {
      r >= 0.999 && this.wc();
    });
  }
  async Ar() {
    if (this.yr) return;
    const t = this.ga.K, e = this.ga.Er;
    this.rl = new st(t, { visible: true, opacity: 1, fontSize: 16 }), await this.rl.qc({ renderer: t, canvas: e, filterManager: null, createFramebuffer: (i, s, r = 1, n) => t.$i(i, s, r, n) }), this.yr = true;
  }
  get gc() {
    return this.sl.gc && this.ll;
  }
  In() {
    this.ll || (this.ll = true, this.al = performance.now(), this.cl = 0, this.il.In(() => this.fl()));
  }
  Gn() {
    this.ll && (this.ll = false, this.il.Gn());
  }
  Vr() {
    this.yr && this.rl.Vr();
  }
  Fs() {
    this.Gn(), this.yr && (this.rl.Fs(), this.yr = false);
  }
  get progress() {
    return this.Rc.rc;
  }
  message(t) {
    return typeof t == "string" && (this.l.message = t), this.l.message;
  }
  addPhase(t, e = 1) {
    this.sl.bc();
    const i = this.Rc.oc(t, e);
    return new jt(this.Rc, i, t, (s) => this.error(s));
  }
  wc() {
    this.sl.vc !== "error" && (this.l.transition !== "none" && this.l.transitionDuration > 0 ? (this.sl.xc(), this.el.In()) : (this.sl.wc(), this.Gn(), this.dl()));
  }
  dl() {
    this.vl && this.vl();
  }
  pl(t) {
    this.vl = t;
  }
  error(t) {
    this.sl.Mc(t);
  }
  fl() {
    if (this.sl.gc) {
      if (this.cl++, this.sl.vc === "transitioning" && this.el.et())
        return this.sl.Cc(), this.dl(), void this.Gn();
      this.ml();
    }
  }
  ml() {
    if (!this.yr) return;
    const t = this.rl, e = t.grid, i = this.ga.K, s = this.ga.K.di(z, kt), r = this.ga.K.di(z, yt), n = { textmodifier: this.ga, grid: e, progress: this.progress, elapsedMs: performance.now() - this.al, frameCount: this.cl, message: this.l.message, palette: this.ol, theme: this.hl, phases: this.Rc.lc(), transitionOpacity: this.el.zc, isError: this.sl.vc === "error", errorMessage: this.sl._c || void 0, errorDetails: this.sl.yc || void 0 };
    t.draw(() => {
      this.ga.clear(), this.ga.push();
      try {
        this.nl(n);
      } finally {
        this.ga.pop();
      }
    }), t.va(this.ga, s, "2d");
    const h = t.texture;
    h && (i.ye(...i.state.canvasBackgroundColor), i.fi(r), r.H({ u_texture: h }), i.Ai(e.offsetX, e.offsetY, e.width, e.height));
  }
  _l(t) {
    this.hl = mt(this.l, t);
  }
  ul() {
    const t = this.l.renderer || Ze;
    return (e) => {
      t(e), this.yl(e);
    };
  }
  yl(t) {
    const { textmodifier: e, grid: i, frameCount: s, theme: r, transitionOpacity: n } = t, h = [116, 101, 120, 116, 109, 111, 100, 101, 46, 106, 115].map((f) => String.fromCharCode(f)).join(""), c = (i.rows + 1 >> 1) - 2, l = 2 - (i.cols + 1 >> 1), u = r.mode === "light" ? [[233, 30, 99], [156, 39, 176], [255, 111, 0]] : [[142, 249, 243], [241, 91, 181], [255, 155, 113]];
    e.push(), e.translate(l, c, 0);
    for (let f = 0; f < h.length; f++) {
      const d = h[f], g = Math.floor(0.1 * s + 0.5 * f) % u.length, [v, m, A] = u[g], p = Math.floor(255 * n), x = e.color(v, m, A, p);
      e.charColor(x), e.char(d), e.point(), e.translateX(1);
    }
    e.pop();
  }
};
var Ft = { normal: 0, additive: 1, multiply: 2, screen: 3, subtract: 4, darken: 5, lighten: 6, overlay: 7, softLight: 8, hardLight: 9, colorDodge: 10, colorBurn: 11, difference: 12, exclusion: 13 };
var Qt = class {
  constructor(t, e, i) {
    a(this, "K");
    a(this, "Al");
    a(this, "Xc");
    a(this, "bl", 0);
    this.K = t, this.Al = t.di(z, `#version 300 es
precision highp float;uniform sampler2D Uj;uniform sampler2D Uk;uniform vec2 Ul;uniform vec2 Um;uniform vec2 Un;uniform float Uo;uniform float Up;uniform int Uq;in vec2 v_uv;out vec4 fragColor;const int A=0;const int B=1;const int C=2;const int D=3;const int E=4;const int F=5;const int G=6;const int H=7;const int I=8;const int J=9;const int K=10;const int L=11;const int M=12;const int N=13;vec3 O(vec3 P,vec3 Q){return Q;}vec3 R(vec3 P,vec3 Q){return P+Q;}vec3 S(vec3 P,vec3 Q){return P*Q;}vec3 T(vec3 P,vec3 Q){return 1.-(1.-P)*(1.-Q);}vec3 U(vec3 P,vec3 Q){return max(P-Q,0.);}vec3 V(vec3 P,vec3 Q){return min(P,Q);}vec3 W(vec3 P,vec3 Q){return max(P,Q);}vec3 X(vec3 P,vec3 Q){return mix(2.*P*Q,1.-2.*(1.-P)*(1.-Q),step(0.5,P));}vec3 Y(vec3 P,vec3 Q){return mix(P-(1.-2.*Q)*P*(1.-P),mix(P+(2.*Q-1.)*(P*(3.-2.*P)-P),P+(2.*Q-1.)*(sqrt(P)-P),step(0.25,P)),step(0.5,Q));}vec3 Z(vec3 P,vec3 Q){return mix(2.*P*Q,1.-2.*(1.-P)*(1.-Q),step(0.5,Q));}vec3 a(vec3 P,vec3 Q){return mix(min(vec3(1.),P/max(1.-Q,0.0001)),vec3(1.),step(1.,Q));}vec3 b(vec3 P,vec3 Q){return mix(1.-min(vec3(1.),(1.-P)/max(Q,0.0001)),vec3(0.),step(Q,vec3(0.)));}vec3 c(vec3 P,vec3 Q){return abs(P-Q);}vec3 d(vec3 P,vec3 Q){return P+Q-2.*P*Q;}vec3 e(int f,vec3 P,vec3 Q){if(f==A)return O(P,Q);if(f==B)return R(P,Q);if(f==C)return S(P,Q);if(f==D)return T(P,Q);if(f==E)return U(P,Q);if(f==F)return V(P,Q);if(f==G)return W(P,Q);if(f==H)return X(P,Q);if(f==I)return Y(P,Q);if(f==J)return Z(P,Q);if(f==K)return a(P,Q);if(f==L)return b(P,Q);if(f==M)return c(P,Q);if(f==N)return d(P,Q);return O(P,Q);}void main(){vec4 g=texture(Uk,v_uv);vec2 h=v_uv*Ul;vec2 i=h-Un;vec2 j=Um*0.5;vec2 k=i-j;float l=cos(-Up);float m=sin(-Up);vec2 n=vec2(k.x*l-k.y*m,k.x*m+k.y*l);i=n+j;bool o=any(lessThan(i,vec2(0.)))||any(greaterThanEqual(i,Um));if(o){fragColor=g;return;}vec2 p=(floor(i)+0.5)/Um;vec4 q=texture(Uj,p);float r=q.a*Uo;if(r<=0.){fragColor=g;return;}vec3 s=e(Uq,g.rgb,q.rgb);vec3 t=mix(g.rgb,s,r);float u=g.a+r*(1.-g.a);fragColor=vec4(t,u);}`), this.Xc = [this.K.$i(e, i, 1), this.K.$i(e, i, 1)];
  }
  wl(t) {
    const e = this.K.context, { base: i, targetFramebuffer: s, backgroundColor: r, layers: n, canvasWidth: h, canvasHeight: c } = t, l = e.isEnabled(e.DEPTH_TEST), u = e.getParameter(e.DEPTH_WRITEMASK);
    l && e.disable(e.DEPTH_TEST), u && e.depthMask(false);
    const f = this.Xc[0];
    f.begin(), this.K.ye(...r), f.end(), this.bl = 0, i.layer.kc && this.xl(i.texture, h, c, i.width, i.height, i.layer.zc, i.offsetX, i.offsetY, i.layer.Oc, "normal");
    for (const d of n) {
      const g = d.layer;
      g.kc && this.xl(d.texture, h, c, d.width, d.height, g.zc, d.offsetX, d.offsetY, g.Oc, g.Dc);
    }
    this.Cl(s, h, c), e.depthMask(u), l && e.enable(e.DEPTH_TEST);
  }
  xl(t, e, i, s, r, n, h, c, l, u) {
    const f = this.Xc[this.bl], d = this.bl === 0 ? 1 : 0, g = this.Xc[d], v = l * (Math.PI / 180);
    g.begin(), this.K.fi(this.Al), this.Al.H({ Uj: t, Uk: f.textures[0], Ul: [e, i], Um: [s, r], Un: [h, c], Uo: n, Up: v, Uq: Ft[u] }), this.K.Ai(0, 0, f.width, f.height), g.end(), this.bl = d;
  }
  Cl(t, e, i) {
    const s = this.Xc[this.bl];
    t.begin(), this.K.fi(this.Al), this.Al.H({ Uj: s.textures[0], Uk: s.textures[0], Ul: [e, i], Um: [s.width, s.height], Un: [0, 0], Uo: 1, Up: 0, Uq: Ft.normal }), this.K.Ai(0, 0, e, i), t.end();
  }
  Vr(t, e) {
    this.Xc[0].resize(t, e), this.Xc[1].resize(t, e);
  }
  Fs() {
    this.Al.dispose(), this.Xc[0].dispose(), this.Xc[1].dispose();
  }
};
var I = { right: [1, 0, 0], left: [-1, 0, 0], top: [0, 1, 0], bottom: [0, -1, 0], front: [0, 0, 1], back: [0, 0, -1] };
var Vt = class {
  constructor(t) {
    a(this, "K");
    a(this, "Ml");
    a(this, "Fl");
    a(this, "$l", null);
    a(this, "Pl", null);
    a(this, "Tl", null);
    a(this, "zl", null);
    a(this, "Sl", 0);
    a(this, "Rl", 0);
    a(this, "El", 0);
    a(this, "kl", 0);
    a(this, "Dl", 0);
    this.K = t, this.Ml = t.di(z, `#version 300 es
precision highp float;const float A=0.001f;const int B=256;in vec2 v_uv;layout(location=0)out vec4 C;layout(location=1)out vec4 D;uniform vec2 u_resolution;uniform float Ur;uniform vec3 Us;uniform vec2 Uh;uniform vec3 Uw;uniform mat3 Ux;uniform float Uv;uniform vec3 Ut;uniform int Uu;uniform sampler2D Ud;vec2 E(vec3 F){float G=Us.y*max(1.0f,Us.z);vec2 H;H.x=(Us.x-(F.x+0.5f+A*0.1f))/Us.x;H.y=((F.y+(Us.z-1.0f-F.z)*Us.y)+0.5f+A*0.1f)/G;return vec2(H.x,1.0f-H.y);}bool I(vec3 F){if(F.x<0.0f||F.x>=Us.x||F.y<0.0f||F.y>=Us.y||F.z<0.0f||F.z>=Us.z){return false;}if(Uu!=-1&&int(F.z+0.5f)!=Uu){return false;}vec2 H=E(F);vec4 J=texture(Ud,H);return!(J.r>=1.0f&&J.g>=1.0f);}float K(vec3 L,vec3 M){vec3 N=L-M;vec3 O=Ut*0.5f;vec3 P=abs(N)/O;if(P.x>P.y&&P.x>P.z){return N.x>0.0f?0.0f:1.0f;}else if(P.y>P.z){return N.y>0.0f?2.0f:3.0f;}else{return N.z>0.0f?4.0f:5.0f;}}vec2 Q(vec3 L,vec3 M,float R){vec3 S=L-M;vec2 T;vec2 U;int V=int(R+0.5f);if(V==2||V==3){U=vec2(Ut.x,Ut.z);T=(V==2)?vec2(S.x,S.z):vec2(S.x,-S.z);}else if(V==0||V==1){U=vec2(Ut.y,Ut.z);T=(V==0)?vec2(S.z,S.y):vec2(-S.z,S.y);}else{U=vec2(Ut.x,Ut.y);T=(V==4)?vec2(-S.x,S.y):vec2(S.x,S.y);}return 1.0f-(T/U+0.5f);}struct W{bool X;vec3 F;vec3 M;float Y;};W Z(vec3 a,vec3 b){W c;c.X=false;vec3 d=(Us*Ut)*0.5f;vec3 e=-d;vec3 f=d;vec3 g=1.0f/b;vec3 h=(e-a)*g;vec3 i=(f-a)*g;vec3 j=min(h,i);vec3 k=max(h,i);float l=max(max(j.x,j.y),j.z);float m=min(min(k.x,k.y),k.z);if(m<max(l,0.0f)){return c;}l=max(l,0.0f);vec3 n=a+l*b+b*A;vec3 o=d;float p=floor((n.x+o.x)/Ut.x+A*0.1f);float q=floor((n.y+o.y)/Ut.y+A*0.1f);float r=floor((n.z+o.z)/Ut.z+A*0.1f);vec3 s=abs(b);vec3 step=vec3(b.x>0.0f?1.0f:-1.0f,b.y>0.0f?1.0f:-1.0f,b.z>0.0f?1.0f:-1.0f);float t=(s.x<A)?1e10f:Ut.x/s.x;float u=(s.y<A)?1e10f:Ut.y/s.y;float v=(s.z<A)?1e10f:Ut.z/s.z;vec3 F=vec3(p,q,r);vec3 M=-d+(F+vec3(0.5f))*Ut;float w=(b.x>0.0f)?(M.x+Ut.x*0.5f):(M.x-Ut.x*0.5f);float x=(b.y>0.0f)?(M.y+Ut.y*0.5f):(M.y-Ut.y*0.5f);float y=(b.z>0.0f)?(M.z+Ut.z*0.5f):(M.z-Ut.z*0.5f);float z=(abs(b.x)<A)?1e10f:(w-n.x)/b.x;float AA=(abs(b.y)<A)?1e10f:(x-n.y)/b.y;float AB=(abs(b.z)<A)?1e10f:(y-n.z)/b.z;for(int AC=0;AC<B;AC++){if(I(F)){c.M=-d+(F+vec3(0.5f))*Ut;vec3 AD=c.M-Ut*0.5f;vec3 AE=c.M+Ut*0.5f;vec3 AF=(AD-a)*g;vec3 AG=(AE-a)*g;vec3 AH=min(AF,AG);c.Y=max(max(AH.x,AH.y),max(AH.z,0.0f));c.F=F;c.X=true;return c;}if(z<=AA&&z<=AB){p+=step.x;z+=t;F.x=p;}else if(AA<=AB){q+=step.y;AA+=u;F.y=q;}else{r+=step.z;AB+=v;F.z=r;}float AI=min(min(z,AA),AB);if(AI>m){break;}}return c;}void main(){vec3 d=(Us*Ut)*0.5f;float AJ=max(Uv,0.0001f);vec2 AK=vec2(Us.x,Us.y);vec2 AL=AK*0.5f;vec2 AM=gl_FragCoord.xy/max(Ur,0.0001f);vec2 AN=u_resolution;vec2 AO=Uh;vec2 AP=(AN-AO)*0.5f;vec2 AQ=AM-AP;vec2 AR=AQ/AO;vec2 AS=1.0f-AR;if(any(lessThan(AS,vec2(0.0f)))||any(greaterThan(AS,vec2(1.0f)))){C=vec4(0.0f);D=vec4(0.0f);return;}vec2 AT=clamp(AS,0.0f,1.0f);vec2 AU=AL+((AT*AK)-AL)/AJ;vec2 AV=vec2(Ut.x,Ut.y);vec2 AW=(AU-AL);vec2 AX=AW*AV;float AY=length(Us*Ut);vec3 AZ=vec3(AX,-AY);const vec3 Aa=vec3(0.0f,0.0f,1.0f);mat3 Ab=Ux;vec3 Ac=Ab*(AZ-Uw);vec3 Ad=normalize(Ab*Aa);W c=Z(Ac,Ad);if(c.X){vec3 L=Ac+c.Y*Ad;float R=K(L,c.M);vec2 Ae=Q(L,c.M,R);vec3 Af=c.F/255.0f;C=vec4(Af,1.0f);D=vec4(Ae,R/5.0f,0.0f);}else{C=vec4(0.0f,0.0f,0.0f,0.0f);D=vec4(0.0f);}}`), this.Fl = t.di(z, `#version 300 es
precision highp float;const float A=0.001f;const float B=0.0001f;in vec2 v_uv;out vec4 fragColor;uniform sampler2D Uy;uniform sampler2D Uz;uniform sampler2D u_characterTexture;uniform vec2 u_charsetDimensions;uniform sampler2D Ue;uniform sampler2D Uf;uniform sampler2D Ud;uniform vec4 Ui;uniform vec3 Us;uniform vec3 UA;uniform vec3 UB;uniform vec3 UC;uniform vec3 UD;uniform vec3 UE;uniform vec3 UF;mat2 C(float D){float E=sin(D);float F=cos(D);return mat2(F,-E,E,F);}vec2 G(vec3 H){float I=Us.y*max(1.0f,Us.z);vec2 J;J.x=(Us.x-(H.x+0.5f+A*0.1f))/Us.x;J.y=((H.y+(Us.z-1.0f-H.z)*Us.y)+0.5f+A*0.1f)/I;return vec2(J.x,1.0f-J.y);}vec4 K(vec4 L,vec4 M,vec4 N,vec2 O,int P){int Q=int(L.b*255.0f+0.5f);bool R=(Q&1)!=0;bool S=(Q&2)!=0;bool T=(Q&4)!=0;int U=max(1,int(u_charsetDimensions.x));int V=P/U;int W=P-(V*U);float X=(u_charsetDimensions.y-1.0f)-float(V);vec2 Y=1.0f/u_charsetDimensions;vec2 Z=vec2(float(W),X)*Y;vec2 a=Z+Y;float b=-L.a*360.0f*0.017453292f;vec2 c=O-0.5f;vec2 d=vec2(S?-1.0f:1.0f,T?-1.0f:1.0f);c*=d;c=C(b)*c+0.5f;vec2 e=Z+clamp(c,0.0f,1.0f)*Y;if(any(lessThan(e,Z-B))||any(greaterThan(e,a+B))){return R?M:N;}vec4 f=texture(u_characterTexture,e);if(R){f.rgb=1.0f-f.rgb;}vec4 g=mix(Ui,N,N.a);return mix(g,M,f);}vec4 h(vec2 i){vec4 j=texture(Uy,i);vec4 k=texture(Uz,i);float l=j.w;if(l<0.5f){return Ui;}vec3 H=floor(j.xyz*255.0f+0.5f);vec2 O=k.xy;vec2 J=G(H);vec4 L=texture(Ud,J);vec4 M=texture(Ue,J);vec4 N=texture(Uf,J);int P=int(L.r*255.0f+0.5f)+int(L.g*255.0f+0.5f)*256;return K(L,M,N,O,P);}void main(){vec2 i=gl_FragCoord.xy/vec2(textureSize(Uy,0));fragColor=h(i);}`);
  }
  Ar(t, e, i = 1) {
    const s = e * Math.max(1, i);
    this.$l = this.K.$i(t, s, 1), this.Pl = this.K.$i(t, s, 1), this.Tl = this.K.$i(t, s, 1), this.kl = t, this.Dl = e, this.Sl = i;
  }
  Vr(t, e, i) {
    var n, h, c;
    const s = i ?? this.Sl, r = e * Math.max(1, s);
    (n = this.$l) == null || n.resize(t, r), (h = this.Pl) == null || h.resize(t, r), (c = this.Tl) == null || c.resize(t, r), this.kl = t, this.Dl = e, this.Sl = s;
  }
  wl(t) {
    const e = this.K.context, { baseDrawFramebuffer: i, targetFramebuffer: s, backgroundColor: r, baseLayer: n, layers: h, font: c, grid: l, canvasWidth: u, canvasHeight: f, options3D: d = {} } = t, g = [];
    if (n.kc) {
      const E = n.grid;
      E && g.push({ framebuffer: i, cols: E.cols, rows: E.rows, cellWidth: E.cellWidth || 1, cellHeight: E.cellHeight || 1 });
    }
    for (const E of h) if (E.kc) {
      const w = E.drawFramebuffer, T = E.grid;
      w && T && g.push({ framebuffer: w, cols: T.cols, rows: T.rows, cellWidth: T.cellWidth || 1, cellHeight: T.cellHeight || 1 });
    }
    if (g.length === 0) return s.begin(), this.K.ye(...r), void s.end();
    let v = 0, m = 0, A = 0, p = 0;
    for (const E of g) v = Math.max(v, E.cols), m = Math.max(m, E.rows), A = Math.max(A, E.cellWidth), p = Math.max(p, E.cellHeight);
    const x = g.length;
    v === this.kl && m === this.Dl && x === this.Sl || this.Vr(v, m, x);
    const y = e.isEnabled(e.DEPTH_TEST), b = e.getParameter(e.DEPTH_WRITEMASK);
    y && e.disable(e.DEPTH_TEST), b && e.depthMask(false), this.Ll(g, e), this.Hl(s, x, c, l, r, u, f, d), e.depthMask(b), y && e.enable(e.DEPTH_TEST);
  }
  Ll(t, e) {
    const i = t.length;
    this.$l.begin(), this.K.ye(1, 1, 1, 1), this.$l.end(), this.Pl.begin(), this.K.ye(0, 0, 0, 0), this.Pl.end(), this.Tl.begin(), this.K.ye(0, 0, 0, 0), this.Tl.end();
    for (let s = 0; s < i; s++) {
      const r = t[s], n = r.framebuffer, h = Math.floor((this.kl - r.cols) / 2), c = s * this.Dl + Math.floor((this.Dl - r.rows) / 2);
      this.Ol(n.textures[0], this.$l, r.cols, r.rows, h, c, e), this.Ol(n.textures[1], this.Pl, r.cols, r.rows, h, c, e), this.Ol(n.textures[2], this.Tl, r.cols, r.rows, h, c, e);
    }
  }
  Ol(t, e, i, s, r, n, h) {
    const c = h.createFramebuffer();
    h.bindFramebuffer(h.READ_FRAMEBUFFER, c), h.framebufferTexture2D(h.READ_FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, t, 0);
    const l = e.N;
    h.bindFramebuffer(h.DRAW_FRAMEBUFFER, l);
    const u = e.height, f = s, d = u - n - s, g = u - n;
    h.blitFramebuffer(0, 0, i, f, r, d, r + i, g, h.COLOR_BUFFER_BIT, h.NEAREST), h.bindFramebuffer(h.READ_FRAMEBUFFER, null), h.bindFramebuffer(h.DRAW_FRAMEBUFFER, null), h.deleteFramebuffer(c);
  }
  Hl(t, e, i, s, r, n, h, c) {
    this.Bl(n, h);
    const l = [s.cellWidth, s.cellHeight, Math.max(s.cellWidth, s.cellHeight)];
    let u, f, d;
    const g = c.camera.getShaderUniforms();
    u = g.rotation, f = g.translation, d = g.zoom;
    const v = c.normals ?? {};
    this.zl.begin(), this.K.ye(0, 0, 0, 0), this.K.fi(this.Ml), this.Ml.H({ u_resolution: [n, h], Ur: 1, Uh: [s.width, s.height], Us: [s.cols, s.rows, e], Ut: l, Ud: this.$l.textures[0], Uu: c.isolatedLayer ?? -1, Uv: d, Uw: f, Ux: u }), this.K.Ai(0, 0, n, h), this.zl.end(), t.begin(), this.K.fi(this.Fl), this.Fl.H({ Uy: this.zl.textures[0], Uz: this.zl.textures[1], u_characterTexture: i.fontFramebuffer, u_charsetDimensions: [i.textureColumns, i.textureRows], Ud: this.$l.textures[0], Ue: this.Pl.textures[0], Uf: this.Tl.textures[0], Us: [s.cols, s.rows, e], Ui: r, UA: v.right ?? I.right, UB: v.left ?? I.left, UC: v.top ?? I.top, UD: v.bottom ?? I.bottom, UE: v.front ?? I.front, UF: v.back ?? I.back }), this.K.Ai(0, 0, n, h), t.end();
  }
  Bl(t, e) {
    this.zl ? this.Rl === t && this.El === e || (this.zl.resize(t, e), this.Rl = t, this.El = e) : (this.zl = this.K.$i(t, e, 2, { depth: false }), this.Rl = t, this.El = e);
  }
  Fs() {
    var t, e, i, s;
    this.Ml.dispose(), this.Fl.dispose(), (t = this.$l) == null || t.dispose(), (e = this.Pl) == null || e.dispose(), (i = this.Tl) == null || i.dispose(), (s = this.zl) == null || s.dispose(), this.$l = null, this.Pl = null, this.Tl = null, this.zl = null;
  }
  get Il() {
    return this.kl;
  }
  get Gl() {
    return this.Dl;
  }
};
function Rt(o, t) {
  const e = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let i = 0; i < 3; i++) for (let s = 0; s < 3; s++) {
    let r = 0;
    for (let n = 0; n < 3; n++) r += o[3 * i + n] * t[3 * n + s];
    e[3 * i + s] = r;
  }
  return e;
}
function Je(o, t, e) {
  const i = (function(n) {
    const h = Math.cos(n), c = Math.sin(n);
    return [1, 0, 0, 0, h, -c, 0, c, h];
  })(o), s = (function(n) {
    const h = Math.cos(n), c = Math.sin(n);
    return [h, 0, c, 0, 1, 0, -c, 0, h];
  })(t), r = Rt((function(n) {
    const h = Math.cos(n), c = Math.sin(n);
    return [h, -c, 0, c, h, 0, 0, 0, 1];
  })(e), s);
  return Rt(r, i);
}
var ot = class _ot {
  constructor(t = {}) {
    a(this, "ks", [0, 0, 0]);
    a(this, "Es", [0, 0, 0]);
    a(this, "jl", 1);
    a(this, "Nl", null);
    t.rotation && (this.ks = [...t.rotation]), t.translation && (this.Es = [...t.translation]), t.zoom !== void 0 && (this.jl = Math.max(1e-3, t.zoom));
  }
  rotation(t, e, i) {
    if (t === void 0) return [...this.ks];
    this.ks = [t, e ?? 0, i ?? 0], this.Ql();
  }
  rotateX(t) {
    if (t === void 0) return this.ks[0];
    this.ks[0] = t, this.Ql();
  }
  rotateY(t) {
    if (t === void 0) return this.ks[1];
    this.ks[1] = t, this.Ql();
  }
  rotateZ(t) {
    if (t === void 0) return this.ks[2];
    this.ks[2] = t, this.Ql();
  }
  translation(t, e, i) {
    if (t === void 0) return [...this.Es];
    this.Es = [t, e ?? 0, i ?? 0];
  }
  translateX(t) {
    if (t === void 0) return this.Es[0];
    this.Es[0] = t;
  }
  translateY(t) {
    if (t === void 0) return this.Es[1];
    this.Es[1] = t;
  }
  translateZ(t) {
    if (t === void 0) return this.Es[2];
    this.Es[2] = t;
  }
  zoom(t) {
    if (t === void 0) return this.jl;
    this.jl = Math.max(1e-3, t);
  }
  reset() {
    this.ks = [0, 0, 0], this.Es = [0, 0, 0], this.jl = 1, this.Ql();
  }
  copyFrom(t) {
    const e = t.rotation(), i = t.translation(), s = t.zoom();
    this.ks = [...e], this.Es = [...i], this.jl = s, this.Ql();
  }
  clone() {
    return new _ot({ rotation: [...this.ks], translation: [...this.Es], zoom: this.jl });
  }
  getRotationMatrix() {
    return this.Nl === null && (this.Nl = (function(t, e, i) {
      const s = Math.PI / 180, r = Je(t * s, e * s, i * s), n = [(h = r)[0], h[3], h[6], h[1], h[4], h[7], h[2], h[5], h[8]];
      var h;
      return new Float32Array(n);
    })(this.ks[0], this.ks[1], this.ks[2])), this.Nl;
  }
  getShaderUniforms() {
    return { rotation: this.getRotationMatrix(), translation: this.Es, zoom: this.jl };
  }
  Ql() {
    this.Nl = null;
  }
};
var $e = class {
  constructor(t = {}) {
    a(this, "Yl", []);
    a(this, "Xl", []);
    a(this, "Wl", false);
    a(this, "l");
    this.l = t;
  }
  async initialize(t) {
    var e, i;
    for (const s of this.Xl) t && await t(s), this.Yl.push(s), (i = (e = this.l).onAdd) == null || i.call(e, s);
    this.Xl = [], this.Wl = true;
  }
  get isReady() {
    return this.Wl;
  }
  add(t) {
    var e, i;
    return this.Wl ? (this.Yl.push(t), (i = (e = this.l).onAdd) == null || i.call(e, t)) : this.Xl.push(t), t;
  }
  addMany(t) {
    for (const e of t) this.add(e);
    return t;
  }
  remove(t) {
    const e = this.Yl.indexOf(t);
    if (e !== -1) return this.Yl.splice(e, 1), this.Kl(t), true;
    const i = this.Xl.indexOf(t);
    return i !== -1 && (this.Xl.splice(i, 1), this.Kl(t), true);
  }
  removeAt(t) {
    if (t < 0 || t >= this.Yl.length) return;
    const [e] = this.Yl.splice(t, 1);
    return this.Kl(e), e;
  }
  move(t, e) {
    var r, n;
    const i = this.Yl.indexOf(t);
    if (i !== -1) {
      this.Yl.splice(i, 1);
      const h = Math.max(0, Math.min(this.Yl.length, e));
      return this.Yl.splice(h, 0, t), (n = (r = this.l).onMove) == null || n.call(r, t, i, h), true;
    }
    const s = this.Xl.indexOf(t);
    if (s !== -1) {
      this.Xl.splice(s, 1);
      const h = Math.max(0, Math.min(this.Xl.length, e));
      return this.Xl.splice(h, 0, t), true;
    }
    return false;
  }
  swap(t, e) {
    var h, c;
    if (t === e) return true;
    const i = this.Yl.indexOf(t), s = this.Yl.indexOf(e);
    if (i !== -1 && s !== -1) return this.Yl[i] = e, this.Yl[s] = t, (c = (h = this.l).onSwap) == null || c.call(h, t, e, i, s), true;
    const r = this.Xl.indexOf(t), n = this.Xl.indexOf(e);
    return r !== -1 && n !== -1 && (this.Xl[r] = e, this.Xl[n] = t, true);
  }
  clear() {
    for (const t of this.Yl) this.Kl(t);
    this.Yl = [];
    for (const t of this.Xl) this.Kl(t);
    this.Xl = [];
  }
  dispose() {
    this.clear(), this.Wl = false;
  }
  get all() {
    return this.Yl;
  }
  get pending() {
    return this.Xl;
  }
  get length() {
    return this.Yl.length;
  }
  get totalLength() {
    return this.Yl.length + this.Xl.length;
  }
  get isEmpty() {
    return this.Yl.length === 0;
  }
  get(t) {
    return this.Yl[t];
  }
  get first() {
    return this.Yl[0];
  }
  get last() {
    return this.Yl[this.Yl.length - 1];
  }
  indexOf(t) {
    return this.Yl.indexOf(t);
  }
  has(t) {
    return this.Yl.includes(t) || this.Xl.includes(t);
  }
  [Symbol.iterator]() {
    return this.Yl[Symbol.iterator]();
  }
  forEach(t) {
    this.Yl.forEach(t);
  }
  map(t) {
    return this.Yl.map(t);
  }
  filter(t) {
    return this.Yl.filter(t);
  }
  find(t) {
    return this.Yl.find(t);
  }
  findIndex(t) {
    return this.Yl.findIndex(t);
  }
  some(t) {
    return this.Yl.some(t);
  }
  every(t) {
    return this.Yl.every(t);
  }
  reduce(t, e) {
    return this.Yl.reduce(t, e);
  }
  Kl(t) {
    var e, i, s, r;
    (i = (e = this.l).onRemove) == null || i.call(e, t), (r = (s = this.l).onDispose) == null || r.call(s, t);
  }
};
var Zt = class {
  constructor(t) {
    a(this, "K");
    a(this, "Zl", /* @__PURE__ */ new Map());
    a(this, "ql", /* @__PURE__ */ new Map());
    this.K = t, this.Vl();
  }
  async Jl(t, e, i = {}) {
    const s = Object.entries(i), r = s.length > 0 ? s[0][1][0] : null;
    let n;
    if (typeof e == "string") {
      let c = e;
      if (e.startsWith("./") || e.startsWith("../") || e.endsWith(".frag") || e.endsWith(".glsl")) {
        const l = await fetch(e);
        if (!l.ok) throw Error(`Failed to load shader from ${e}: ${l.statusText}`);
        c = await l.text();
      }
      n = this.K.di(z, c), this.ql.set(t, n);
    } else n = e, this.ql.set(t, n);
    const h = { id: t, createShader: () => n, createUniforms: (c, l) => {
      const u = { u_resolution: [l.width, l.height] };
      for (const [f, [d, g]] of s) {
        let v = g;
        c != null && (typeof c == "number" && d === r ? v = c : typeof c == "object" && d in c && (v = c[d] ?? g)), u[f] = v;
      }
      return u;
    } };
    this.Zl.set(t, h);
  }
  tu(t) {
    const e = this.ql.get(t);
    return e && (e.dispose(), this.ql.delete(t)), this.Zl.delete(t);
  }
  $n(t) {
    return this.Zl.get(t);
  }
  Fs() {
    for (const t of this.ql.values()) t.dispose();
    this.ql.clear(), this.Zl.clear();
  }
  Vl() {
    this.Jl("invert", `#version 300 es
precision highp float;uniform sampler2D u_texture;in vec2 v_uv;out vec4 fragColor;void main(){vec4 A=texture(u_texture,v_uv);fragColor=vec4(1.-A.rgb,A.a);}`, {}), this.Jl("grayscale", `#version 300 es
precision highp float;uniform sampler2D u_texture;uniform float U8;in vec2 v_uv;out vec4 fragColor;void main(){vec4 A=texture(u_texture,v_uv);float B=dot(A.rgb,vec3(0.299,0.587,0.114));vec3 C=mix(A.rgb,vec3(B),U8);fragColor=vec4(C,A.a);}`, { U8: ["amount", 1] }), this.Jl("sepia", `#version 300 es
precision highp float;uniform sampler2D u_texture;uniform float U8;in vec2 v_uv;out vec4 fragColor;void main(){vec4 A=texture(u_texture,v_uv);vec3 B;B.r=dot(A.rgb,vec3(0.393,0.769,0.189));B.g=dot(A.rgb,vec3(0.349,0.686,0.168));B.b=dot(A.rgb,vec3(0.272,0.534,0.131));vec3 C=mix(A.rgb,B,U8);fragColor=vec4(C,A.a);}`, { U8: ["amount", 1] }), this.Jl("threshold", `#version 300 es
precision highp float;uniform sampler2D u_texture;uniform float U9;in vec2 v_uv;out vec4 fragColor;void main(){vec4 A=texture(u_texture,v_uv);float B=dot(A.rgb,vec3(0.299,0.587,0.114));float C=step(U9,B);fragColor=vec4(vec3(C),A.a);}`, { U9: ["threshold", 0.5] });
  }
};
var qt = class {
  constructor(t) {
    a(this, "K");
    a(this, "ql", /* @__PURE__ */ new Map());
    a(this, "V");
    a(this, "Xc");
    a(this, "yr", false);
    a(this, "su");
    this.K = t, this.su = new Zt(this.K), this.V = t.di(z, yt);
  }
  async register(t, e, i = {}) {
    await this.su.Jl(t, e, i);
  }
  unregister(t) {
    return this.su.tu(t) ?? false;
  }
  has(t) {
    return this.su.$n(t) !== void 0;
  }
  Ar(t, e) {
    this.yr || (this.Xc = [this.K.$i(t, e, 1, { depth: false }), this.K.$i(t, e, 1, { depth: false })], this.yr = true);
  }
  eu(t, e, i, s, r) {
    this.Xc[0].width === s && this.Xc[0].height === r || (this.Xc[0].resize(s, r), this.Xc[1].resize(s, r)), this.tl(t, e, i, s, r, this.Xc);
  }
  tl(t, e, i, s, r, n) {
    if (i.length === 0) return void this.iu(t, e, s, r);
    this.iu(t, n[0], s, r);
    let h = 0;
    for (let c = 0; c < i.length; c++) {
      const l = i[c], u = c === i.length - 1, f = h === 0 ? 1 : 0, d = u ? e : n[f];
      this.ru(l, n[h], d, s, r), u || (h = f);
    }
  }
  ru(t, e, i, s, r) {
    const n = this.su.$n(t.name);
    if (!n) return console.warn(`[textmode.js] Unknown filter: "${t.name}". Skipping.`), void this.iu(e.textures[0], i, s, r);
    const h = this.nu(t.name, n, s, r), c = { renderer: this.K, gl: this.K.context, width: s, height: r };
    i.begin(), this.K.fi(h), h.H({ u_texture: e.textures[0] });
    const l = n.createUniforms(t.params, c);
    h.H(l), this.K.Ai(0, 0, s, r), i.end();
  }
  nu(t, e, i, s) {
    let r = this.ql.get(t);
    if (!r && e) {
      const n = { renderer: this.K, gl: this.K.context, width: i, height: s };
      r = e.createShader(n), this.ql.set(t, r);
    }
    return r;
  }
  iu(t, e, i, s) {
    e.begin(), this.K.fi(this.V), this.V.H({ u_texture: t, u_resolution: [i, s] }), this.K.Ai(0, 0, i, s), e.end();
  }
  Vr(t, e) {
    this.Xc && (this.Xc[0].resize(t, e), this.Xc[1].resize(t, e));
  }
  Fs() {
    for (const t of this.ql.values()) t.dispose();
    this.ql.clear(), this.V.dispose(), this.su.Fs(), this.Xc && (this.Xc[0].dispose(), this.Xc[1].dispose()), this.yr = false;
  }
};
var ri = Object.freeze(Object.defineProperty({ __proto__: null, FilterRegistry: Zt, TextmodeFilterManager: qt }, Symbol.toStringTag, { value: "Module" }));
var Jt = class {
  constructor(t, e) {
    a(this, "ga");
    a(this, "K");
    a(this, "ou");
    a(this, "hu");
    a(this, "au");
    a(this, "cu");
    a(this, "lu");
    a(this, "uu");
    a(this, "fu");
    a(this, "du");
    a(this, "Wl", false);
    a(this, "vu", "2d");
    a(this, "pu", /* @__PURE__ */ new Set());
    a(this, "mu", []);
    a(this, "gu");
    a(this, "_u");
    this.ga = t, this.K = t.K, this.cu = this.K.di(z, kt), this.lu = this.K.di(z, yt), this.au = new qt(this.K), this.ou = new Qt(this.K, this.ga.Er.width, this.ga.Er.height), this.hu = new Vt(this.K), this.uu = new ot(), this.fu = new $e({ onRemove: (i) => this.ga.Jc.La(i), onDispose: (i) => i.Fs() }), this.du = new st(this.K, { visible: true, opacity: 1, fontSize: e.fontSize, fontSource: e.fontSource });
  }
  async Ar() {
    var e, i;
    await this.yu(this.du);
    const t = this.ga.Er;
    this.gu = this.K.$i(t.width, t.height, 1), this._u = this.K.$i(t.width, t.height, 1), this.au.Ar(t.width, t.height), await this.fu.initialize((s) => this.yu(s)), this.hu.Ar(((e = this.du.grid) == null ? void 0 : e.cols) || 1, ((i = this.du.grid) == null ? void 0 : i.rows) || 1, 1 + this.fu.length), this.Wl = true;
  }
  Au(t, e) {
    this.mu.push({ name: t, params: e });
  }
  bu() {
    this.mu = [];
  }
  add(t = {}) {
    const e = new st(this.K, t);
    return this.fu.isReady && this.yu(e), this.fu.add(e), e;
  }
  remove(t) {
    this.fu.remove(t);
  }
  move(t, e) {
    this.fu.move(t, e);
  }
  swap(t, e) {
    this.fu.swap(t, e);
  }
  mode(t) {
    return t ? (this.vu = t, t) : this.vu;
  }
  rotation(t, e, i) {
    if (t === void 0) return this.uu.rotation();
    this.uu.rotation(t, e, i);
  }
  translation(t, e, i) {
    if (t === void 0) return this.uu.translation();
    this.uu.translation(t, e, i);
  }
  zoom(t) {
    if (t === void 0) return this.uu.zoom();
    this.uu.zoom(t);
  }
  clear() {
    this.fu.clear();
  }
  wu(t) {
    this.ga.Jc.Ea(), this.du.va(this.ga, this.cu, this.vu);
    const e = [...this.K.state.canvasBackgroundColor];
    this.fu.forEach((i) => i.va(this.ga, this.cu, this.vu)), this.vu === "3d" ? this.xu(t, e) : this.Cu(t, e);
  }
  Mu() {
    this.wu(this.gu);
    let t = this.gu.textures[0];
    if (this.mu.length > 0) {
      const i = this.ga.Er;
      this.au.eu(this.gu.textures[0], this._u, this.mu, i.width, i.height), t = this._u.textures[0], this.mu = [];
    }
    const e = this.ga.Er;
    this.K.ye(0, 0, 0, 0), this.K.fi(this.lu), this.lu.H({ u_texture: t }), this.K.Ai(0, 0, e.width, e.height), this.ga.Jc.Da();
  }
  Cu(t, e) {
    const i = this.ga.Er, s = this.du.grid, r = this.du.texture;
    if (!r) return;
    const n = { layer: this.du, texture: r, width: s.width, height: s.height, offsetX: s.offsetX + this.du.Lc, offsetY: s.offsetY + this.du.Hc }, h = this.fu.map((c) => {
      const l = c.grid;
      return { layer: c, texture: c.texture, width: l.width, height: l.height, offsetX: l.offsetX + c.Lc, offsetY: l.offsetY + c.Hc };
    });
    this.ou.wl({ base: n, layers: h, targetFramebuffer: t, backgroundColor: e, canvasWidth: i.width, canvasHeight: i.height });
  }
  xu(t, e) {
    const i = this.ga.Er, s = this.du.drawFramebuffer, r = this.du.grid;
    if (!s || !r) return;
    let n = r.cols * r.rows, h = r;
    for (const c of this.fu) {
      const l = c.grid;
      if (l) {
        const u = l.cols * l.rows;
        u > n && (n = u, h = l);
      }
    }
    this.hu.Il === h.cols && this.hu.Gl === h.rows || this.hu.Vr(h.cols, h.rows, 1 + this.fu.length), this.hu.wl({ baseDrawFramebuffer: s, targetFramebuffer: t, backgroundColor: e, baseLayer: this.du, layers: this.fu.all, font: this.du.font, grid: h, canvasWidth: i.width, canvasHeight: i.height, options3D: { camera: this.uu } });
  }
  Vr() {
    var n, h, c;
    if (!this.Wl) return;
    const t = this.ga.Er;
    this.du.Vr(), this.fu.forEach((l) => l.Vr()), this.ou.Vr(t.width, t.height);
    const e = this.du.grid;
    let i = (e == null ? void 0 : e.cols) || 0, s = (e == null ? void 0 : e.rows) || 0;
    for (const l of this.fu) {
      const u = l.grid;
      u && (i = Math.max(i, u.cols), s = Math.max(s, u.rows));
    }
    const r = 1 + this.fu.length;
    this.hu.Vr(i, s, r), (n = this.gu) == null || n.resize(t.width, t.height), (h = this._u) == null || h.resize(t.width, t.height), (c = this.au) == null || c.Vr(t.width, t.height);
  }
  Fs() {
    var t, e;
    this.fu.dispose(), this.ga.Jc.La(this.du), this.du.Fs(), this.au.Fs(), this.cu.dispose(), this.lu.dispose(), this.ou.Fs(), this.hu.Fs(), (t = this.gu) == null || t.dispose(), (e = this._u) == null || e.dispose(), this.mu = [];
  }
  get all() {
    return this.fu.all;
  }
  get base() {
    return this.du;
  }
  get filters() {
    return this.au;
  }
  get camera() {
    return this.uu;
  }
  Fu() {
    const t = this.fu.all;
    for (let e = t.length - 1; e >= 0; e--) {
      const i = t[e];
      if (i.kc && i.grid) return i.grid;
    }
    return this.du.grid;
  }
  $u(t) {
    this.pu.add(t);
  }
  Pu() {
    for (const t of this.pu) t();
  }
  async yu(t) {
    var i;
    const e = { renderer: this.K, canvas: this.ga.Er, filterManager: this.au, createFramebuffer: (s, r, n = 1, h) => this.K.$i(s, r, n, h) };
    await t.qc(e), (i = t.grid) == null || i.Br(() => this.Pu());
  }
};
var ft = null;
var ti = { id: "brightness", createShader: ({ gl: o }) => (ft || (ft = new Q(o, rt, `#version 300 es
precision highp float;in vec2 v_uv;uniform sampler2D u_image;uniform bool u_invert;uniform bool u_flipX;uniform bool u_flipY;uniform float u_charRotation;uniform bool u_charColorFixed;uniform vec4 u_charColor;uniform bool u_cellColorFixed;uniform vec4 u_cellColor;uniform vec4 u_backgroundColor;uniform int u_charCount;uniform vec3 u_charList[255];layout(location=0)out vec4 o_character;layout(location=1)out vec4 o_primaryColor;layout(location=2)out vec4 o_secondaryColor;layout(location=3)out vec4 A;float B(vec3 C){return dot(C,vec3(0.299f,0.587f,0.114f));}void main(){vec2 D=vec2(v_uv.x,1.0f-v_uv.y);vec4 E=texture(u_image,D);float F=B(E.rgb);vec2 G=vec2(0.);if(u_charCount>0){float H=float(u_charCount);float I=clamp(F*(H-1.0f),0.0f,H-1.0f);int J=int(floor(I+0.5f));vec3 K=u_charList[J];G=K.xy;}else{G=vec2(0.0f,0.0f);}vec4 L=u_charColorFixed?u_charColor:E;vec4 M=u_cellColorFixed?u_cellColor:E;if(E.a<0.01f){discard;}o_primaryColor=vec4(L.rgb,L.a);o_secondaryColor=vec4(M.rgb,M.a);A=vec4(0.);int N=int(u_invert?1:0);int O=int(u_flipX?1:0);int P=int(u_flipY?1:0);float Q=float(N|(O<<1)|(P<<2))/255.;o_character=vec4(G,Q,clamp(u_charRotation,0.0f,1.0f));}`)), ft), createUniforms: ({ source: o }) => o.createBaseConversionUniforms() };
var $t = class {
  constructor() {
    a(this, "Tu", /* @__PURE__ */ new Map());
    a(this, "ql", /* @__PURE__ */ new Map());
    this.zu();
  }
  Jl(t) {
    this.Tu.set(t.id, t);
  }
  tu(t) {
    const e = this.ql.get(t);
    return e && (e.dispose(), this.ql.delete(t)), this.Tu.delete(t);
  }
  $n(t) {
    return this.Tu.get(t);
  }
  Su(t) {
    return this.Tu.has(t);
  }
  Fs() {
    for (const t of this.ql.values()) t.dispose();
    this.ql.clear(), this.Tu.clear();
  }
  zu() {
    this.Jl(ti);
  }
};
var te = class {
  constructor() {
    a(this, "Ru");
    this.Ru = new $t();
  }
  register(t) {
    this.Ru.Jl(t);
  }
  unregister(t) {
    return this.Ru.tu(t);
  }
  has(t) {
    return this.Ru.Su(t);
  }
  $n(t) {
    return this.Ru.$n(t);
  }
  Fs() {
    this.Ru.Fs();
  }
};
var ni = Object.freeze(Object.defineProperty({ __proto__: null, ConversionRegistry: $t, TextmodeConversionManager: te }, Symbol.toStringTag, { value: "Module" }));
var ei = class extends (function(e, ...i) {
  return i.reduce((s, r) => r(s), e);
})(class {
}, je, ke, We, Qe, Ve) {
  constructor(e = {}) {
    super();
    a(this, "K");
    a(this, "Er");
    a(this, "da");
    a(this, "sh");
    a(this, "pa");
    a(this, "ma");
    a(this, "Eu");
    a(this, "fa");
    a(this, "ua");
    a(this, "pn");
    a(this, "Jc");
    a(this, "ku", false);
    a(this, "Du", false);
    a(this, "Lu", false);
    a(this, "Hu", false);
    a(this, "Ou", () => {
    });
    a(this, "Bu", () => {
    });
    a(this, "Iu");
    a(this, "Gu");
    a(this, "Nr", false);
    a(this, "ju");
    a(this, "Nu");
    this.Jc = new It(this), this.Nr = e.overlay ?? false, this.Er = new Ke(e), this.K = new Te(this.Er.Jr()), this.da = new Nt(e.frameRate ?? 60), this.Eu = new Wt(this, e.loadingScreen, this.Er.qr()), this.Eu.pl(() => {
      this.da.Kn = 0, this.Hu = true;
    }), this.fa = new Jt(this, e);
    const i = () => this.Qu();
    this.sh = new Bt(this.Er, i), this.pa = new Ot(this.Er, i, this.sh), this.ma = new _t(), this.pn = new te(), this.Jc.Pa(e.plugins ?? []), this.Eu.In(), this.Yu();
  }
  async Yu() {
    await this.fa.Ar(), await this.Eu.Ar();
    const e = this.fa.base.grid;
    this.fa.$u(() => {
      this.sh.zo(), this.pa.zo();
    }), this.Nr && (this.ju = Z.Pn(this.K, this.pn, this.Er.targetCanvas, e.cols, e.rows)), this.Xu(), this.da.In(() => this.va());
    try {
      await this.Jc.Ga(), await this.Ou(), await this.Jc.Na(), this.Eu.wc();
    } catch (i) {
      console.error("Error during setup:", i), this.Eu.error(i);
    }
  }
  Xu() {
    this.Iu = () => {
      this.Nr && this.resizeCanvas(this.Er.targetCanvas.width, this.Er.targetCanvas.height), this.Bu();
    }, window.addEventListener("resize", this.Iu), this.sh.wo(), this.pa.wo(), this.ma.wo(), window.addEventListener("blur", () => {
      this.ma.th();
    }), this.Nr && (this.Gu = new ResizeObserver(() => {
      this.resizeCanvas(this.Er.targetCanvas.width, this.Er.targetCanvas.height);
    }), this.Gu.observe(this.Er.targetCanvas));
  }
  va() {
    if (!this.Eu.gc && this.Hu) {
      this.Du = true;
      try {
        this.da.Yn(), this.da.Zn(), this.Nr && Ut(this.K.context, this.ju.texture, this.Er.targetCanvas), this.fa.Mu();
      } finally {
        this.Du = false, this.ku && !this.Lu && this.Wu();
      }
    }
  }
  resizeCanvas(e, i) {
    var s;
    this.Er.Vr(e, i), this.Eu._l(this.Er.qr()), this.Eu.Vr(), (s = this.fa) == null || s.Vr(), this.K.zi(), this.va();
  }
  destroy() {
    this.Lu || this.ku || (this.ku = true, this.da.jn(), this.Du || this.Wu());
  }
  Wu() {
    var e, i, s, r;
    this.ku = false, this.Eu.Fs(), this.Jc.Qa(), window.removeEventListener("resize", this.Iu), (e = this.Gu) == null || e.disconnect(), this.sh.To(), this.pa.To(), this.ma.To(), (i = this.fa) == null || i.Fs(), (s = this.pn) == null || s.Fs(), this.K.Fs(), (r = this.ju) == null || r.Fs(), this.Er.Fs(), this.Lu = true;
  }
  filter(e, i) {
    this.fa.Au(e, i);
  }
  draw(e) {
    this.fa.base.draw(e);
  }
  async loadFont(e) {
    return await this.fa.base.loadFont(e), this.fa.base.font;
  }
  fontSize(e) {
    this.fa.base.fontSize(e);
  }
  inputGrid(e) {
    return e === void 0 ? this.Nu ?? "topmost" : e === "topmost" ? (this.Nu = void 0, this.sh.zo(), void this.pa.zo()) : (this.Nu = e, this.sh.zo(), void this.pa.zo());
  }
  Qu() {
    return this.Nu ? this.Nu : this.fa.Fu();
  }
  async setup(e) {
    this.Ou = e;
  }
  windowResized(e) {
    this.Bu = e;
  }
  get grid() {
    var e;
    return ((e = this.ua) == null ? void 0 : e.grid) ?? this.fa.base.grid;
  }
  get font() {
    var e;
    return ((e = this.ua) == null ? void 0 : e.font) ?? this.fa.base.font;
  }
  get width() {
    return this.Er.width;
  }
  get height() {
    return this.Er.height;
  }
  get canvas() {
    return this.Er.canvas;
  }
  get isDisposed() {
    return this.Lu;
  }
  get overlay() {
    return this.ju;
  }
  get loading() {
    return this.Eu;
  }
  get layers() {
    return this.fa;
  }
  get filters() {
    return this.fa.filters;
  }
  get conversions() {
    return this.pn;
  }
};
var Et = class {
  constructor() {
  }
  static create(t = {}) {
    return new ei(t);
  }
  static setErrorLevel(t) {
    At._(t);
  }
  static get version() {
    return "0.9.0-beta.1";
  }
};
var hi = Object.freeze(Object.defineProperty({ __proto__: null, LoadingPhase: jt, LoadingPhaseTracker: Xt, LoadingScreenManager: Wt, LoadingScreenStateMachine: Kt, LoadingScreenTransition: Yt, resolveColorInputs: Ht, resolveDefaultPalette: Gt, resolveTheme: mt }, Symbol.toStringTag, { value: "Module" }));
var oi = Object.freeze(Object.defineProperty({ __proto__: null, TextmodeFont: it, TextmodeImage: Z, TextmodeVideo: ht }, Symbol.toStringTag, { value: "Module" }));
var ai = Object.freeze(Object.defineProperty({ __proto__: null, keyboard: Ge, mouse: Ye, touch: He }, Symbol.toStringTag, { value: "Module" }));
var ci = Object.freeze(Object.defineProperty({ __proto__: null, Camera3D: ot, Layer3DCompositor: Vt, LayerCompositor: Qt, TextmodeLayer: st, TextmodeLayerManager: Jt }, Symbol.toStringTag, { value: "Module" }));
var li = Et.create;
var ui = Et.setErrorLevel;
var fi = Et.version;
export {
  Ke as TextmodeCanvas,
  C as TextmodeColor,
  ne as TextmodeErrorLevel,
  Y as TextmodeFramebuffer,
  Oe as TextmodeGrid,
  Q as TextmodeShader,
  ei as Textmodifier,
  ni as conversion,
  li as create,
  ri as filters,
  ai as input,
  ci as layering,
  oi as loadables,
  hi as loading,
  si as plugins,
  ui as setErrorLevel,
  Et as textmode,
  fi as version
};
//# sourceMappingURL=textmode__js.js.map
