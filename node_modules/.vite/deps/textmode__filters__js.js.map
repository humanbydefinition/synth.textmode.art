{
  "version": 3,
  "sources": ["../../textmode.filters.js/dist/textmode.filters.esm.js"],
  "sourcesContent": ["const n = () => ({ name: \"textmode.filters\", version: \"1.0.0\", async install(r) {\n  r.filters.register(\"brightness\", `#version 300 es\\r\nprecision highp float;\\r\n\\r\nuniform sampler2D u_texture;\\r\nuniform vec2 u_resolution;\\r\nuniform float u_amount;\\r\n\\r\nin vec2 v_uv;\\r\nout vec4 fragColor;\\r\n\\r\nvoid main() {\\r\n    vec4 color = texture(u_texture, v_uv);\\r\n    \\r\n    // Multiply RGB by brightness amount\\r\n    vec3 result = color.rgb * u_amount;\\r\n    \\r\n    fragColor = vec4(result, color.a);\\r\n}`, { u_amount: [\"amount\", 1] }), r.filters.register(\"contrast\", `#version 300 es\\r\nprecision highp float;\\r\n\\r\nuniform sampler2D u_texture;\\r\nuniform vec2 u_resolution;\\r\nuniform float u_amount;\\r\n\\r\nin vec2 v_uv;\\r\nout vec4 fragColor;\\r\n\\r\nvoid main() {\\r\n    vec4 color = texture(u_texture, v_uv);\\r\n    \\r\n    // Adjust contrast around midpoint (0.5)\\r\n    vec3 result = (color.rgb - 0.5) * u_amount + 0.5;\\r\n    \\r\n    fragColor = vec4(result, color.a);\\r\n}`, { u_amount: [\"amount\", 1] }), r.filters.register(\"hueRotate\", `#version 300 es\\r\nprecision highp float;\\r\n\\r\nuniform sampler2D u_texture;\\r\nuniform vec2 u_resolution;\\r\nuniform float u_angle;\\r\n\\r\nin vec2 v_uv;\\r\nout vec4 fragColor;\\r\n\\r\n// Helper function for HSL to RGB conversion\\r\nfloat hue2rgb(float p, float q, float t) {\\r\n    if (t < 0.0) t += 1.0;\\r\n    if (t > 1.0) t -= 1.0;\\r\n    if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;\\r\n    if (t < 1.0 / 2.0) return q;\\r\n    if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;\\r\n    return p;\\r\n}\\r\n\\r\n// Convert RGB to HSL\\r\nvec3 rgb2hsl(vec3 color) {\\r\n    float maxC = max(max(color.r, color.g), color.b);\\r\n    float minC = min(min(color.r, color.g), color.b);\\r\n    float delta = maxC - minC;\\r\n    \\r\n    vec3 hsl = vec3(0.0);\\r\n    hsl.z = (maxC + minC) / 2.0; // Lightness\\r\n    \\r\n    if (delta == 0.0) {\\r\n        hsl.x = 0.0; // Hue\\r\n        hsl.y = 0.0; // Saturation\\r\n    } else {\\r\n        hsl.y = hsl.z < 0.5 ? delta / (maxC + minC) : delta / (2.0 - maxC - minC); // Saturation\\r\n        \\r\n        if (color.r == maxC) {\\r\n            hsl.x = (color.g - color.b) / delta + (color.g < color.b ? 6.0 : 0.0);\\r\n        } else if (color.g == maxC) {\\r\n            hsl.x = (color.b - color.r) / delta + 2.0;\\r\n        } else {\\r\n            hsl.x = (color.r - color.g) / delta + 4.0;\\r\n        }\\r\n        hsl.x /= 6.0;\\r\n    }\\r\n    \\r\n    return hsl;\\r\n}\\r\n\\r\n// Convert HSL to RGB\\r\nvec3 hsl2rgb(vec3 hsl) {\\r\n    float h = hsl.x;\\r\n    float s = hsl.y;\\r\n    float l = hsl.z;\\r\n    \\r\n    if (s == 0.0) {\\r\n        return vec3(l);\\r\n    }\\r\n    \\r\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\\r\n    float p = 2.0 * l - q;\\r\n    \\r\n    float r = hue2rgb(p, q, h + 1.0 / 3.0);\\r\n    float g = hue2rgb(p, q, h);\\r\n    float b = hue2rgb(p, q, h - 1.0 / 3.0);\\r\n    \\r\n    return vec3(r, g, b);\\r\n}\\r\n\\r\nvoid main() {\\r\n    vec4 color = texture(u_texture, v_uv);\\r\n    \\r\n    // Convert to HSL\\r\n    vec3 hsl = rgb2hsl(color.rgb);\\r\n    \\r\n    // Rotate hue (angle is in degrees, convert to 0-1 range)\\r\n    hsl.x = fract(hsl.x + u_angle / 360.0);\\r\n    \\r\n    // Convert back to RGB\\r\n    vec3 result = hsl2rgb(hsl);\\r\n    \\r\n    fragColor = vec4(result, color.a);\\r\n}\\r\n`, { u_angle: [\"angle\", 0] }), r.filters.register(\"glitch\", `#version 300 es\\r\nprecision highp float;\\r\n\\r\nuniform sampler2D u_texture;\\r\nuniform vec2 u_resolution;\\r\nuniform float u_amount;\\r\n\\r\nin vec2 v_uv;\\r\nout vec4 fragColor;\\r\n\\r\n// Random function\\r\nfloat random(vec2 co) {\\r\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\r\n}\\r\n\\r\nvoid main() {\\r\n    vec2 uv = v_uv;\\r\n    \\r\n    // Create glitch effect based on amount\\r\n    float glitchStrength = u_amount * 0.1;\\r\n    \\r\n    // Horizontal displacement\\r\n    float block = floor(uv.y * 20.0);\\r\n    float noise = random(vec2(block, floor(u_amount * 100.0)));\\r\n    \\r\n    if (noise > 0.7) {\\r\n        uv.x += (noise - 0.7) * glitchStrength * 2.0;\\r\n    }\\r\n    \\r\n    // RGB channel separation (chromatic aberration)\\r\n    float separation = glitchStrength * 0.02;\\r\n    vec2 uvR = uv + vec2(separation, 0.0);\\r\n    vec2 uvG = uv;\\r\n    vec2 uvB = uv - vec2(separation, 0.0);\\r\n    \\r\n    float r = texture(u_texture, uvR).r;\\r\n    float g = texture(u_texture, uvG).g;\\r\n    float b = texture(u_texture, uvB).b;\\r\n    float a = texture(u_texture, uv).a;\\r\n    \\r\n    vec3 color = vec3(r, g, b);\\r\n    \\r\n    // Add scanlines\\r\n    float scanline = sin(uv.y * u_resolution.y * 2.0) * 0.1 * u_amount;\\r\n    color -= scanline;\\r\n    \\r\n    // Add random noise\\r\n    float noiseAmount = random(uv + fract(u_amount)) * 0.1 * u_amount;\\r\n    color += noiseAmount;\\r\n    \\r\n    fragColor = vec4(color, a);\\r\n}\\r\n`, { u_amount: [\"amount\", 0] }), r.filters.register(\"chromaticAberration\", `#version 300 es\\r\nprecision highp float;\\r\n\\r\nuniform sampler2D u_texture;\\r\nuniform vec2 u_resolution;\\r\nuniform float u_amount;\\r\nuniform vec2 u_direction;\\r\n\\r\nin vec2 v_uv;\\r\nout vec4 fragColor;\\r\n\\r\nvoid main() {\\r\n    vec2 texelSize = 1.0 / u_resolution;\\r\n    vec2 offset = u_direction * u_amount * texelSize;\\r\n    \\r\n    // Sample each color channel with different offsets\\r\n    float r = texture(u_texture, v_uv + offset).r;\\r\n    float g = texture(u_texture, v_uv).g;\\r\n    float b = texture(u_texture, v_uv - offset).b;\\r\n    float a = texture(u_texture, v_uv).a;\\r\n    \\r\n    fragColor = vec4(r, g, b, a);\\r\n}\\r\n`, { u_amount: [\"amount\", 5], u_direction: [\"direction\", [1, 0]] }), r.filters.register(\"pixelate\", `#version 300 es\\r\nprecision highp float;\\r\n\\r\nuniform sampler2D u_texture;\\r\nuniform vec2 u_resolution;\\r\nuniform float u_pixelSize;\\r\n\\r\nin vec2 v_uv;\\r\nout vec4 fragColor;\\r\n\\r\nvoid main() {\\r\n    vec2 pixelSize = vec2(u_pixelSize) / u_resolution;\\r\n    vec2 pixelatedUV = floor(v_uv / pixelSize) * pixelSize + pixelSize * 0.5;\\r\n    \\r\n    fragColor = texture(u_texture, pixelatedUV);\\r\n}\\r\n`, { u_pixelSize: [\"pixelSize\", 4] });\n}, async uninstall(r) {\n  r.filters.unregister(\"brightness\"), r.filters.unregister(\"contrast\"), r.filters.unregister(\"hueRotate\"), r.filters.unregister(\"glitch\"), r.filters.unregister(\"chromaticAberration\"), r.filters.unregister(\"pixelate\");\n} });\ntypeof window < \"u\" && (window.createFiltersPlugin = n);\nexport {\n  n as createFiltersPlugin\n};\n"],
  "mappings": ";;;AAAA,IAAM,IAAI,OAAO,EAAE,MAAM,oBAAoB,SAAS,SAAS,MAAM,QAAQ,GAAG;AAC9E,IAAE,QAAQ,SAAS,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiB/B,EAAE,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,SAAS,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiB7D,EAAE,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,SAAS,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAkF/D,EAAE,SAAS,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,SAAS,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAoDzD,EAAE,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,SAAS,uBAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAuBxE,EAAE,UAAU,CAAC,UAAU,CAAC,GAAG,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,SAAS,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAgBjG,EAAE,aAAa,CAAC,aAAa,CAAC,EAAE,CAAC;AACpC,GAAG,MAAM,UAAU,GAAG;AACpB,IAAE,QAAQ,WAAW,YAAY,GAAG,EAAE,QAAQ,WAAW,UAAU,GAAG,EAAE,QAAQ,WAAW,WAAW,GAAG,EAAE,QAAQ,WAAW,QAAQ,GAAG,EAAE,QAAQ,WAAW,qBAAqB,GAAG,EAAE,QAAQ,WAAW,UAAU;AACvN,EAAE;AACF,OAAO,SAAS,QAAQ,OAAO,sBAAsB;",
  "names": []
}
